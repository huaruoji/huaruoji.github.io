{"pages":[{"title":"关于","text":"关于本博客 使用Github Pages+Hexo搭建, 主题是iracus. 使用了AlphaLxy提供的个性化配置方案! 更新日志（从210416始）： 210416： 将评论系统更新为 Disqus （注意：210416以前的文章没有disqus-id，评论可能因为文章地址的改动而丢失） 210421： 在 gitee 搭建了仓库，以后的博客会在 gitee 和 github 同步更新。 210506： 鉴于 gitee 的手动更新机制，博客在 gitee 不定期更新。 210515： 换用支持 hexo 独有 tag 标签的 markdown-it 渲染器，且渲染速度更快。 关于我 My luogu My codforces My AtCoder 关于文章 文章分为\"题解\",\"小记\",\"专题\"和\"杂项\"四种类型.特别说明,\"专题\"中如果出现了例题,一定是在撰写该文章前后2天做到的题(也就是入门题目).其余的题目会发到\"题解\". 所有的文章,如果过长,会加上&lt;!--more--&gt;标签,即\"阅读更多\"效果. 2019年到2020年的文章是从博客园自动迁移过来的，很多存在格式问题（虽然也没什么用）。 2021年3月的文章从CSDN迁移过来。","link":"/about/index.html"},{"title":"","text":"杂物 这是一个段落 good good int a = 3; 猜猜这里有什么","link":"/other/index.html"},{"title":"友链","text":"这里还没有友链~ 请在下方留言,我一定会回复的!","link":"/%E5%8F%8B%E9%93%BE/index.html"}],"posts":[{"title":"【专题】Trie树（基本无用）","text":"pz:Trie树-&gt;字典树 就是查字典用到的树! 具体来说就是一颗26叉树,代表璎文26个字母,这样查询单词起来就变得10分的快速了. build函数,建立Trie树 s(search)函数,查找该使用前缀的单词出现次数 记录一下偶滴辞典 http://acm.hdu.edu.cn/showproblem.php?pid=1251模版题 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; char str[20]; int trie[1000005][26]; int cnt[1000005]; int tot; void build() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) trie[p][str[i]-'a']=++tot; p=trie[p][str[i]-'a']; cnt[p]++; } } int s() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) return 0; p=trie[p][str[i]-'a']; } return cnt[p]; } int main() { ios::sync_with_stdio(false); while\\(gets\\(str\\) \\&amp;\\&amp; str\\[0\\]\\!='\\\\0'\\) \\{ build\\(\\); \\} while\\(scanf\\(&quot;\\%s&quot;,str\\)\\!=EOF\\) \\{ cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​ ​ return 0; } 前缀统计 题目描述 给定N个字符串S1,S2...SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。 输入字符串的总长度不超过10^6，仅包含小写字母。 输入格式 第一行两个整数N，M； 接下来N行每行一个字符串Si ； 接下来M行每行一个字符串表示询问。 输出格式 对于每个询问，输出一个整数表示答案 输入输出样例 输入 #1复制 3 2 ab bc abc abc efg 输出 #1复制 2 0 pz:和模版反了过来,但是代码cbd 修改如下: 1. tot只记录Si尾部字母 2. 询问出现次数 返回值累加 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; char str[1000005]; int trie[1000005][26]; int cnt[1000005]; int tot,n,m; void build() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) trie[p][str[i]-'a']=++tot; p=trie[p][str[i]-'a']; } cnt[p]++; } int s() { int p=0,ans=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) return ans; p=trie[p][str[i]-'a']; ans+=cnt[p]; } return ans; } int main() { ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;str; build\\(\\); \\} for\\(int j=1;j\\&lt;=m;j++\\) \\{ cin&gt;&gt;str; cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​ ​ return 0; } 2020/3/28 20:39","link":"/2020/03/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91Trie%E6%A0%91/"},{"title":"【专题】乘法逆元","text":"乘法逆元,一般用于将模意义下的除法转换为乘法.本文介绍了乘法逆元,并给出了算法实现. 前言: 乘法逆元,一般用于将模意义下的除法转换为乘法 求解普通逆元(\\(ax\\equiv 1(mod\\ m)\\)) 拓展欧几里得 首先我们看看逆元的定义:若\\(ax\\equiv 1(mod \\ m)\\),且a与m互质,则\\(x\\)为\\(a\\)在\\(mod \\ m\\)意义下的乘法逆元,记作\\(a^{-1}\\). 根据这个同余式,我们可以得到\\(ax+km=1\\),且a和m是互质的,那么就满足贝祖等式\\(ax+by=gcd(a,b)\\),可以用拓欧求解. 1234567891011ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)//ax+by{ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y),t=x; x=y,y=t-(a/b)*x; return ret;} 这个板子虽然稍长,但返回值是gcd,用处更广泛 另外,由于gcd求得负数和1最大公约数是-1,exgcd不能用来求解a为负数的情况 快速幂 观察乘法逆元的形式:\\(ax \\equiv1(mod \\ m)\\). 考虑到欧拉定理:\\(a^{\\varphi (m)} \\equiv 1(mod\\ m)\\). 由于洛谷模版题中给出m为质数,则有: \\[ ax \\equiv a^{m-1}(mod\\ m)\\\\a \\equiv a^{m-2}(mod \\ m) \\] \\(那么,a在mod \\ m意义下的乘法逆元即为a^{m-2} mod \\ m\\),满足快速幂形式,可使用快速幂求解. 12345678910111213ll fpm(ll x, ll power, ll mod) { x%=mod; ll ans=1; for (;power;power&gt;&gt;=1,(x*=x)%=mod) if(power&amp;1)(ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);} 代码中的(ans*=x)%=mod即为(ans=ans*x)=(ans=ans*x)%mod.ns*x)%mod`.","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"【专题】二分图","text":"二分图的判定 定理：一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。 利用 DFS 进行染色。如果环的长度为偶数，不会出现颜色相同的冲突，反之则会。 1234567891011bool dfs(int u,int col) { int len=g[u].size(); color[u]=col; for(int i=0;i&lt;len;i++) { int&amp; v=g[u][i]; if(color[v]==color[u]) return false; else if(color[v]==0 &amp;&amp; dfs(v,-col)==false) return false; } return true;}//color[i]为-1,0或1 -1,1表示颜色 0表示是否访问 二分图最大匹配 匈牙利算法 二分图的增广路：增广路是二分图中的一条路径。增广路的起点和终点都是未匹配点。增广路由已选择路径和未选择路径交替组成，也就是说，增广路含有的原本两部之间路径数量为奇数。 将增广路中的所有已选择路径改为未选择路径，未选择路径改为已选择路径，匹配数量就增加了 1 。 匈牙利算法（Hungarian Algorithm）不断寻找增广路，直到找到二分图的最大匹配。 特性：当一个节点成为匹配节点，就不会再变成未匹配节点。（可以用来输出匹配方案） 时间复杂度：\\(O(NM)\\) 1234567891011bool dfs(int u) { int len=g[u].size(); for(int i=0;i&lt;len;i++) { int &amp;v=g[u][i]; if(!vis[v]) { vis[v]=true; if(!mat[v] || dfs(mat[v])) {mat[v]=u;return true;} } } return false;} 其中，vis 数组的作用仅仅是避免单次寻找增广路时的重复搜索，所以每次执行 dfs 前都要清零。 二分图带权最大匹配 等我学了网络流再说 二分图最大独立集 选最多的点，满足两两之间没有边相连。 二分图中，最大独立集 = \\(n\\) - 最大匹配。 二分图最小点覆盖 对于一个二分图，求出一个最小的点集 \\(S\\)，使得图中任意一条边都至少有一个端点属于 \\(S\\)。\\(S\\) 就是这个二分图的最小点覆盖。 König定理：二分图最小点覆盖包含的点数等于二分图最大匹配包含的边数。 构造点覆盖的方法： 求出二分图最大匹配 从左部每个匹配点出发，再执行一次 DFS 寻找增广路的过程，标记访问过的节点。 取左部未被标记的点，右部被标记了点，就得到了二分图的最小点覆盖。","link":"/2021/03/31/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"【专题】平衡树","text":"参考： Splay - OI Wiki (oi-wiki.org) 二叉搜索树（Binary Search Tree） 二叉搜索树是二叉树 空树是二叉搜索树 二叉搜索树上一个节点的右子树上的所有节点的权值大于该节点的权值 二叉搜索树上一个节点的左子树上的所有节点的权值小于该节点的权值 使用二叉搜索树，我们可以很方便的在一堆数中找到，删除，插入一个值。可以发现，对二叉搜索树的操作的时间复杂度与其高度密切相关，即 \\(O(h)\\)。 下面是使用 BST 解决“普通平衡树”的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//丐版BST 不支持重复的 val #include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5,INF=1&lt;&lt;30;int n;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}struct BST { int l,r; int val;}a[N];int tot,root;int make(int val) { a[++tot].val=val; return tot;}void build() { make(-INF),make(INF); root=1,a[1].r=2;}void insert(int &amp;p,int val) { if(p==0) { p=make(val); return; } if(val==a[p].val) return; if(val&lt;a[p].val) insert(a[p].l,val); else insert(a[p].r,val);}int getNext(int val) { int ans=1,p=root; while(p) { if(val==a[p].val) { if(a[p].r&gt;0) { p=a[p].r; while(a[p].l&gt;0) p=a[p].l; ans=p; } break; } if(a[p].val&gt;val &amp;&amp; a[p].val&lt;a[ans].val) ans=p; p=(val&lt;a[p].val)?(a[p].l):(a[p].r); } return ans;}int getPre(int val) { int ans=2,p=root; while(p) { if(val==a[p].val) { if(a[p].l&gt;0) { p=a[p].l; while(a[p].r&gt;0) p=a[p].r; ans=p; } break; } if(a[p].val&gt;val &amp;&amp; a[p].val&lt;a[ans].val) ans=p; p=(val&lt;a[p].val)?(a[p].l):(a[p].r); } return ans;}void remove(int val) { int &amp;p=root; while(p) { if(val==a[p].val) break; p=(val&lt;a[p].val)?(a[p].l):(a[p].r); } if(p==0) return; if(a[p].l==0) p=a[p].r; else if(a[p].r==0) p=a[p].l; else { int nxt=a[p].r; while(a[nxt].l&gt;0) nxt=a[nxt].l; remove(a[nxt].val); a[nxt].l=a[p].l,a[nxt].r=a[p].r; p=nxt; }}int main() { n=read(); int op,x; build(); for(int i=1;i&lt;=n;i++) { op=read(),x=read(); switch(op) { case 1: make(x); break; case 2: remove(x); break; case 5: cout&lt;&lt;a[getPre(x)].val&lt;&lt;endl; break; case 6: cout&lt;&lt;a[getNext(x)].val&lt;&lt;endl; break; } } return 0;} 如果一个二叉搜索树的深度接近 \\(\\log(n)\\)，那么每次操作的期望时间复杂度就为 \\(O(\\log n)\\)，这样的二叉搜索树就比较“平衡”。有很多实现方式使得二叉搜索树保持平衡。 Treap Treap 是 Tree + Heap 的合成词。我们通过对给每个节点增加一个随机生成的优先值，然后维护 BST 使得它满足大根堆的性质。由于优先值是随机生成的，那么堆的形状就近似于完全二叉树，使得 BST 平衡。这可能有点反直觉，为什么 Treap 既可以满足 BST 的性质，又可以满足堆的性质呢？其实，BST 只决定了子树和节点的关系，并未确定严格的父亲和儿子的关系，这给堆的建立留出了条件。 旋式 Treap 既然要满足堆的性质，那么“交换”父亲和儿子是必不可少的。我们需要找到一个合适的处理方式来使得交换父亲和儿子后的树仍然满足 BST 的性质，便有“右旋(zag)“和”左旋(zig)“操作： 光看图可能有些抽象，写成代码就是这样： 12345678void zig(int &amp;p) { //右旋 int q=a[p].l; a[p].l=a[q].r,a[q].r=p,p=q;//注意p是a[x].r或a[x].l的引用 } void zag(int &amp;p) { //左旋 int q=a[p].r; a[p].r=a[q].l,a[q].l=p,p=q;} 这里的引用可能不太好懂，它与后文我们的 Treap 的实现方式密切相关，但意思到了就行。 请注意，无论怎么进行 zig 和 zag 操作，这棵树仍然是 BST！ 为了满足堆的性质，我们需要修改上面模版中 newNode 和 insert 的代码： 123456789101112131415161718192021int newNode(int val) { //插入一个新节点,返回tot a[++tot].val=val; a[tot].dat=rand(),a[tot].cnt=a[tot].size=1; return tot;}void insert(int &amp;p,int val) { //在以p为根的子树上插入一个节点 if(p==0) { p=newNode(val); return; } else if(a[p].val==val) { ++a[p].cnt,update(p); return; } else if(a[p].val&gt;val) { insert(a[p].l,val); if(a[p].dat&lt;a[a[p].l].dat) zig(p); } else { insert(a[p].r,val); if(a[p].dat&lt;a[a[p].r].dat) zag(p); } update(p);} 合理利用 zig 和 zag，将需要删除的节点旋转至叶子节点，就可以实现 remove 操作： 123456789101112131415161718void remove(int &amp;p,int val) { //在以p为根的子树中删除val if(p==0) return; if(val==a[p].val) { if(a[p].cnt&gt;1) { --a[p].cnt,update(p); return; } if(a[p].l || a[p].r) { if(a[a[p].l].dat&gt;a[a[p].r].dat) zig(p),remove(a[p].r,val); else zag(p),remove(a[p].l,val); update(p); } else p=0; return; } val&lt;a[p].val?remove(a[p].l,val):remove(a[p].r,val); update(p);} 剩下的就是繁琐的各种操作了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//模版 普通平衡树#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5,INF=0x7fffffff;int n;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace treap { struct node { int l,r,val,dat,cnt,size; }a[N]; int tot,root; int newNode(int val) { //插入一个新节点,返回tot a[++tot].val=val; a[tot].dat=rand(),a[tot].cnt=a[tot].size=1; return tot; } inline void update(int p) { //当更改了父子关系或cnt时,需要执行update a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt; } void build() { //建立treap,将a[1].val设置为-INF,a[2].val设置为INF newNode(-INF),newNode(INF); root=1,a[1].r=2; update(root); } int getRank(int p,int val) { //根据val找到rank并返回,如果找不到返回INF if(p==0) return INF; if(a[p].val==val) return a[a[p].l].size+1; else if(a[p].val&gt;val) return getRank(a[p].l,val); else return getRank(a[p].r,val)+a[a[p].l].size+a[p].cnt; } int getVal(int p,int rank) { //根据rank找到val并返回,如果找不到返回INF if(p==0) return INF; if(a[a[p].l].size&gt;=rank) return getVal(a[p].l,rank); else if(a[a[p].l].size+a[p].cnt&gt;=rank) return a[p].val; else return getVal(a[p].r,rank-a[a[p].l].size-a[p].cnt); } void zig(int &amp;p) { //右旋 int q=a[p].l; a[p].l=a[q].r,a[q].r=p,p=q;//注意p是a[x].r或a[x].l的引用 update(a[p].r),update(p); } void zag(int &amp;p) { //左旋 int q=a[p].r; a[p].r=a[q].l,a[q].l=p,p=q; update(a[p].l),update(p); } void insert(int &amp;p,int val) { //在以p为根的子树上插入一个节点 if(p==0) { p=newNode(val); return; } else if(a[p].val==val) { ++a[p].cnt,update(p); return; } else if(a[p].val&gt;val) { insert(a[p].l,val); if(a[p].dat&lt;a[a[p].l].dat) zig(p); } else { insert(a[p].r,val); if(a[p].dat&lt;a[a[p].r].dat) zag(p); } update(p); } int getPre(int val) { //获取val的前驱,如果没有则返回-INF int ans=1,p=root; //a[ans].val=-INF while(p) { if(val&gt;a[p].val) ans=p,p=a[p].r; else p=a[p].l; } return a[ans].val; } int getNext(int val) { int ans=2,p=root; //a[ans].val=INF while(p) { if(val&lt;a[p].val) ans=p,p=a[p].l; else p=a[p].r; } return a[ans].val; } void remove(int &amp;p,int val) { //在以p为根的子树中删除val if(p==0) return; if(val==a[p].val) { if(a[p].cnt&gt;1) { --a[p].cnt,update(p); return; } if(a[p].l || a[p].r) { if(a[a[p].l].dat&gt;a[a[p].r].dat) zig(p),remove(a[p].r,val); else zag(p),remove(a[p].l,val); update(p); } else p=0; return; } val&lt;a[p].val?remove(a[p].l,val):remove(a[p].r,val); update(p); } void out(int p) { if(p==0) return; out(a[p].l); cout&lt;&lt;p&lt;&lt;' '&lt;&lt;a[p].val&lt;&lt;endl; out(a[p].r); }}int main() { srand(time(0)); using namespace treap; n=read(); build(); for(int i=1,op,x;i&lt;=n;i++) { op=read(),x=read(); switch(op) { case 1: insert(root,x); break; case 2: remove(root,x); break; case 3: printf(&quot;%d\\n&quot;,getRank(root,x)-1); break; case 4: printf(&quot;%d\\n&quot;,getVal(root,x+1)); break; case 5: printf(&quot;%d\\n&quot;,getPre(x)); break; case 6: printf(&quot;%d\\n&quot;,getNext(x)); break; } } return 0;}","link":"/2021/04/16/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"【专题】初赛位运算","text":"以下摘自洛谷日报 “&lt;&lt;” “&gt;&gt;” 运算 首先，在这里这东西跟 cin cout 没有什么关系。 在二进制运算中，这东西叫做“左移”“右移”运算，顾名思义，就是将一个二进制数向左或向右移动 k 位，就是给一个数乘 2^k 或者除 2^k (末尾1不计)。 那么这东西有什么用呢？这东西快啊 “~”运算 又称取反运算，就是对一个二进制数按位取反。 对于 int 来说， ~ x=-x-1 那么这东西有什么用呢？我也不知道 “&amp;”运算 “&amp;”运算，即“and” 运算，也是一种逻辑运算符，对于二进制运算来说，“&amp;”运算的意义是对于两个二进制数的每一位，如果这一位都是 1 ，那么这一位为 1 ，否则这一位为 0 。 举个例子 10101(21) &amp; 11100(28) = 10100{20} 我们可以用 &amp; 运算判断一个数是奇数还是偶数，当 x 为奇数时， x 二进制下的第 0 位一定是 1 ，否则为 0 。我们让 x &amp; 1 ，就可以知道 x 的奇偶性了。 “|” 运算 即 “or” 运算，也是一种逻辑运算符，对于二进制运算来说，“|” 运算的意义是对于两个二进制数的每一位，如果这两个数此位有一个 1 那么此位就是 1 ，否则为 0 。 举个例子 10101(21) | 11100(28) = 11101(29) 通过对这两个运算的观察，我们可以发现一个规律 x &amp; y&lt;=xx | y&gt;=x 根据二进制的性质很容易就可以得出这些结论吧 “^”运算 “^”运算，又称“xor”运算，异或运算。定义是对于两个二进制数的每一位，如果相同则为 0 ，否则为 1 。 举个例子 10101(21) ^ 11100(28) = 1001(9) 异或是一个非常神奇的东东 首先显而易见的是一个数异或他自己肯定是得 0 的 其次对于一个形如 2n 的数 x ， x ^ 1 =x+1 ,而对于一个形如 2n+1 的数 x ， x ^ 1 =x-1 然后异或运算满足以下交换律 如果 x ^ y=z 那么 y ^ z=x ， x ^ z=y 异或运算还是比较常用到的，简单举两个例子 例题一 给你 n 个数，其中只有一个数出现过一次，其余都成对出现，问只出现过一次的那个数是那个数。 原题 P1469 找筷子（https://www.luogu.org/problemnew/show/P1469） 利用异或的性质 x ^ x=0 ，将所有数异或起来，最后剩下来的那个数就是答案了。 例题二 计算 1 ^ 2 ^ 3 ^ 4 ^ … ^ n 的值 原题 P3908 异或之和（https://www.luogu.org/problemnew/show/P3908） 首先最开始是 1 ，根据异或的性质，我们可以知道 (2n) ^ 1 是等于 2n+1 的 于是我们又回到了 1 ，所以可以得出答案是以 4 为周期循环的。 ------------ 接下来厉害的来了，这三种运算是可以互相转换的 x|y= ~ (( ~ x) &amp; ( ~ y)) x &amp; y= ~ (( ~ x)|( ~ y)) x ^ y=(x|y)-(x &amp; y)=x+y-((x &amp; y)&lt;&lt;1) 但这东西似乎除了能让你感受到位运算的博大精深以外似乎什么用都没有 洛谷日报结束 位运算大部分人都知道，看一道18年初赛题： 14. 为了统计一个非负整数的二进制形式中 1 的个数，代码如下: int CountBit(int x) { int ret = 0; while (x) { ret++; ___________; } return ret; } 则空格内要填入的语句是( )。 A. x &gt;&gt;= 1 B. x &amp;= x - 1 C. x |= x &gt;&gt; 1 D. x &lt;&lt;= 1 答案为B 这种题思路就是先举1个数，再一个一个代入。 如9 二进制为 1001 A选项只会一次删掉一位 1001 100 10 1 答案为4，排除 B选项 1001 &amp; 1000 = 1000 1000 &amp; 0111 = 0 答案为2，正确 C选项 错 D选项 死循环，与A类似","link":"/2019/10/18/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%88%9D%E8%B5%9B%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"【专题】前缀，后缀表达式求值","text":"前缀表达式 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从右至左，遇数压1，遇符弹2，再来计算。 后缀表达式 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从左至右，遇数压1，遇符弹2，再来计算。 例题 https://www.luogu.org/problem/P1449 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; int a[1005],p,top,t; char c; int main() { while(c=getchar()) { if(c=='@') break; if(isdigit(c)) t=t*10+c-'0'; if(c=='.') { a[++top]=t; t=0; } if(c=='+') { a[top-1]=a[top]+a[top-1]; top--; } if(c=='-') { a[top-1]=a[top-1]-a[top]; top--; } if(c=='*') { a[top-1]=a[top]*a[top-1]; top--; } if(c=='/') { a[top-1]=a[top-1]/a[top]; top--; } } cout&lt;&lt;a[top]; return 0; } 注意事项： 1.有除法，并且就按c++里的整除运算 2.getchar()在cstdio里面","link":"/2019/10/19/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%89%8D%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"title":"【专题】区间动态规划","text":"区间动态规划的特征 不同于线性动态规划将一个\"点\"的位置作为状态信息,比如LIS(f[i]表示前i个数的最优解),LCS(\\(f[i][j]\\)表示A串前i个数,B串前j个数的最优解).区间动态规划往往将\"区间\"作为状态信息存储,比如\\(f[l][r]\\)表示区间\\([l,r]\\)的最优解.实际上,线性动态规划可以看做左端点或右端点固定的区间动态规划. 虽然状态信息变了,但是动态规划的本质没有变.在区间动态规划中,一个小区间的最优解满足无后效性,这让它可以扩展到大区间.在解题确定状态时一定要满足这个规则. 例题 P1880 [NOI1995] 石子合并 Des 在一个圆形操场的四周摆放 N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。 Sol 如果不是在圆形操场上摆放,而仅仅是在一条直线跑道上摆放石子的话,本题可能不足以被打上普及+/提高的标签.这种区间在环上的问题也被称作环形动态规划,大佬们已经研究出了套路:变环为链.将样例中环4 5 9 4扩展成链4 5 9 4 9 5 4,这样虽然增加了数据规模,但是降低了状态转移方程算法实现的难度. 将\\(f[i][j]\\)定义为区间\\([i,j]\\)的最优解.显然\\(f[i][j]\\)可以从任意\\(f[i][k],f[k+1][j](i&lt;k&lt;j)\\)转移得到(即两堆合并好的石子).要求出长度为\\(l\\)的区间最优解,必须知道长度为\\(l-1\\)的区间最优解.所以先枚举长度\\(l\\),再枚举左端点\\(i\\),然后计算区间的右端点(\\(i+l-1\\)).最后枚举\\(k\\). 这个时候,变环为链的优越性就体现出来了,无论你怎么取i,j,链中的状态都可以对应到环上去,不会出现答案比原来大或者小的情况.这里要注意,枚举的i的上界必须到\\(2n-1\\).比如\\(f[4][6]\\)的值需要从\\(f[5][6]\\)更新,但\\(f[5][6]\\)没计算怎么行呢? 这种解法的代码可以参考洛谷题解,但我由于是第一次做,使用了自己的方法.我的方法就是将\\(f[i][j]\\)定义为从i开始长度为j的区间的最优解.这样不用变环为链,但下标涉及到取模,容易写错.具体看我的代码吧. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//环形DP #include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,a[N],add[N][N],f[N][N],ans=2e9;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; add[i][1]=a[i]; } for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;=n;i++) { f[i][j]=2e9; int cur=(i+j-1)%n; if(cur==0) cur=n; add[i][j]=add[i][j-1]+a[cur]; for(int k=1;k&lt;j;k++) { cur=(i+k-1)%n; int p2=(i+k)%n; if(p2==0) p2=n;//坑点 f[i][j]=min(f[i][j],f[i][k]+f[p2][j-k]+add[i][j]); } } } for(int i=1;i&lt;=n;i++) { ans=min(ans,f[i][n]); } cout&lt;&lt;ans&lt;&lt;endl; memset(f,0,sizeof(f)); for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;=n;i++) { int cur=(i+j-1)%n; if(cur==0) cur=n; add[i][j]=add[i][j-1]+a[cur]; for(int k=1;k&lt;j;k++) { cur=(i+k-1)%n; int p2=(i+k)%n; if(p2==0) p2=n; f[i][j]=max(f[i][j],f[i][k]+f[p2][j-k]+add[i][j]); } } } for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i][n]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} P1063 [NOIP2006 提高组] 能量项链 Des 在\\(Mars\\)星球上，每个\\(Mars\\)人都随身佩带着一串能量项链。在项链上有\\(N\\)颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是\\(Mars\\)人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为\\(m\\)，尾标记为\\(r\\)，后一颗能量珠的头标记为r，尾标记为\\(n\\)，则聚合后释放的能量为\\(m \\times r \\times n\\)（\\(Mars\\)单位），新产生的珠子的头标记为\\(m\\)，尾标记为\\(n\\)。 需要时，\\(Mars\\)人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设\\(N=4\\)，\\(4\\)颗珠子的头标记与尾标记依次为\\((2,3) (3,5) (5,10) (10,2)\\)。我们用记号⊕表示两颗珠子的聚合操作，(\\(j\\)⊕\\(k\\))表示第\\(j,k\\)两颗珠子聚合后所释放的能量。则第\\(4\\)、\\(1\\)两颗珠子聚合后释放的能量为： (\\(4\\)⊕\\(1\\))\\(=10 \\times 2 \\times 3=60\\)。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为： ((\\(4\\)⊕\\(1\\))⊕\\(2\\))⊕\\(3\\)）=\\(10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710\\)。 Sol 和石子合并简直是一个模子里出来的,这次我换了变环为链的做法. My code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N=505;int n,a[N],hd[N],tl[N],f[N][N],ans;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;hd[i]; for(int i=1;i&lt;n;i++) tl[i]=hd[i+1]; tl[n]=hd[1]; for(int i=n+1;i&lt;n+n;i++) hd[i]=hd[i-n],tl[i]=tl[i-n]; for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;n+n;i++)//注意到2n-1 { int r=i+j-1; for(int k=i;k&lt;r;k++) { f[i][r]=max(f[i][r],f[i][k]+f[k+1][r]+hd[i]*hd[k+1]*tl[r]); } } } for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i][i+n-1]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note 初始化数据的部分我写得不太简洁,但我觉得在不是核心步骤的地方浪费脑力写得简洁没有用,不如把代码写得清晰易懂一点,间接加强鲁棒性. P3146 [USACO16OPEN]248 G Des 给定一个1*n的地图，在里面玩2048，每次可以合并相邻两个（数值范围1-40），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是+1，例如2与2合并后的数值为3。 Sol 说句实话,这道题没做出来,以后做出来了再写.我的程序有一个点WA了,AC的记录是特判直接输出正解的.对于这道题的数据增强版,则有6个点WA了,暂时推测全是因为一个bug. UPD on 210429： 今天 lmk 发了这题的题解我才想起来这道题是乱搞的，并且从 USACO 上搞了数据然后特判了一个点过的。现在来讲讲正解。 注意这道题并不需要整个区间完全合并，答案的最大值可能来源于任何一个合并出的区间。并且合并的规则是：1 + 1 拼出 2; 2 + 2 拼出 3; 3 + 3 拼出 4,,,依此类推。那么，我们需要 2 个拼出了 i 的区间才能拼出 i + 1, 并且这 2 个区间还必须是挨在一起的！ 我们用 f[i][j] 记录以 i 为起点，连续合并出 j 的右端点位置。那么如果 f[i][j]+1 也合并出了 j，显然 f[i][j+1]=f[f[i][j]+1][j]。 与“能量项链”之类的题不同，本题的区间不好控制，也就是说不能拿区间做 dp 数组的下标。本题就是拿区间的“特征值”，即合并出的数字做下标 dp。这样，下标与下标之间有联系，方便转移！ My code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=270000;int n,ans;int f[N][66];int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int t; scanf(&quot;%d&quot;,&amp;t); f[i][t]=i; } for(int i=2;i&lt;=60;i++) { for(int j=1;j&lt;=n;j++) { if(!f[j][i] &amp;&amp; f[j][i-1]) f[j][i]=f[f[j][i-1]+1][i-1]; if(f[j][i]) ans=i; } } printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】可持久化字典树","text":"前言 正好今天考试用了可持久化字典树，不如来写个专题。 例题 P4735 最大异或和 Des 给定一个非负整数序列 \\(\\{a\\}\\)，初始长度为\\(n\\)。 有 \\(m\\) 个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数 \\(x\\)，序列的长度 \\(n+1\\)。 Q l r x：询问操作，你需要找到一个位置 \\(p\\)，满足\\(l \\le p \\le r\\)，使得： $ a[p] a[p+1] ... a[N] x$ 最大，输出最大是多少。 Sol 先来回顾一下普通字典树做异或的题： 有关按位与，或，异或，还有求最大最小值的题，可以利用二进制下的贪心规则，即一定要先满足高位为 1 或 0. 但是某一位相同的数也可能很多，要方便的找到这些数成了问题。 这就不得不说字典树的妙处了：它建立了一个方便的索引机制，且冗余较少。 回到这道题，如果不知道异或的这个性质的话很难做： 设 \\(a\\) 为整数，则有 \\(a \\oplus a = 0\\)。 题外话，利用这一点可以做到交换 2 个数： 12345void swap2(int a, int b) { a ^= b; b ^= a; a ^= b;} 我想诸位都知道是什么意思了，要计算 \\(a[p] \\oplus a[p+1] \\oplus \\cdots \\oplus a[N] \\oplus x\\)，只需要先维护异或前缀和数组 \\(s[i]\\)，然后有 \\(a[p] \\oplus a[p+1] \\oplus \\cdots \\oplus a[N] = s[p-1] \\oplus s[N]\\)。 那么，问题就变成了：对于 \\(l\\le p\\le r\\)，求最大的 \\(s[p-1]\\oplus s[n]\\oplus x\\)。 虽然可以使用 2 个版本的字典树得到答案，但由于只需要知道有没有那个前缀和，不需要知道个数，所以可以给每个节点打上一个 latest 值，如果 latest &lt; l - 1 就不能使用。 My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 6e5 + 5;int n, m, p, s[N];inline int getbit(int x, int k) { return (x &gt;&gt; k) &amp; 1;}namespace trie { int nodeCnt, rt[N]; struct node { int cnt, latest; int ch[2]; }c[N * 28]; void make(const int s, int now, int fa) { c[++nodeCnt] = c[rt[fa]]; rt[now] = nodeCnt; now = nodeCnt; for(int i = 24; i &gt;= 0; i--) { int v = getbit(s, i); if(!c[now].ch[v]) c[now].ch[v] = ++nodeCnt; else { c[++nodeCnt] = c[c[now].ch[v]]; c[now].ch[v] = nodeCnt; } ++c[nodeCnt].cnt; c[nodeCnt].latest = p; now = nodeCnt; } } int query(int u, int l, int val) { if(u == 0) return val; int ans = 0; for(int i = 24; i &gt;= 0; i--) { int v = getbit(val, i); if(c[u].ch[v ^ 1] &amp;&amp; c[c[u].ch[v ^ 1]].latest &gt;= l) u = c[u].ch[v ^ 1], ans += 1 &lt;&lt; i; else u = c[u].ch[v]; } return ans; }}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; char op; int l, r, x; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; s[i] = s[i - 1] ^ x; trie::make(s[i], ++p, i - 1); } for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; op; if(op == 'A') { cin &gt;&gt; x; ++p; s[p] = s[p - 1] ^ x; trie::make(s[p], p, p - 1); } else { cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; trie::query(trie::rt[r - 1], l - 1, x ^ s[p]) &lt;&lt; endl; } } return 0;} Note COGS 上这道题空间卡得超紧！ 晚饭回来还是不要写代码吧 P6088 [JSOI2015]字符串树 Des 字符串树本质上还是一棵树，即 \\(N\\) 个节点 \\(N-1\\) 条边的连通无向无环图，节点从 \\(1\\) 到 \\(N\\) 编号。与普通的树不同的是，树上的每条边都对应了一个字符串。萌萌和 JYY 在树下玩的时候，萌萌决定考一考 JYY。每次萌萌都写出一个字符串 \\(S\\) 和两个节点 \\(U,V\\)，JYY 需要立即回答 \\(U\\) 和 \\(V\\) 之间的最短路径（即 \\(U,V\\) 之间边数最少的路径，由于给定的是一棵树，这样的路径是唯一的）上有多少个字符串以 \\(S\\) 为前缀。 JYY 虽然精通编程，但对字符串处理却不在行。所以他请你帮他解决萌萌的难题。 Sol 字典树 + LCA My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 1e5 + 5;int n, Q;int edgeCnt = 0, head[N];struct edges { int nxt, v; string s;} edge[N];void addEdge(int u, int v, string s) { edge[++edgeCnt].nxt = head[u], head[u] = edgeCnt; edge[edgeCnt].v = v, edge[edgeCnt].s = s;}namespace trie { int nodeCnt, rt[N]; struct node { int cnt; int ch[26]; }c[N * 11]; void make(const string &amp;s, int now, int fa) { int len = s.size(); c[++nodeCnt] = c[rt[fa]]; rt[now] = nodeCnt; now = nodeCnt; for(int i = 0; i &lt; len; i++) { int v = s[i] - 'a'; if(!c[now].ch[v]) c[now].ch[v] = ++nodeCnt; else { c[++nodeCnt] = c[c[now].ch[v]]; c[now].ch[v] = nodeCnt; } ++c[nodeCnt].cnt; now = nodeCnt; } }}namespace LCA { int lg[1 &lt;&lt; 17], f[N][17], dep[N]; void prework() { for(int i = 1; i &lt;= 17; i++) lg[1 &lt;&lt; i] = 1; for(int i = 1; i &lt;= N; i++) lg[i] += lg[i - 1]; } void build(int u, int fa) { dep[u] = dep[fa] + 1, f[u][0] = fa; for(int i = 1; i &lt;= lg[dep[u]]; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = head[u]; i; i = edge[i].nxt) if(edge[i].v != fa) build(edge[i].v, u); } int get(int x, int y) { if(dep[x] &gt; dep[y]) swap(x, y); while(dep[y] &gt; dep[x]) y = f[y][lg[dep[y] - dep[x]]]; if(x == y) return x; for(int i = lg[dep[x]]; i &gt;= 0; i--) if(f[x][i] != f[y][i]) x= f[x][i], y= f[y][i]; return f[x][0]; }}void build(int u, int fa, const string &amp;s) { trie::make(s, u, fa); for(int i = head[u]; i; i = edge[i].nxt) { if(edge[i].v != fa) build(edge[i].v, u, edge[i].s); }}int query(int u, int v, const string &amp;s) { int len = s.size(), anc = LCA::get(u, v); u = trie::rt[u], v = trie::rt[v], anc = trie::rt[anc]; for(int i = 0; i &lt; len; i++) { int to = s[i] - 'a'; u = trie::c[u].ch[to], v = trie::c[v].ch[to], anc = trie::c[anc].ch[to]; } return trie::c[u].cnt + trie::c[v].cnt - 2 * trie::c[anc].cnt;}int main() { ios::sync_with_stdio(false); cin.tie(0); int u, v; string s; cin &gt;&gt; n; for(int i = 1; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; s; addEdge(u, v, s); } build(1, 0, &quot;&quot;); LCA::prework(); LCA::build(1, 0); cin &gt;&gt; Q; for(int i = 1; i &lt;= Q; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; s; cout &lt;&lt; query(u, v, s) &lt;&lt; endl; } return 0;} P4551 最长异或路径 Des 给定一棵\\(n\\)个点的带权树，结点下标从\\(1\\)开始到\\(N\\)。寻找树中找两个结点，求最长的异或路径。 异或路径指的是指两个结点之间唯一路径上的所有边权的异或。 Sol 还是用到异或的性质：\\(a\\oplus a =0\\). 直接用每个节点到根节点的边权异或和建树求解就好。","link":"/2021/05/10/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%97%E5%85%B8%E6%A0%91/"},{"title":"【专题】图的连通性问题","text":"本文参考: https://byvoid.com/zhs/blog/scc-tarjan/ https://oi-wiki.org/graph/bcc/ https://www.cnblogs.com/justPassBy/p/4678192.html 求强连通分量 强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图。 Tarjan 算法 有向图的 DFS 生成树 有向图的DFS生成树有4种边 树枝边(图中绿色):每次从一个访问过的节点到一个未访问过的节点,就形成了树枝边(也就是最后生成树上的边). 返祖边(图中黄色):指向已经访问过的节点,且是祖先节点的边. 横叉边(图中红色):指向已经访问过的节点,但不是祖先节点的边. 前向边(图中蓝色):指向子树节点的边. Tarjan 算法求强连通分量解析 Tarjan 算法利用深度优先搜索,和 DFS 生成树并无直接练习.但介绍 DFS 生成树中的概念有利于讲解 Tarjan 算法. 定义:DFN(u) 为搜索到 u 节点的时间戳,Low(u) 为 u 节点或 u 的子树上的节点通过最多一条前向边或返祖边到达的节点的最小的 DFN(u).当 Low(u) = DFN(u) 时,以 u 为根的搜索子树上的所有节点是一个强连通分量. 由于采用深度优先搜索,可以用栈记录搜索子树. 根据定义,我们可以得出: 123456Low(u)=min{ DFN(u), Low(v),//(u,v)为树枝边,u是v的父节点 DFN(v);//(u,v)为前向边或返祖边} 然后就是图解过程. 首先依 DFS 序搜索,搜到 6 号节点,没有树枝边,前向边,返祖边.Low(6) = DFN(6) = 4,弹出栈中元素直到 6 号节点出栈(实际上也只能弹出 1 个元素,就是 6 号节点).已经弹出的元素即为一个强连通分量.然后回溯. 5 号节点也没有前向边或返祖边,Low(5) = min (Low(6),DFN(5)) = 3.执行输出强连通分量操作,然后回溯. 正常搜索到 4 号节点.有返祖边指向 1 号节点,Low(4) = min(DFN(1),DFN(4)) = 1.然后回溯到 3 号节点,Low(3) = min(DFN(3),Low(4)) = 1. 搜索到 2 号节点,有前向边指向 4 号节点,Low(2) = min(DFN(2),DFN(4)) = 5.然后回溯. 回溯到1号节点,发现 DFN(1) = Low(1),执行输出强连通分量操作(这次可以弹出4个). 至此,所有节点已搜索完. 其实,Tarjan 算法至始至终都在完成一件事:判断当前节点能否与 已经判断连通的节点 连通.对于所有搜索时间戳小于 DFN(u) ,且不在栈中的节点,它们组成了一个强连通子图.如果 u 节点能够到达之前的任意一个节点,那它就可以加入这个强连通子图了. 所谓\"连通\"只需要从时间戳靠前的点到达时间戳靠后的点,而强连通则需要互相到达.从这个角度看, Tarjan 算法其实很质朴.但同时,DFN 和 Low 的思想也极其美妙. Tarjan 算法的时间复杂度 不难发现,每个节点和每条边恰好经过一次.时间复杂度为\\(O(n+m)\\). Tarjan 算法的实现 例题:P3387 【模板】缩点 由于强连通分量内任意2个点互相可达.到达了一个强连通分量内的任意1个点,强连通分量内的所有点都可以产生贡献,并且最后可以从任意一个点出去.那么可以将一个强连通分量看作一个点,入边集为原来所有点的入边(且源点不是强连通分量内的点)的并,出边集同理.该点的权值为所有点的权值和. 使用 Tarjan 算法求出所有强连通分量.给每个节点记录上所在强连通分量的序号,并完成记录权值,入边,出边的操作. 新建的图是 DAG,进行动态规划即可. 图上 DP 大概分为以下几种： \\[ \\text{图上 DP}\\begin{cases} 有环 \\begin{cases} \\text{进行缩点：BFS，DFS 皆可} \\\\ \\text{不进行缩点：只能从父亲开始 DFS} \\end{cases} \\\\ 无环 \\begin{cases} \\text{需要从所有儿子更新信息：DFS}\\\\ \\text{需要从所有父亲更新信息：BFS}\\\\ \\text{否则：皆可} \\end{cases} \\end{cases} \\] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*- 答案最大1e7,用int - 输入1e5,不用快读 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=1e5+5; int n,m,ans;int pointVal[N];vector&lt;int&gt; g1[N],g2[N]; int dfn[N],low[N],scc[N],sccVal[N],idx,tot; bool ins[N];stack&lt;int&gt; s;void tarjan(int u){ dfn[u]=low[u]=++idx; s.push(u),ins[u]=true; int len=g1[u].size(); for(int i=0;i&lt;len;i++) { int v=g1[u][i]; if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { ++tot; int top; do { top=s.top(); scc[top]=tot,sccVal[tot]+=pointVal[top],ins[top]=false; s.pop(); }while(top!=u); }}int vis[N],f[N];int dp(int u){ if(f[u]&gt;0) return f[u]; f[u]=sccVal[u]; int len=g2[u].size(); for(int i=0;i&lt;len;i++) { f[u]=max(f[u],sccVal[u]+dp(g2[u][i])); } return f[u];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;pointVal[i]); } for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); g1[u].push_back(v); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i); } for(int i=1;i&lt;=n;i++) { int len=g1[i].size(),u=scc[i]; for(int j=0;j&lt;len;j++) { int v=scc[g1[i][j]]; if(u!=v) g2[u].push_back(v); } } for(int i=1;i&lt;=tot;i++) { ans=max(ans,dp(i)); } printf(&quot;%d\\n&quot;,ans); return 0;} 其实之前我在补图论基础的时候就做过 DAG DP 问题,但写的实在是惨不忍睹...... kosaraju 算法 kosaraju 前置知识: DFS 记录访问节点的顺序. 前序排列. 在访问节点前将节点加入队列. 后序排列. 在访问节点后将节点加入队列. 逆后序排列. 在访问节点后将节点压入栈. kosaraju算法描述: 先对图进行 DFS ,得到每个节点的逆后序排列的标号(reversPost).按照reversePost从大到小的顺序对原图的逆图进行 DFS 搜索.每次搜索得到的子图就是一个强连通分量. 点双连通分量 无向点双连通图指不存在割点的无向连通图,无向图的极大点双连通子图称为点双连通分量(v-DCC,vertex double connected component). 点双连通图满足以下两个条件中的一个: 点数不超过2 任意2点包含在一个简单图中. 点双连通分量的求解与缩点 一个割点可能属于多个 v-DCC. 在满足割点判定法则后,将栈中元素出栈,与割点共同形成一个 v-DCC(割点不出栈). 将所有割点和所有点双连通分量看作新图中的点,并把每个割点和包含它的 v-DCC 连边,就完成了 v-DCC 的缩点.缩点后的图是一棵树(或森林). 边双连通分量 无向边双连通图指不存在割割边的无向连通图,无向图的极大边双连通子图称为边双连通分量(e-DCC,edge double connected component). 边双连通图满足条件: 任意一条边被包含在一个简单环中. 边双连通分量的求解与缩点 求解边双连通分量需要先找出割边,然后将割边删除.用 DFS 求连通块,每个连通块就是一个边双连通分量.缩点方法与强连通分量缩点类似.缩点后的图是一棵树(或森林). 有向图向强连通图的转化 1. 原有向图是连通图 其实就是P2746 [USACO5.3]校园网Network of Schools. 将连通图中的强联通分量缩点.统计缩点后入度为0,出度为0的点的个数.连边数量取max(in0,out0). 2. 原有向图是非连通图 对每个连通子图进行上面的处理.再把处理好的强联通分量串成一条链.设强联通分量的数量为\\(n\\),则连边树为\\(2\\times (n-1)\\). 无向图向 v-DCC, e-DCC 的转化 1.原无向图是连通图 已知把 v-DCC 或 e-DCC 缩点后整张图变成了一棵树.设树的叶子节点数量为\\(x\\),那么在叶子节点间的连边数量为\\(\\lfloor (x+1)/2\\rfloor\\)(比如,a 向 b 连,c 向 d连).可以归纳证明这样连边是正确的.而且连边数应该就是最少的. 2. 原无向图是非连通图 对每个连通子图进行上面的处理.再把处理好的双联通分量串成一条链.设强联通分量的数量为\\(n\\),则连边树为\\(2\\times (n-1)\\). 例题 P2860 [USACO06JAN]Redundant Paths G Des 为了从F(1≤F≤5000)个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择． 每对草场之间已经有至少一条路径．给出所有R(F-1≤R≤10000)条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量, 路径由若干道路首尾相连而成．两条路径相互分离，是指两条路径没有一条重合的道路．但是，两条分离的路径上可以有一些相同的草场． 对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路． Sol 即无向图转 e-DCC . My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5005,M=10005;int n,m,size=1;//size从2开始 int first[N],out[N];struct node{ int v,next;}edge[M];void addEdge(int u,int v){ edge[++size].v=v; edge[size].next=first[u]; first[u]=size;}int idx;int dfn[N],low[N],cut[M];void tarjan(int u,int fa){ dfn[u]=low[u]=++idx; for(int i=first[u];i;i=edge[i].next) { int v=edge[i].v; if(v==fa) continue; if(!dfn[v]) { tarjan(v,u); low[u]=min(low[u],low[v]); if(dfn[u]&lt;low[v]) cut[i]=cut[i^1]=true; } else low[u]=min(low[u],dfn[v]); }} int vis[N],dccCnt,dcc[N];void dfs(int u){ vis[u]=true; dcc[u]=dccCnt; for(int i=first[u];i;i=edge[i].next) { int v=edge[i].v; if(!vis[v] &amp;&amp; cut[i]==false) dfs(v); }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addEdge(u,v); addEdge(v,u); } tarjan(1,0);//已经是连通图 for(int i=1;i&lt;=n;i++) { if(!vis[i]) { dccCnt++; dfs(i); } } for(int i=1;i&lt;=n;i++) { for(int j=first[i];j;j=edge[j].next) { if(dcc[i]!=dcc[edge[j].v]) out[dcc[i]]++; //一定要判断是否属于同一个连通块! } } int leaf=0; for(int i=1;i&lt;=dccCnt;i++) { if(out[i]==1) leaf++; } if(dccCnt&lt;=2) printf(&quot;0\\n&quot;);//e-DCC 判定法则 else printf(&quot;%d\\n&quot;,(leaf+1)/2); return 0;} Note 这种可用异或求反向边的邻接表,size 一定要从2开始,否则会造成数值混淆. 不能用vector了TAT 记录 DCC 的出度时要记得判断2个点是否在同一个 DCC !","link":"/2021/03/16/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"title":"【专题】埃氏素数筛法(Eratosthenes)","text":"埃氏筛法: 对于每一个小于n的非负整数p,删去2p,3p,4p......,当处理完所有数后,还没有删除的就是素数. 想法:用a记录素数表,a[i]=1表示不是素数,a[i]=0表示是素数. #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int n,m,a[10000005],t; int main() { a[1]=1; cin&gt;&gt;n&gt;&gt;m; int pd=sqrt(n+0.5); for(int i=2;i&lt;=pd;i++) if(!a[i]) for(int j=i*i;j&lt;=n;j+=i) a[j]=1; // for(int i=1;i&lt;=100;i++) // cout&lt;&lt;a[i]&lt;&lt;endl; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;t; if(a[t]==0) cout&lt;&lt;\"Yes\\n\"; else cout&lt;&lt;\"No\\n\"; } return 0; } 注意:1不是素数,需要特判!","link":"/2019/10/20/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%9F%83%E6%B0%8F%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95(Eratosthenes)/"},{"title":"【专题】字典树(Trie)","text":"字典树用于解决 有多个长度短的字符串的问题 异或问题.本文包含了几道简单题. 前言: 字典树用于解决 有多个长度短的字符串的问题 异或问题 #2122 【模板】电话簿 处理每个电话号码时要输出NO有2种情况,一是某个已经处理的电话号码是它的前缀,二是它是某个已处理的电话号码的前缀,2种情况分别处理即可,注意trie[0]也需要清零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int t,n,trie[maxn][30],end[maxn],size;char str[15];bool insert(int v){ int now=0; for(int i=0;str[i]!='\\0';i++) { if(end[now]) return false; int son=str[i]-48; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=v; for(int i=0;i&lt;=9;i++) if(trie[now][i]) return false; return true;}void empty(){ memset(end,0,sizeof(end)); size=0; memset(trie[0],0,sizeof(trie[0]));}int main(){ cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; bool flag=false; for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;,str); if(insert(1)==false) { flag=true; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); empty(); } return 0;} #2204 秘密消息 与第一题类似,若密码可以匹配信息,有2种情况,一是信息是密码的前缀,二是密码是信息的前缀.且此题需要统计个数,则建立2个数组tot和end.tot统计当前节点向下有多少个单词,用于计算是密码是信息前缀的信息数量;end统计在当前节点有多少个单词结束,用于计算信息是密码前缀的信息数量. 将密码在字典树中匹配,将沿途的tot累加为ans,若密码长度大于可匹配长度,则ans可直接输出.若密码长度小于可匹配长度,则输出ans-end[now]+tot[now],即加上密码是信息前缀的信息数量(+tot[now),因为在now节点结束的信息对tot有贡献,需减去(-end[now]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,m,len,trie[maxn][30],tot[maxn],end[maxn],size;int key[maxn],info[maxn];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-') s=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s*x;}void insert(int v,int len){ int now=0; for(int i=1;i&lt;=len;i++) { int son=key[i]; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); trie[now][son]=size; } now=trie[now][son]; tot[now]++; } end[now]++;}int query(int len){ int now=0,ans=0; bool flag=false; for(int i=1;i&lt;=len;i++) { if(trie[now][info[i]]==0) { flag=true; break; } now=trie[now][info[i]]; ans+=end[now]; } if(flag==false) return ans-end[now]+tot[now]; else return ans; }int main(){ m=read(); n=read(); for(int i=1;i&lt;=m;i++) { len=read(); for(int j=1;j&lt;=len;j++) { key[j]=read(); } insert(1,len); } for(int i=1;i&lt;=n;i++) { len=read(); for(int j=1;j&lt;=len;j++) { info[j]=read(); } printf(&quot;%d\\n&quot;,query(len)); } return 0;} #3827 The XOR Largest Pair 将每个数按照二进制存进字典树,从最高位按\"先走不同,再走相同\"的贪心规则向下走. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*将每个数转为2进制,从高位开始建立trie树,按照贪心原则向下走,同时记录走过位数,最后还原 */#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,t,ans,trie[maxn][30],end[maxn],size;int pow_2[35];int to2(int x,int *a){ int p=-1; while(x) { a[++p]=x%2; x/=2; } return p;}int insert(int *a,int len){ int now=0,ret=0,xor_now=0; for(int i=30;i&gt;=0;i--)//共31位,最大是2^31-1,满足题目要求 { int son=a[i]; //下方操作只有在操作第一个数时不安全 if(trie[xor_now][!son])//和当前位相反的数是否有 { ret+=pow_2[i]; xor_now=trie[xor_now][!son]; } else { xor_now=trie[xor_now][son]; } if(trie[now][son]==0) { ++size; end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=1; return ret; }int main(){ //初始化打表 pow_2[0]=1; for(int i=1;i&lt;=30;i++) { pow_2[i]=pow_2[i-1]*2; } cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;t; int t_2[35]; memset(t_2,0,sizeof(t_2)); int now_ans=insert(t_2,to2(t,t_2)); if(now_ans&gt;ans &amp;&amp; i!=1) ans=now_ans; } cout&lt;&lt;ans; return 0;} 总结: 字典树大部分题目的核心操作是在添加单词时进行的,正确性涉及到字典树的特殊结构(添加一个单词,若与前面添加的单词有关系,则在此时就会被处理;若与后面添加的单词有关系,会在后面被处理). 字典树可很好的解决前缀/后缀问题 字典树可解决部分关于位运算操作的问题(将数转为01串,建立0-1 trie)","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E5%85%B8%E6%A0%91(Trie)/"},{"title":"【专题】字符串匹配(KMP+普通算法)","text":"字符串匹配 定义母串为S,子串为T,在S中寻找到T,即为字符串匹配 普通匹配算法 12345678910k=0;for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;t.length();j++) { if(s[k]==t[j]) continue; else cout&lt;&lt;&quot;Fail&quot;,break; } k=i-j+2//此处最重要} 假设t串长度为5,第一次循环后k也为5","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D(KMP+%E6%99%AE%E9%80%9A%E7%AE%97%E6%B3%95)/"},{"title":"【专题】字符串哈希(入门)","text":"前言: 本文介绍了字符串哈希,并带有几道入门题目. 字符串哈希 什么是字符串哈希 字符串哈希与一个数字建立对应关系,用于字符串的判重,效验. 在字符串哈希的过程中,如果字符串太长,可能出现多个字符串对应同一个数的情况,称作哈希冲突.为了避免哈希冲突,需要选择合适的模数与基数(通常为质数). 基础做法 实现方法:hash[i]=(hash[i-1]*base+s[i])%p 这里的base被称为基数,p被称为模数. 在这个过程中,hash[i]可能会超int范围,因此一般将其的数据类型设置为long long. 进阶做法 自然溢出法: 将hash[i]的设置类型设置为unsigned long long,利用无符号类型的自然溢出规则,省去%p的过程. 双哈希: 对一个字符串用2对不同的模数与基数操作,得到hash[1],hash[2].&lt;hash[1],hash[2]&gt;便是最终的哈希值. 防止生成数据卡哈希/哈希冲突 自然溢出法的模数(18446744073709551615)虽然不是质数,但够大,因此选用自然溢出法. 双哈希,冲突率可看作单哈希冲突率的平方. 随机base法 来自https://www.luogu.com.cn/problem/solution/P4503中lyyi03的题解. 设\\(pw_i=base^i\\)，则传统哈希的哈希值\\(hash=\\sum pw_i*s[i]\\)，但我这里的哈希是将\\(pw_i\\)换成一个long long范围内的随机数，这样就可以防卡哈希了． 题目 P3370 【模板】字符串哈希 My code: 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=1e4+5,mod=1e9+7,base=131;int n,ans;ll a[N];string s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; int len=s.length(); for(int j=0;j&lt;len;j++) { a[i]=(a[i]*base+(ll)s[j])%mod; } } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]==a[i+1]) ans++; } cout&lt;&lt;n-ans; return 0;} P4305 [JLOI2011]不重复数字 HINT: 使用vector判重 My code: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n,hash_num=50021,t,temp;vector&lt;int&gt; a[50022];int main(){ ios::sync_with_stdio(false); //快速读入 cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; memset(a,0,sizeof(a));//重置hash表 for(int j=1;j&lt;=n;j++) { cin&gt;&gt;temp;//输入当前数据 int hash=temp%hash_num;//hash过程 bool pd=false; if(a[hash].empty()==false) { for(int k=0;k&lt;a[hash].size();k++) { if(a[hash][k]==temp)//判断hash表中是否有当前元素 pd=true; } } else if(pd==false) { a[hash].push_back(temp);//如果hash表中没有,加入hash表并输出 printf(&quot;%d &quot;,temp); } } printf(&quot;\\n&quot;); }} P4503 [CTSC2014]企鹅QQ HINT: 不得不说hzwer的代码真是太强了,就借鉴了一下. 在他的代码中,使用了自然溢出法,并有类似双哈希的方法防止被卡. Bugs: #define ll unsigned long long后误打了分号 B1和B2过小(三十几),被hack掉了3个点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;const int N=3e4+5,B1=149,B2=137;int n,l,s,ans;ll H1[N][205],H2[N][205],t[N];char qq[205];void cal(int x){ for(int i=1;i&lt;=l;i++) H1[x][i]=H1[x][i-1]*B1+qq[i]; for(int i=l;i&gt;=1;i--) H2[x][i]=H2[x][i+1]*B2+qq[i];}int main(){ cin&gt;&gt;n&gt;&gt;l&gt;&gt;s; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,qq+1); cal(i); } for(int i=1;i&lt;=l;i++) { for(int j=1;j&lt;=n;j++) { t[j]=H1[j][i-1]*233+H2[j][i+1]*213; } sort(t+1,t+n+1); int now=1; for(int j=1;j&lt;n;j++) { if(t[j]!=t[j+1]) now=1; else { ans+=now; now++; } } } printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】并查集(入门)","text":"前言: 本文介绍了并查集及其优化(启发式合并和路径压缩),并提供了几道入门题目. 并查集 什么是并查集 并查集用于查询和合并多组关系,最常见的例子就是处理家族关系问题,需要查找成员关系和合并家族.并查集需要提供合并和查找操作. 简单实现 初始化 建立father[n]数组将father[i]初始化为i 查找操作 12345int find(int x){ if(father[x]==x) return x; else return find(father[x]);} 合并操作 12345void merge(int x,int y){ x=find(x),y=find(y); fa[x]=y;} 算法优化 路径压缩算法 用于优化并查集查找操作的时间复杂度 一个例子,若a,b,c,d满足这样的关系:a&lt;-b&lt;-c&lt;-d,&lt;-箭头表示左边的是右边的父亲.那么在每次find(d)的过程中将会经历4次递归.每次我们都找到了d的祖先是a,但没有将这个关系记录下来.由于只需要查找一个元素的祖先,将father[d]设为a也未尝不可.将查找路径上的每个节点直接连接到根上,这就是路径压缩算法.如下面的代码. 12345int find(x){ if(father[x]!=x) father[x]=find(father[x]);//if中的条件用于处理根节点,后面的语句包含了递归和优化的操作 return father[x];} 启发式合并(按秩合并) 用于优化并查集合并操作的时间复杂度 滑稽村庄和阴险村庄要被拆迁了,政府告诉它们两个村庄拆迁二选一.由于滑稽村庄的人数远大于阴险村庄,两村的村长协商后,决定让阴险村庄的居民暂时在滑稽村庄居住. 你已经发现了,对于两组关系的合并来说,数量少的合并到数量大的似乎要方便些.事实上在并查集的操作中也是这样的.我们便有了算法: 123456789int father[n],size[n];//初始化时新增了size数组void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];//不需要处理size[x]} 这种受到人类经验启发的算法称作启发式算法. 时间复杂度 路径压缩 启发式合并 时间复杂度 批注 × √ \\(O(m\\ log\\ n)\\) 最坏 √ × \\(O(m\\ log_{1+m/n}\\ n)\\),\\(O(m\\alpha (m,n))\\) 最坏,平均 √ √ \\(O(m\\alpha(m,n))\\) 最坏 其中,m表示find操作次数,n表示合并操作次数.\\(\\alpha()\\)函数为Ackermann函数的反函数,在OI中你可以认为是一个小于4的常数. 对于一般的题,使用路径压缩和启发式合并即可.有些题目不能使用路径压缩,因此学习启发式合并还是很有必要的. 题目 P3367 【模板】并查集 - 洛谷 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,z,x,y,father[10005],size[10005];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];} int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { father[i]=i,size[i]=1; } for(int i=1;i&lt;=m;i++) { z=read(),x=read(),y=read(); if(z==1) merge(x,y); else { x=find(x),y=find(y); if(x==y) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } } return 0;} P2758 村村通 Sol 将有公路连接的两个城市合并,最后输出连通块个数. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int INF=1e9,N=1e3+5;int n,m,fa[N],size[N],num;int find(int x){ if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];}void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; num--; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; fa[x]=y;}int main(){ while(cin&gt;&gt;n&amp;&amp;n) { cin&gt;&gt;m; for(int i=1;i&lt;=n;i++) { fa[i]=i; size[i]=1; } num=n; for(int i=1;i&lt;=m;i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; merge(x,y); } cout&lt;&lt;num-1&lt;&lt;endl; } return 0;} P1111 修复公路 - 洛谷 Sol 初始化num为n,代表现存集合个数.显然若只存在一个集合,所有村庄都可通车. 在merge时,如果x和y所在集合不同,将num--.直到num=1时输出t. Note 到这道题才发现之前的板子有点问题...在merge时如果x和y已经在同一个集合了,就不用合并. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005,M=1e5+5;int n,m,father[N],size[N],num;//num表示现存集合个数 struct relation{ int x,y,t; bool operator &lt; (const relation &amp;b) const //如果要结构体排序,也可使用这种方法,注意是重载小于运算符 { if(t&lt;b.t) return true; else return false; }}a[M];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x]; }void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; num--; father[x]=y;}int main(){ n=read(),m=read(); num=n; for(int i=1;i&lt;=n;i++) father[i]=i,size[i]=1; for(int i=1;i&lt;=m;i++) { a[i].x=read(),a[i].y=read(),a[i].t=read(); } sort(a+1,a+m+1); for(int i=1;i&lt;=m;i++) { merge(a[i].x,a[i].y); if(num==1) { printf(&quot;%d\\n&quot;,a[i].t); return 0; } } printf(&quot;-1\\n&quot;); return 0;} [P3958 NOIP2017 提高组] 奶酪 - 洛谷 Sol 首先判断2个球的位置的方法很容易推出来,如果(dist(a,b)&lt;=2r),那么2个球相交或相切. 暴力两两判断球是否连通,若连通则合并,最后判断每个集合是否能到达顶和底即可.时间复杂度复杂度为\\(O(Tn^2\\alpha (n))\\). Note 点坐标的绝对值不超过\\(10^9\\)计算2点距离过程会爆int. 12345double dist(int x,int y){ int m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z;//应把int改为long long return sqrt(m1*m1+m2*m2+m3*m3);} 另外,dist(i,j)&lt;=2*r涉及到了隐式转换,复习一下(来自cnblogs) C语言自动转换不同类型的行为称之为隐式类型转换 ，转换的基本原则是：低精度类型向高精度类型转换，具体是： int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; long long -&gt; unsigned long long -&gt; float -&gt; double -&gt; long double 也就是说,long long类型和double比较,long long会被提升至double My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define R registerusing namespace std;const int N=1005;int t,n,h,r,father[N],size[N];bool top[N],flo[N],flag[N][2];struct ball{ int x,y,z;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } double dist(int x,int y){ long long m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z; return sqrt(m1*m1+m2*m2+m3*m3);}int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y;}int main(){ t=read(); for(R int i=1;i&lt;=t;i++) { n=read(),h=read(),r=read(); memset(top,0,sizeof(top)); memset(flo,0,sizeof(flo)); for(R int j=1;j&lt;=n;j++) { father[j]=j;size[j]=1; a[j].x=read(),a[j].y=read(),a[j].z=read(); if(a[j].z+r&gt;=h) top[j]=true;//判断元素是否通顶 if(a[j].z-r&lt;=0) flo[j]=true;//判断元素是否通底 } for(R int j=1;j&lt;=n;j++) { for(R int k=j+1;k&lt;=n;k++) { if(dist(j,k)&lt;=2*r) { merge(j,k); } } } memset(flag,0,sizeof flag); for(R int j=1;j&lt;=n;j++) { int fa=find(j); if(top[j]) flag[fa][0]=true; if(flo[j]) flag[fa][1]=true; } bool yes=false; for(R int j=1;j&lt;=n;j++) { if(flag[j][0]&amp;&amp;flag[j][1]) { printf(&quot;Yes\\n&quot;); yes=true; break; } } if(!yes) printf(&quot;No\\n&quot;); } return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】快速幂(含矩阵快速幂)","text":"本文介绍了快速幂与矩阵快速幂,并实现了简单运用. 前言: 矩阵快速幂就是缝合怪 快速幂 这篇文章写的真心好啊,%%%.其实在理解其它的算法时,用纸笔推导每一步在干什么,也能达到差不多的理解程度,所以一定要耐心. 首先给一个幂运算: a p a^p ap 在代码实现中,实现p次方的复杂度为 O ( p ) O(p) O(p).我们考虑缩减指数,若p是偶数,则 a p = ( a ∗ a ) p 2 a^p=(a*a)^{\\frac p 2} ap=(a∗a)2p​.只进行了一次乘法运算,却将指数缩减到了原来的二分之一(这也是为什么快速幂的复杂度是 l o g n log\\ n logn). 有了想法,我们再看能不能实现.由唯一分解定理得:整数 m = ∏ a i p i = ∏ a i 2 k + n = ∏ ( a i 2 k ) 1 ( a i n ) 1 m=\\prod a_i^{p_i}=\\prod a_i^{2k+n}=\\prod (a_i^{2k})^1(a_i^{n})^1 m=∏aipi​​=∏ai2k+n​=∏(ai2k​)1(ain​)1,也就是说,m可分解为若干个幂次为1的数的乘积(好像是废话),那么,在缩减指数的时候,若 p m o d 2 = = 1 p\\ mod \\ 2==1 pmod2==1,ans*=a即可. 初步代码： 123456789101112131415ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;1) { if(p%2==1) { ans=(ans*a)%mod; } p/=2; a=(a*a)%mod; } ans=(ans*a)%mod; return ans;} 优化代码: 1234567891011ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;=1) { if(p&amp;1) (ans*=a)%=mod; p&gt;&gt;=1; (a*=a)%=mod; } return ans%mod;} 分析while循环,每次做的事为p&gt;&gt;=1和(a*=a)%=mod,结束条件为p&gt;=1,可将其改写为for循环节省行数 1234567ll fpm(ll a,ll p,ll mod){ ll ans=1; for(;p;p&gt;&gt;=1,(a*=a)%=mod) if(p&amp;1) (ans*=a)%=mod; return ans%mod;} 注意(a*=a)%=mod)是在if(p&amp;1) (ans*=a)%=mod;后执行的. 矩阵快速幂 矩阵乘法已经在线性代数中提到了.顾名思义,矩阵快速幂用于解决诸如 A p A^p Ap的问题,为什么会用到一个矩阵的幂呢?我们先来回顾斐波那契数列 f n = f n − 1 + f n − 2 f_n=f_{n-1}+f_{n-2} fn​=fn−1​+fn−2​,这个简单的递推式在数据规模为1e7时能轻松通过,但到了1e8便很危险了.这时候矩阵便派上用场了. 斐波那契数列的第n项有通项公式 F n = ( 5 + 1 2 ) n − ( 5 − 1 2 ) n 5 F_n= \\frac {(\\frac {\\sqrt{5}+1} {2})^n-(\\frac{\\sqrt{5}-1}{2})^n } {\\sqrt 5} Fn​=5 ​(25 ​+1​)n−(25 ​−1​)n​,但对精度要求极高,不适用.但我们能不能构造一个类似的通项公式,只不过求出的是一个矩阵呢? 可能你会疑惑,为什么要求一个矩阵呢?请看 [ f n f n − 1 ] \\begin{bmatrix}f_n\\\\f_{n-1}\\end{bmatrix} [fn​fn−1​​],这是不是一个矩阵?求出的是不是斐波那契数列?这样,我们的矩阵、快速幂与递推便有机统一了.现在到了在做题时最有思维难度的部分:构造矩阵. 思考: [ f [ i ] f [ i − 1 ] ] = [ a b c d ] × [ f [ i − 1 ] f [ i − 2 ] ] \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}a&amp;b\\\\c&amp;d\\end{bmatrix}\\times\\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[ac​bd​]×[f[i−1]f[i−2]​] 第一个矩阵该填什么?首先它肯定是长这个样子的,也就是要找出a,b,c,d满足 a × f [ i − 1 ] + b × f [ i − 2 ] = f [ i ] a\\times f[i-1]+b\\times f[i-2]=f[i] a×f[i−1]+b×f[i−2]=f[i] c × f [ i − 1 ] + d × f [ i − 2 ] = f [ i − 1 ] c\\times f[i-1]+d\\times f[i-2]=f[i-1] c×f[i−1]+d×f[i−2]=f[i−1] c=1,d=2是显然的,a和b等于多少呢?但观察形式,它不就是最基本的斐波那契递推式吗? 于是就有了: f [ i ] = 1 × f [ i − 1 ] + 1 × f [ i − 2 ] (1) \\tag 1f[i]=1\\times f[i-1]+1\\times f[i-2] f[i]=1×f[i−1]+1×f[i−2](1) f [ i − 1 ] = 1 × f [ i − 1 ] + 0 × f [ i − 2 ] (2) \\tag 2f[i-1]=1\\times f[i-1]+0\\times f[i-2] f[i−1]=1×f[i−1]+0×f[i−2](2) 由(1)(2)发现式(3) [ f [ i ] f [ i − 1 ] ] = [ 1 1 1 0 ] × [ f [ i − 1 ] f [ i − 2 ] ] (3) \\tag 3 \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}\\times \\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[11​10​]×[f[i−1]f[i−2]​](3) ohhhhhhh!构造出来了!剩下的不就简单多了吗,根据式(3)归纳出式(4) [ f [ n + 1 ] f [ n ] ] = [ 1 1 1 0 ] n − 1 × [ f [ 2 ] f [ 1 ] ] (4) \\tag 4 \\begin{bmatrix}f[n+1]\\\\f[n]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}^{n-1}\\times \\begin{bmatrix}f[2]\\\\f[1]\\end{bmatrix} [f[n+1]f[n]​]=[11​10​]n−1×[f[2]f[1]​](4) 至此,我们已经完成了\"构造一个矩阵的通项公式\"的任务了,可以编写代码了. 接下来该考虑的事情是如何将矩阵乘法运算套入快速幂,在快速幂的求解中,即将 a p a^p ap拆分成若干个幂次为1的数的乘积,只用到了结合律,显然其对矩阵乘法的运算也是成立的.(其实在这里也满足交换律,毕竟全都是同一个矩阵A).那么我们直接将快速幂中涉及到乘法的部分换为矩阵乘法即可. 12345void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);} 封装了一个矩阵板子,支持乘法操作(我居然自己造了一个板子,太不可思议了) 123456789101112131415161718struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }}; P3390 【模板】矩阵快速幂 索然无味的AC代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);}int main(){ cin&gt;&gt;n&gt;&gt;k; matrix a; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;a.g[i][j]; } } matrix ans; //构造单位矩阵 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i==j) ans.g[i][j]=1; else ans.g[i][j]=0; } } fpm_mat(ans,a,k); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cout&lt;&lt;ans.g[i][j]&lt;&lt;' '; } cout&lt;&lt;endl; } return 0;} 这里涉及到一个叫做单位矩阵(identity matrix)的东西,就是主对角线上元素全为1的矩阵. I × A = A I\\times A=A I×A=A. 好了,回到我们的斐波那契数列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt() { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a,2,2)) if(p&amp;1) ans.mul(a,2,2);}int main(){ cin&gt;&gt;n; if(n==1) { cout&lt;&lt;1; return 0; } matrix a,idt; idt.idt(); a.g[1][1]=1,a.g[1][2]=1,a.g[2][1]=1,a.g[2][2]=0; fpm_mat(idt,a,n);//结果存在idt里 matrix f; f.g[1][1]=1,f.g[2][1]=1; idt.mul(f,2,1); cout&lt;&lt;idt.g[2][1]; return 0;} 代码虽然AC了,但是因为状态不好,写的极度糟糕. 改进了一下板子,增加了idt构造单位矩阵功能: 1234567891011121314151617181920212223242526struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt(int n) { for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};","link":"/2021/02/03/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82(%E5%90%AB%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82)/"},{"title":"【专题】快速读写相关","text":"快速读入 最基础版本，主要思想是一个一个读入 12345678910111213141516int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v1 这个版本很好理解,可以加上inline快一点 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v2 最后加上位运算以及手写isdigit函数 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if(c=='-') s=-s; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { a=(a&lt;&lt;1)+(a&lt;&lt;3)+(ch^48); c=getchar(); } return s*a;}//v3","link":"/2020/05/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/"},{"title":"【专题】扩展欧几里得算法(exgcd)","text":"前言：本文介绍了扩展欧几里德算法，并给出了算法模版 欧几里得算法 首先我们来回顾一下求解2个数的最大公约数(gcd,Greatest Common Divisor)的欧几里得算法: 这个算法的核心是\\(gcd(a,b)=gcd(b,a \\ mod \\ b)\\),即\\(a\\)和\\(b\\)的公约数等于\\(b\\)和\\(a \\ mod \\ b\\)的公约数. 至于为什么,oi-wiki上有,我们就不证了,但为了理解这个公式,我们举个例子 \\[ gcd(3,5)=gcd(5,3)=gcd(2,3)=gcd(3,2)=\\\\gcd(1,2)=gcd(2,1)=gcd(1,1)=gcd(0,1)=gcd(1,0) \\] 然后你会发现,我们将要用1去模0了,但这显然是没有意义的*(a模b的定义为a除以b的余数).并且,1和0是没有公约数的(0没有任何约数),那么我们的程序好像就无法继续进行了.我们又观察到,5和3因为互质,最大公约数是1,恰好是当b=0的时候a的值.那么,其他的数进行gcd操作也会有这样的性质吗? 再来个例子 \\[ gcd(4,2)=gcd(0,2)=gcd(2,0) \\] 好像确实是这样的!我们只需输出当b等于0时a的值即可! 实际上,当b=0时,就代表着前一步的a%b==0,也就是\\(b|a\\),那么我们的最大公约数显然就是b(下一步的a)了. *如果你编译运行1%0这段代码,编译器报错[Warning] division by zero [-Wdiv-by-zero],程序RE 这样就可以写出代码: 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); } 在进入下一部分前,我们先来分析一下这个算法的复杂度.细心的读者已经发现了,上面的例子中有些操作是无效的,他们仅仅交换了a和b的位置,但对于程序运行来说,这是必需的.但他们的数量显然小于等于有效操作的数量,对于时间复杂度的分析来说可以略去. 回顾到取模这个运算,在正数意义下它的代码可以写成这样(你是否知道负数的取模运算?可以参考这篇文章): 1while(a&gt;b) a-=b//=a%b 实际上,G++中实现的取模不是这么简单.具体来说,若\\(a=qb+r\\),则\\(a \\ mod \\ b=r\\)(例:7%(-3)=1 -7%(-3)=-1 -7%3=-1).并且,G++的原则是使商尽可能大 有点扯远了,最重要的是知道上面在正数意义下的代码!我们再来举几个例感性理解一下复杂度 不用感性理解了,请读者们自己思考吧,我直接说结论好了,gcd中的有效操作至少能让a减半. 那么,gcd的复杂度就为\\(log \\ n\\) 补充知识: 多个数的最大公约数/最小公倍数求法:每次取出2个数求得最大公约数/最小公倍数后将最大公约数/最小公倍数放回去 算数基本定理(用于求lcm,Least Common Multiple,最小公倍数):\\(gcd(a,b) \\times lcm(a,b)=a \\times b\\) 扩展欧几里德算法(exgcd) 恶心gcd 扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求\\(ax+by=gcd(a,b)\\)的一组可行解。 P.S 原来extra指额外,extend才是扩展... 定理:\\(x_1=y_2,y_1=x_2-\\lfloor \\frac a b \\rfloor\\) 证明(摘自oi-wiki,但手写一遍才能更好的弄懂): &gt;设 &gt; \\(ax_1+by_1=\\gcd(a,b)\\) &gt; \\(bx_2+(a\\bmod b)y_2=\\gcd(b,a\\bmod b)\\) &gt;由欧几里得定理可知： \\(\\gcd(a,b)=\\gcd(b,a\\bmod b)\\) &gt;所以 \\(ax_1+by_1=bx_2+(a\\bmod b)y_2\\) &gt;又因为 \\(a\\bmod b=a-(\\lfloor\\frac{a}{b}\\rfloor\\times b)\\) &gt;所以 \\(ax_1+by_1=bx_2+(a-(\\lfloor\\frac{a}{b}\\rfloor\\times b))y_2\\) &gt; \\(ax_1+by_1=ay_2+bx_2-\\lfloor\\frac{a}{b}\\rfloor\\times by_2=ay_2+b(x_2-\\lfloor\\frac{a}{b}\\rfloor y_2)\\) &gt;因为 \\(a=a,b=b\\) ，所以 \\(x_1=y_2,y_1=x_2-\\lfloor\\frac{a}{b}\\rfloor y_2\\) 证明中比较重要的就是这个式子(其实就是取模运算的数学表达式): \\[ a \\ mod \\ b=a-\\lfloor \\frac a b \\rfloor \\times b \\] 知道了\\(x\\)和\\(y\\)的递归表达式,我们就可以进行程序设计了. 既然是递归,就一定有最底层的\\(x\\)和\\(y\\)能够让我们轻易求出值,回到基础gcd算法的递归结束位置,\\(a_{now}=gcd(a,b),b_{now}=0\\),带入\\(ax+by=gcd(a,b)\\),得\\({gcd(a,b)} \\times x +0 \\times y=gcd(a,b)\\) 那么显然\\(x\\)取1,\\(y\\)取任意值即可(我们选择取0). 考虑到在源代码上修改,我们仍然返回gcd的值,在过程中计算x和y即可. 代码: 12345678910111213int exgcd(int a,int b,int &amp;x,int &amp;y){ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y); int temp=x; x=y; y=temp-(a/b)*y; return ret; }","link":"/2021/01/31/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95(exgcd)/"},{"title":"【专题】拉格朗日插值(入门)","text":"本文介绍了拉格朗日插值法,并给出了模版代码. 拉格朗日插值法可构造一个经过任意n个点的函数f \\(拉格朗日插值法可构造一个经过任意n个点(a_1,b_1),(a_2,b_2),(a_3,b_3),\\dots,(a_n,b_n)的函数f,设f=f_1+f_2+\\dots+f_n,需要让f_1,f_2,\\dots,f_n均经过这n个点,且当x=a_i时,f_i=b_i;当x=a_j(j \\ne i)时,f_i=0.\\) \\(那么显然,由f_1,f_2,\\dots,f_n相加得到的的f,恰好经过了a_1,a_2,\\dots,a_n.\\) \\(f_1,f_2,\\dots,f_n被称为拉格朗日基函数,表达式为:f_i=b_i\\prod_{j\\ne i} \\frac {x-x_j} {x_i-x_j}\\) \\(那么,由拉格朗日插值法得到的函数f的表达式为:\\sum_{i=1}^{n}b_i\\prod_{j\\ne i} \\frac{x-x_j} {x_i-x_j},时间复杂度为O(n^2).\\) \\(若在程序实现中,每一次计算x_i-x_j值时都求一次其的乘法逆元,时间复杂度将乘上log\\ n,我们选择先计算所有x_i-x_j的乘积,再求逆元.\\) 另外,此处求逆元必须选择快速幂方法,否则你将陷入深深的迷惑中.为什么呢?在此题中,可能会需要求负数的逆元,但根据辗转相除法求负数和-1的最大公约数时,求得的最大公约数为-1(在cmath库函数__gcd中计算也会得到-1,可见其运用的是辗转相除法).可是在数学定义上,gcd(a,b)=gcd(|a|,|b|),也就是说负数和-1的最大公约数为1.贝祖等式ax+by=gcd(a,b)的gcd(a,b)显然是数学定义上的.那么便不能得到ax+by=1,或者说我们算的其实是ax+by=-1,完全错误了.(我在这个问题上困扰了接近1个小时TAT) 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,k,x[2005],y[2005],mod=998244353,ans;//998244353是个题目常用取模质数 ll fpm(ll x,ll power,ll mod) { x %= mod; ll ans = 1; for (; power; power &gt;&gt;= 1,(x*=x)%=mod) if(power&amp;1) (ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x[i]&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++) { ll ans_up=y[i],ans_down=1; for(int j=1;j&lt;=n;j++) { if(j==i) continue; ans_up=(ans_up*(k-x[j]))%mod; ans_down=(ans_down*(x[i]-x[j]))%mod; } ans=(ans+(ans_up*inv(ans_down)))%mod; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0;}","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】拓扑排序","text":"拓扑排序 拓扑排序是指对一个DAG(有向无环图)进行一个线性排列.对于任何一个点对(u,v),即u到v有一条边,u在线性序列中必须比v先出现. 代码实现 Des 给任务排序 Sol 使用拓扑排序,邻接矩阵存储关系.输入完毕时统计一次入度,将入度为0的点加入队列中.然后将队列中的点依次删除(删点,删边,删相连的点得入度).在这个过程中也要将更新后入度为0的点加入队列中.直到队列中所有点输出后结束程序. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,m,u,v,g[N][N],in[N];queue&lt;int&gt; q;int main(){ while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; (n||m)) { memset(g,0,sizeof g); memset(in,0,sizeof in); while(!q.empty()) { q.pop(); } for(int i=1;i&lt;=m;i++) { cin&gt;&gt;u&gt;&gt;v; g[u][v]=true; in[v]++; } for(int i=1;i&lt;=n;i++) { if(in[i]==0) { q.push(i); in[i]=-1; } } while(!q.empty()) { int i=q.front(); q.pop(); printf(&quot;%d &quot;,i); for(int j=1;j&lt;=n;j++) { if(g[i][j]) { in[j]--; g[i][j]=false; if(in[j]==0) { in[j]=-1; q.push(j); } } } } cout&lt;&lt;endl; } return 0;} Note 这里因为把cin&gt;&gt;n&gt;&gt;m &amp;&amp; (n||m)写成cin&gt;&gt;n&gt;&gt;m &amp;&amp; &amp;&amp; n &amp;&amp; mWA了一次,也就是说m可能等于0.不得不说UVA的题真是严谨. 时间复杂度 设边数为e,点数为n.不难看出建边复杂度为\\(O(e)\\),第一次统计入度为0的点复杂度为\\(O(n)\\).每个点都会进入队列一次,并操作一次,还是\\(O(n)\\).如果用邻接矩阵存储数据(如上面的代码),每次遍历每个点相连的点需要\\(O(n)\\).合起来就是\\(O(n^2)\\)(当然,这是最坏情况).所以用邻接矩阵存储数据的拓扑排序算法的时间复杂度为\\(O(n^2+e)\\). 如果用邻接表存储,遍历每个点相连的点得复杂度之和为\\(O(e)\\),总复杂度为\\(O(n+e)\\).所以知道该用哪个了吧. 例题 P1983 [NOIP2013 普及组] 车站分级 Sol 从题意不难看出,对于一趟车次的运行情况,停靠站的等级大于未停靠站的等级.那么,建立DAG,边关系为(停靠站,未停靠站)即可.这样的时间复杂度为\\(O(n^2m)\\),在洛谷上能够通过.但理论复杂度超过限制的算法显然不是我们想要的. 我们将每个停靠站连向一个虚拟节点,再将虚拟节点连向每个未停靠站.这样,扩大了n的规模(最多2000),但时间复杂度为\\(O(nm)\\).比前面的方案更优. 另外,这道题由于题意的特殊性,不需要邻接矩阵存边. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt; using namespace std;const int N=1005;int n,m,s,stop[N],g[2005][2005],st,ed,in[2005],ans;int ne[N],p;//not_existinline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ n=read(),m=read(); for(int i=1;i&lt;=m;i++) { s=read(); memset(stop,0,sizeof stop); ++p; ne[p]=n+p; for(int j=1;j&lt;=s;j++) { int t=read(); stop[t]=true; if(j==1) st=t; if(j==s) ed=t; } for(int j=st;j&lt;=ed;j++) { if(stop[j]) { g[j][ne[p]]=true; in[ne[p]]++; } else { g[ne[p]][j]=true; in[j]++; } } } int cnt=n+p;//普通车站和虚拟节点的个数和 while(cnt!=0) { bool all_ne=true; for(int i=1;i&lt;=n+p;i++) { if(in[i]==0) { cnt--; for(int j=1;j&lt;=n+p;j++) { if(g[i][j]) { g[i][j]=0; in[j]--; } } in[i]=-1; if(i&lt;=n) all_ne=false; } } if(all_ne==false) ans++; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} P1038 [NOIP2003 提高组] 神经网络 Sol 按照拓扑排序的步骤一层一层的模拟.每一层的点都必须删,但是否激发就要按照题意进行了. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105,INF=1e9+7;int n,p,u[N],f[N],s[N],in[N],c[N],ans[N],g[N][N];queue&lt;int&gt; q;int main(){ cin&gt;&gt;n&gt;&gt;p; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]&gt;&gt;u[i]; if(s[i]) { q.push(i); } fill(g[i],g[i]+N-1,INF); } int out,to; for(int i=1;i&lt;=p;i++) { cin&gt;&gt;out&gt;&gt;to; cin&gt;&gt;g[out][to]; in[to]++; } while(!q.empty()) { out=q.front(); q.pop(); if(s[out]==0) { c[out]=f[out]-u[out]; } else { c[out]=s[out]; } bool out_layer=true; for(int i=1;i&lt;=n;i++) { if(g[out][i]!=INF) { in[i]--; if(c[out]&gt;0) f[i]+=c[out]*g[out][i]; if(in[i]==0) { q.push(i); } out_layer=false; } } if(out_layer)//是否是输出层 { ans[out]=c[out]; } } bool all0=true; for(int i=1;i&lt;=n;i++) { if(ans[i]&gt;0) { cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ans[i]&lt;&lt;endl; all0=false; } } if(all0) cout&lt;&lt;&quot;NULL\\n&quot;; return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"【专题】搜索进阶","text":"引言 回顾一下设计搜索算法的过程 确定搜索状态 设计算法 边界控制 剪枝 转移 要优化搜索或动态规划算法，一定是在状态上下功夫。剪枝可以去除无效状态，记忆化搜索可以利用重复转移的状态（类似 DP）。优化搜索顺序或双向广搜可以优化到达答案的状态树。本文记录剪枝的方法。 剪枝可以分为可行性剪枝和最优化剪枝。 P1731 [NOI1999] 生日蛋糕（剪枝） Des 7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 \\(N\\pi\\) 的 \\(M\\) 层生日蛋糕，每层都是一个圆柱体。 设从下往上数第 \\(i\\)（\\(1 \\leq i \\leq M\\)）层蛋糕是半径为 \\(R_i\\)，高度为 \\(H_i\\) 的圆柱。当 \\(i \\lt M\\) 时，要求 \\(R_i \\gt R_{i+1}\\) 且 \\(H_i \\gt H_{i+1}\\)。 由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 \\(Q\\) 最小。 请编程对给出的 \\(N\\) 和 \\(M\\)，找出蛋糕的制作方案（适当的 \\(R_i\\) 和 \\(H_i\\) 的值），使 \\(S=\\dfrac{Q}{\\pi}\\) 最小。 （除 \\(Q\\) 外，以上所有数据皆为正整数） Sol 好题，可行性剪枝和最优化剪枝都体现到了。2个方面入手：如果继续搜不能更新最优解，就不搜了；如果继续搜搜不到边界，就不搜了。 My code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e4+5,inf=1e9;int n,m,best=inf;int minV[20],minS[20]; //做i层蛋糕最少的表面积和体积 单位:π不会爆int//每进入到搜索的一层,状态是决定好了的 /*搜索执行条件顺序: 边界回溯 剪枝 转移*/ void dfs(int x,int r,int h,int v,int s) { //当前层数,半径,高度,体积剩余(pi),使用表面积(pi) if(x==1) { if(v==n &amp;&amp; s&lt;best) best=s; return; } if(v+minV[x-1]&gt;n) return; if(s+minS[x-1]&gt;=best) return; if(s+2*(n-v)/r&gt;=best) return; for(int i=r-1;i&gt;=x-1;i--) { if(x==m+1) s=i*i; int mxh=min(h-1,(n-v)/(i*i)); for(int j=mxh;j&gt;=x-1;j--) { dfs(x-1,i,j,v+i*i*j,s+2*i*j); } }}int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) minV[i]=minV[i-1]+i*i*i; for(int i=1;i&lt;=m;i++) minS[i]=minS[i-1]+2*i*i; dfs(m+1,n+1,n+1,0,0); //N=r*r*h cout&lt;&lt;((best==inf)?(0):(best))&lt;&lt;endl; return 0;} UVA307 小木棍 Sticks（剪枝） Des 乔治拿来一组等长的木棒，将它们随机的砍掉，得到若干根小木棍，并使每一节小棍的长度都不超过50个单位。然后他又想把这些木棍拼接起来，恢复到裁剪前的状态，但他忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度，每一节木棍的长度都用大于零的整数表示。 输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后具有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后。是一个零。 对于每组数据，分别输出原始木棒的可能最小长度。 Sol 直接枚举每组长度，然后看能不能搜索完。 能想到的剪枝有： 记录可行的长度组合。如果搜索中剩余的长度不合法，就不转移。 将木棍先降序排列，并记录每个长度的起始木棍位置。 结果：超时 果：超时 ：超时 超时 时 。。。 这道题，说来说去还是这个剪枝最重要： 若当前长棍的剩余未拼长度等于应拼长度或下一步拼接的木棍长度时，若不能拼接成功，则 return。 如果当前的应拼长度合适，那么每根木棍都应属于一个长棍中。搜索每根长棍的第一根木棍，相当于搜索了它与没有拼接的木棍的所有组合情况，如果不能组合，一定是应拼长度有问题，或之前的木棍拼错了。这就证明了剩余未拼长度等于应拼长度的情况。 如果剩余长度等于木棍长度，那根长木棍可能等于许多短木棍长度和。但由于短木棍组合出更多的情况，此时拼接长木棍一定最优。既然最优的情况都无解，其他的情况自然误解了。 上面的剪枝看似难想，但传达出了 2 个思想： 如果确定当前下一步的状态转移最优，但不可行，则之前的状态有误。 注意状态树上父亲和儿子的关系。若任何一个儿子不可行可推出父亲不可行，那么就不要搜索其他儿子了。 在前面，我们提到剪枝分为最优化剪枝和可行性剪枝。其实这里的 2 个剪枝都算作可行性剪枝，但和前面的题中的剪枝又有不同。在前面的剪枝中，我们总是在考虑状态树上单个节点的可行性和最优性，如果性质不好就直接舍弃整颗子树。但在本题中，我们并不能直接剪掉子树，而是必须先搜索一个最优的儿子，然后再考虑舍弃。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=70;int n,sum,tot,len;int a[N];bool vis[N],ok;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void dfs(int k,int last,int rest) { if(ok) return; if(!rest) { if(k==tot) { ok=true; return; } rest=len; ++k; last=n; } for(int i=upper_bound(a+1,a+last+1,rest)-a-1;i&gt;=1;i--) { if(a[i]==a[i+1] &amp;&amp; !vis[i+1]) continue; if(a[i]&lt;=rest &amp;&amp; !vis[i]) { vis[i]=true; dfs(k,i,rest-a[i]); vis[i]=false; if(ok) return; if(rest==len || rest==a[i]) return; } }} int main() { while(cin&gt;&gt;n &amp;&amp; n) { sum=0; for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1); for(int i=n;i&gt;=1;i--) { if(a[i]&lt;=50) { n=i; break; } } for(int i=1;i&lt;=n;i++) sum+=a[i]; for(int i=a[n],ed=sum/2;i&lt;=ed;i++) { if(sum%i==0) { tot=sum/i,len=i; ok=false; dfs(1,n,i); if(ok) { printf(&quot;%d\\n&quot;,i); break; } } } if(!ok) printf(&quot;%d\\n&quot;,sum); } return 0;} WOJ3205 送礼物（拆分状态） Des 作为惩罚，GY被遣送去帮助某神牛给女生送礼物(GY：貌似是个好差事)但是在GY看到礼物之后，他就不这么认为了。某神牛有N个礼物，且异常沉重，但是GY的力气也异常的大(-_-b)，他一次可以搬动重量和在w(w&lt;=2^31-1)以下的任意多个物品。GY希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。 Sol 如果直接搜索，有 \\(2^{45}\\) 种状态，显然会超时。 我们利用初一学的幂的计算规则，有 \\(m^{2n}=m^n\\times m^n\\)。这给了我们一个启发，即状态数量满足乘法原理。我们完全可以把状态拆成 2 部分计算，然后将其中一部分的每个状态去另一部分中寻找一个最优的。如果这个寻找的时间低于 \\(O(n)\\)（n 是另一部分状态的规模），那就可以将原本 \\(O(n^2)\\) 的算法优化到 \\(O(n\\log n)\\)。 本题就是一个很好的体现，我们先搜索前一半的数，然后再搜索后一半的数。后半部分每产生一个状态，就在前面的状态里二分查找一个最优的。时间复杂度 \\(O(2^{n/2}\\log 2^{n/2})\\)。 但需要注意，能这样做的题的状态间的关系一定是不复杂的，比如本题的状态就可以完美的拆成两部分。 My code 使用 mode 作为两次 dfs 的标记。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100;int n,w,best,p=0;int a[N],fir[1&lt;&lt;24];bool cmp(const int &amp;a,const int &amp;b) { return a&gt;b;}void dfs(int x,int last,ll curW,int mode) { if(curW&gt;w) return; if(mode==1) fir[++p]=curW; if(x&gt;last) { if(mode==2) { int pos=lower_bound(fir+1,fir+p+1,w-curW)-fir-1; if(pos!=0 &amp;&amp; best&lt;curW+fir[pos] &amp;&amp; curW+fir[pos]&lt;=w) best=curW+fir[pos]; } return; } dfs(x+1,last,curW,mode); dfs(x+1,last,curW+a[x],mode);}int main() { cin&gt;&gt;w&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } sort(a+1,a+n+1,cmp); int mid=n/2; dfs(0,mid-1,0,1); sort(fir+1,fir+p+1); dfs(mid,n,0,2); cout&lt;&lt;best&lt;&lt;endl; return 0;} Note fir 数组要开到 2 的 24 次方，不然就会 RE？？？ 将 a 数组降序排列，有效减少前半部分状态数量。 P1032 [NOIP2002 提高组] 字串变换（双向搜索） Des 已知两个字串 \\(A,B\\) 及一组字串变换的规则（至多 \\(6\\) 个规则）: \\(A_1\\) -&gt;$ B_1$ \\(A_2\\) -&gt; \\(B_2\\) \\(\\cdots\\) \\(A_n \\rightarrow B_n\\) 规则含义为：\\(A\\) 中子串 \\(A_1\\) 可换为 $ B_1\\(，\\)A_2$ 可换为 \\(B_2\\) …。 例如：若\\(A=\\text{abcd}\\)，\\(B＝\\text{xyz}\\)，规则为：\\(\\text{abc}\\rightarrow\\text{xu}\\)，\\(\\text{ud}\\rightarrow\\text{y}\\)，\\(\\text{y}\\rightarrow\\text{yz}\\)。则\\(A\\) 最终可变换为 \\(B\\)，过程为 \\(\\text{abcd}\\rightarrow\\text{xud}\\rightarrow\\text{xy}\\rightarrow\\text{xyz}\\)。（共进行 3 次变换） Sol 如果直接搜索，状态数量为 \\(6^{10}=60466176\\)，乘上对字符串的存储以及替换时间，铁定要爆。 幻想有一颗状态转移图，图上有一个入度为 0 的节点，即状态的起始点。有一个出度为 0 的叶子节点，即状态结束点。如果从起点开始搜索，那么整个状态转移图都将被遍历，包括许多无效节点。搜索的层数越多，状态就越多。双向广搜就是基于减少搜索层数的思想，在固定终点的题把终点和起点都看做搜索的起点。当搜索节点第一次同时出现，步数一定最优。 理论上时间复杂度上限为 \\(6^5\\times w=7776\\times w\\)，\\(w\\) 是处理字符串的常数。但是洛谷题面里为什么说没有靠谱的多项式做法??? My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=10;int n,sz[N];string a,b,x[N],y[N],s;struct node { string s; int dep;}t;map&lt;string,int&gt; m1,m2;queue&lt;node&gt; q1,q2;void bfs() { q1.push((node){a,0}),q2.push((node){b,0}); m1[a]=m2[b]=0; while(!q1.empty() &amp;&amp; !q2.empty()) { //一边搜完了就不搜了 if(q1.front().dep+q2.front().dep&gt;10) { printf(&quot;NO ANSWER!&quot;); return; } t=q1.front(),q1.pop(); int len=t.s.size(); for(int i=0;i&lt;len;i++) { for(int j=0;j&lt;n;j++) { s=t.s; if(sz[j]+i-1&gt;=len) continue; if(s.substr(i,sz[j])!=x[j]) continue; if(m1.count(s.replace(i,sz[j],y[j]))) continue; m1[s]=t.dep+1; q1.push((node){s,t.dep+1}); if(m2.count(s)) { printf(&quot;%d\\n&quot;,t.dep+1+m2[s]); return; } } } t=q2.front(),q2.pop(); len=t.s.size(); for(int i=0;i&lt;len;i++) { for(int j=0;j&lt;n;j++) { s=t.s; if((int)y[j].size()+i-1&gt;=len) continue; if(s.substr(i,y[j].size())!=y[j]) continue; if(m2.count(s.replace(i,y[j].size(),x[j]))) continue; m2[s]=t.dep+1; q2.push((node){s,t.dep+1}); if(m1.count(s)) { printf(&quot;%d\\n&quot;,t.dep+1+m1[s]); return; } } } } printf(&quot;NO ANSWER!&quot;);}int main() { cin&gt;&gt;a&gt;&gt;b; for(;cin&gt;&gt;x[n]&gt;&gt;y[n];++n) sz[n]=x[n].size(); bfs(); return 0;} Note 双向广搜需要： 判断边界 剪枝 状态转移（过程中判断重合）","link":"/2021/04/17/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%90%9C%E7%B4%A2%E8%BF%9B%E9%98%B6/"},{"title":"【专题】数列分块","text":"资料: 「分块」数列分块入门1 – 9 by hzwer - 分块 - hzwer.com 均值不等式 - 知乎 (zhihu.com) 前置知识: 均值不等式 基本不等式的代数证明和几何证明 \\(\\cfrac {a_1+a_2+\\dots+a_n} n \\ge \\sqrt[n] {a_1+a_2+\\dots+a_n}\\). 复习一下: \\(2(a^2+b^2+c^2-ab-bc-ac)=(a-b)^2+(b-c)^2+(a-c)^2\\ge 0\\). 分块 分块感觉就是用 \\(\\sqrt n\\) 叉树实现的线段树, 所以很多题型都是线段树写过的. 那你会问: 我为什么要用这么一个复杂度高的算法呢? 正因为分块存储区间信息的节点数量少(只有 \\(\\sqrt n\\) 个,线段树是 \\(2+4+8+\\cdots\\)), 所以单节点维护起来方便. 可以在单节点内套上其他数据结构. hzwer 的分块九讲感觉难度排的不是很对...... 所以就按照我自己的喜好排了. 分块入门 1 by hzwer 区间加法, 单点求值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5; int n,SQN;int ans[N],tag[N],tot[N];void modify(int l,int r,int k) { while(l%SQN!=1) { ans[l++]+=k; if(l&gt;r) return; } while(r%SQN!=0) { ans[r--]+=k; if(l&gt;r) return; } for(;l&lt;=r;l+=SQN) { tag[l/SQN]+=k; }} int query(int l,int r) { int t=0; while(l%SQN!=1) { t+=ans[l]+tag[(l-1)/SQN]; ++l; if(l&gt;r) return t; } while(r%SQN!=0) { t+=ans[r]+tag[(r-1)/SQN]; --r; if(l&gt;r) return t; } for(;l&lt;=r;l+=SQN) { t+=tot[l/SQN]+tag[l/SQN]*SQN; } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;ans[i]); tot[i/SQN]+=ans[i]; } int opt,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;opt,&amp;l,&amp;r,&amp;c); if(opt) { printf(&quot;%d\\n&quot;,query(r,r)); } else { modify(l,r,c); } } return 0;} 分块入门 4 by hzwer 区间加, 区间询问. 不开 long long 见祖宗. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*tag表示区间都应加上的数a表示单点的值tot表示区间和对于区间,总和为 tot + tag*SQN对于单点,总和为 a + tag[] 对于加法操作,在区间上维护tag在单点上维护a和区间tot */#include &lt;bits/stdc++.h&gt; typedef long long ll;using namespace std;const int N=5e4+5;int n,SQN;ll a[N],tot[N],tag[N];void modify(int l,int r,ll c) { for(;l%SQN!=1;l++) { a[l]+=c; tot[(l-1)/SQN]+=c; if(l==r) return; } for(;r%SQN!=0;r--) { a[r]+=c; tot[(r-1)/SQN]+=c; if(l==r) return; } for(int i=l;i&lt;=r;i+=SQN) { tag[(i-1)/SQN]+=c; }}int query(int l,int r,int c) { ll t=0; for(;l%SQN!=1;l++) { t+=tag[(l-1)/SQN]+a[l]; t%=c; if(l==r) return t; } for(;r%SQN!=0;r--) { t+=tag[(r-1)/SQN]+a[r]; t%=c; if(l==r) return t; } for(int i=l;i&lt;=r;i+=SQN) { t+=tag[(i-1)/SQN]*SQN+tot[(i-1)/SQN]; t%=c; } return t;} int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;a[i]); tot[(i-1)/SQN]+=a[i]; } for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c+1)); } else { modify(l,r,c); } } return 0;} 分块入门 5 by hzwer 区间开方, 区间求和. 经典区间开方, 线段树也做过. 一个非零数连续开方变成 1 需要的开方次数其实很少. 所以在最开始的时候一个一个开方, 如果区间全部为 0 或 1 就跳过区间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,SQN;int a[N],tot[N],al0[N],bl[N];void modify(int l,int r) { bool ok=false; for(int i=l;i&lt;=r;i++) { tot[bl[i]]-=(a[i]-sqrt(a[i])); a[i]=sqrt(a[i]); if(i%SQN==1) { if(al0[bl[i]]) { i+=SQN-1; continue; } else ok=true; } if(a[i]!=1 &amp;&amp; a[i]!=0) ok=false; if(i%SQN==0 &amp;&amp; ok==true) { al0[bl[i]]=true; } }}int query(int l,int r) { int ans=0; for(;l%SQN!=1;l++) { ans+=a[l]; if(l==r) return ans; } for(;r%SQN!=0;r--) { ans+=a[r]; if(r==l) return ans; } for(;l&lt;=r;l+=SQN) { ans+=tot[bl[l]]; } return ans;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); bl[i]=(i-1)/SQN; tot[bl[i]]+=a[i]; } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op==0) { modify(l,r); } else if(op==1) { printf(&quot;%d\\n&quot;,query(l,r)); } } return 0;} P3870 [TJOI2009]开关 区间均为 0 或 1, 执行区间异或, 区间求和. 异或会修改整块的和, 但也就是 SQN-sum 和 sum 的区别. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5; int n,m,SQN;int ans[N],tag[N],tot[N];void modify(int l,int r) { while(l%SQN!=1) { tot[(l-1)/SQN]+=(ans[l]==0)?(1):(-1); ans[l++]^=1; if(l&gt;r) return; } while(r%SQN!=0) { tot[(r-1)/SQN]+=(ans[r]==0)?(1):(-1); ans[r--]^=1; if(l&gt;r) return; } for(;l&lt;=r;l+=SQN) { tag[l/SQN]^=1; }} int query(int l,int r) { int t=0; while(l%SQN!=1) { t+=ans[l]^tag[(l-1)/SQN]; ++l; if(l&gt;r) return t; } while(r%SQN!=0) { t+=ans[r]^tag[(r-1)/SQN]; --r; if(l&gt;r) return t; } for(;l&lt;=r;l+=SQN) { int id=l/SQN; t+=(tag[id]==1)?(SQN-tot[id]):tot[id]; } return t;}int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); SQN=sqrt(n); int opt,l,r; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;l,&amp;r); if(opt) { printf(&quot;%d\\n&quot;,query(l,r)); } else { modify(l,r); } } return 0;} 分块入门 2 by hzwer 区间加法, 区间求小于 k 的数 a数组存储排序好的数组, b数组表示原始数组, tag 存储在区间上的加法 对于加法操作: 在区间上修改 tag 在单点上修改原始数组, 并对修改过的散块重新排序 对于求小于的操作 在区间上二分排序好的数组, 但二分的值要减去 tag 在单点上判断是否 a[x]+tag[x]&lt;k . 这道题真的调了超久. 一开始我甚至没有 rebuild ,意识到后这一点后, rebuild 的情况也没考虑全. 我拿一个讨论区里的暴力踩标算的程序来对拍, 然后发现始终不对. 我真的是想不出哪里还有问题了, 就抱着侥幸心理交了一发, 没想到对了! 我能说我最开始不知道黄学长那篇博客下面是有标程的吗? 导致我一开始就没有用 vector 写. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,SQN;int a[N],b[N],tag[N];void rebuild(int id) { int st=max(1,id*SQN+1),ed=min((id+1)*SQN,n); for(int i=st;i&lt;=ed;i++) a[i]=b[i]; sort(a+st,a+ed+1);}void modify(int l,int r,int k) { int led=-1,rst=-1; for(;l%SQN!=1;l++) { b[l]+=k; if(l%SQN==0) led=l; if(l==r) { rebuild((l-1)/SQN); return; } } if(led!=-1) rebuild((led-1)/SQN); for(;r%SQN!=0;r--) { b[r]+=k; if(r%SQN==1) rst=r; if(r==l) { rebuild((r-1)/SQN); return; } } if(rst!=-1) rebuild((rst-1)/SQN); for(;l&lt;=r;l+=SQN) { tag[(l-1)/SQN]+=k; }}int query(int l,int r,int k) { int t=0; for(;l%SQN!=1;l++) { if(b[l]+tag[(l-1)/SQN]&lt;k) ++t; if(l==r) return t; } for(;r%SQN!=0;r--) { if(b[r]+tag[(r-1)/SQN]&lt;k) ++t; if(l==r) return t; } for(;l&lt;r;l+=SQN) { t+=lower_bound(a+l,a+l+SQN,k-tag[(l-1)/SQN])-a-l; } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); b[i]=a[i]; } for(int i=1;i&lt;=n;i+=SQN) { sort(a+i,min(a+n+1,a+i+SQN)); } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c*c)); } else { modify(l,r,c); } } return 0;} 分块入门 3 by hzwer 区间加, 区间求前驱 把上一题的代码改一改就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,SQN;int a[N],b[N],tag[N];void rebuild(int id) { int st=max(1,id*SQN+1),ed=min((id+1)*SQN,n); for(int i=st;i&lt;=ed;i++) a[i]=b[i]; sort(a+st,a+ed+1);}void modify(int l,int r,int k) { int led=-1,rst=-1; for(;l%SQN!=1;l++) { b[l]+=k; if(l%SQN==0) led=l; if(l==r) { rebuild((l-1)/SQN); return; } } if(led!=-1) rebuild((led-1)/SQN); for(;r%SQN!=0;r--) { b[r]+=k; if(r%SQN==1) rst=r; if(r==l) { rebuild((r-1)/SQN); return; } } if(rst!=-1) rebuild((rst-1)/SQN); for(;l&lt;=r;l+=SQN) { tag[(l-1)/SQN]+=k; }}int query(int l,int r,int k) { int t=-1; for(;l%SQN!=1;l++) { int rec=b[l]+tag[(l-1)/SQN]; if(rec&lt;k) t=max(t,rec); if(l==r) return t; } for(;r%SQN!=0;r--) { int rec=b[r]+tag[(r-1)/SQN]; if(rec&lt;k) t=max(t,rec); if(l==r) return t; } for(;l&lt;r;l+=SQN) { int id=lower_bound(a+l,a+min(l+SQN,n+1),k-tag[(l-1)/SQN])-a; if(id==l) continue; else t=max(t,a[id-1]+tag[(id-1)/SQN]); } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); b[i]=a[i]; } for(int i=1;i&lt;=n;i+=SQN) { sort(a+i,min(a+n+1,a+i+SQN)); } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c)); } else { modify(l,r,c); } } return 0;} 分块入门 6 by hzwer 单点插入, 单点查询. 在块内插入, 可以把所有元素暴力向后移. 但如果块过大, 就得把一个块分裂开或者重新分块. 此处我选择第一种, 时间复杂度小. 下面的程序是 hzwer 标程用时的二分之一. 把块裂开, 实际上就是新建一个 vector ,然后改一下顺序访问用到的单向链表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,SQN,cnt;int nxt[N];vector&lt;int&gt; a[3000];void rebuild(int x) { vector&lt;int&gt; t=a[x]; a[x].clear(); int ed=t.size(),mid=ed/2; ++cnt; for(int i=0;i&lt;=mid;i++) a[x].push_back(t[i]); for(int i=mid+1;i&lt;ed;i++) a[cnt].push_back(t[i]); nxt[cnt]=nxt[x],nxt[x]=cnt;}void insert(int l,int k) { int p=0; for(int i=0;i!=-1;i=nxt[i]) { int len=a[i].size(); if(p+len&gt;=l) { a[i].push_back(*(a[i].end()-1)); for(int j=len-1;j&gt;l-p-1;j--) { a[i][j]=a[i][j-1]; } a[i][l-p-1]=k; if(a[i].size()&gt;(unsigned int)(10*SQN)) { rebuild(i); i=nxt[i]; } break; } else p+=len; }}int query(int x) { int p=0; for(int i=0;i!=-1;i=nxt[i]) { int len=a[i].size(); if(p+len&gt;=x) { return a[i][x-p-1]; } else p+=len; } return -1;}inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { n=read(); SQN=sqrt(n); cnt=-1; int op,l,r,c; for(int i=0;i&lt;=SQN;i++) a[i].reserve(300); for(int i=1;i&lt;=n;i++) { if(i%SQN==1) ++cnt; c=read(); a[cnt].push_back(c); } for(int i=0;i&lt;cnt;i++) nxt[i]=i+1; nxt[cnt]=-1; for(int i=1;i&lt;=n;i++) { op=read(),l=read(),r=read(),c=read(); if(op==0) insert(l,r); else printf(&quot;%d\\n&quot;,query(r)); } return 0;} 分块入门 7 by hzwer 区间加法, 区间乘法, 单点求值. 分别维护加法和乘法的 tag. 其实区间求值也可以, 但是较难写. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,P=10007;int n,SQN;int a[N],tagm[N],taga[N],bl[N];inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void reset(int x) { int st=x*SQN+1,ed=(x+1)*SQN; for(int i=max(1,st);i&lt;=min(n,ed);i++) a[i]=(a[i]*tagm[x]+taga[x])%P; tagm[x]=1,taga[x]=0;}void modify(int l,int r,int k,int op) { reset(bl[l]),reset(bl[r]); for(;l%SQN!=1;l++) { if(op==0) a[l]=(a[l]+k)%P; else a[l]=(a[l]*k)%P; if(l==r) return; } for(;r%SQN!=0;r--) { if(op==0) a[r]=(a[r]+k)%P; else a[r]=(a[r]*k)%P; if(l==r) return; } for(int i=bl[l];i&lt;=bl[r];i++) { if(op==0) taga[i]=(taga[i]+k)%P; else { taga[i]=(taga[i]*k)%P; tagm[i]=(tagm[i]*k)%P; } }}inline int query(int x) { return ((a[x]*tagm[bl[x]])+taga[bl[x]])%P;}int main() { n=read(); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { a[i]=read(); bl[i]=(i-1)/SQN; } for(int i=0;i&lt;=bl[n];i++) tagm[i]=1; int op,l,r,c; for(int i=1;i&lt;=n;i++) { op=read(),l=read(),r=read(),c=read(); if(op==2) { printf(&quot;%d\\n&quot;,query(r)); } else { modify(l,r,c,op); } } return 0;} P4168 [Violet]蒲公英 区间众数，另一种常见的分块思想。 整块和散块之间并不是毫无关系的（比如求和），而是需要通过记录整块上的一些数据，来让散块可以更新它，并求出答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=40005,M=50005,MXT=1200;int n,m,len,T,cnt,last;int a[N],u[N],pos[N],bl[N],t[N]; //u是sort+unique后的a数组,pos存储蒲公英的品种 int mode[MXT][MXT],modeCnt[MXT][MXT];vector&lt;int&gt; line[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void preWork() { for(int i=0;i&lt;cnt;i++) { memset(t,0,sizeof t); int mxp=0,mxn=0; for(int j=i;j&lt;cnt;j++) { int st=max(1,j*T+1),ed=min(n,(j+1)*T); for(int k=st;k&lt;=ed;k++) { int p=pos[k]; t[p]++; if(t[p]==mxn &amp;&amp; a[k]&lt;mxp) mxp=a[k]; else if(t[p]&gt;mxn) mxn=t[p],mxp=a[k]; } mode[i][j]=mxp; modeCnt[i][j]=mxn; } } for(int i=1;i&lt;=n;i++) { line[pos[i]].push_back(i); }}int query(int l,int r) { int st=l,ed=r,mxn=0,mxp=0; for(;st%T!=1;st++) { int x=lower_bound(line[pos[st]].begin(),line[pos[st]].end(),l)-line[pos[st]].begin(); int y=upper_bound(line[pos[st]].begin(),line[pos[st]].end(),r)-line[pos[st]].begin()-1; if(y-x+1&gt;mxn) mxn=y-x+1,mxp=a[st]; else if(y-x+1==mxn &amp;&amp; a[st]&lt;mxp) mxp=a[st]; if(st==ed) return last=mxp; } for(;ed%T!=0;ed--) { int x=lower_bound(line[pos[ed]].begin(),line[pos[ed]].end(),l)-line[pos[ed]].begin(); int y=upper_bound(line[pos[ed]].begin(),line[pos[ed]].end(),r)-line[pos[ed]].begin()-1; if(y-x+1&gt;mxn) mxn=y-x+1,mxp=a[ed]; else if(y-x+1==mxn &amp;&amp; a[ed]&lt;mxp) mxp=a[ed]; if(ed==st) return last=mxp; } st=bl[st],ed=bl[ed]; if(modeCnt[st][ed]&gt;mxn) mxn=modeCnt[st][ed],mxp=mode[st][ed]; else if(modeCnt[st][ed]==mxn &amp;&amp; mode[st][ed]&lt;mxp) mxp=mode[st][ed]; return last=mxp;}int main() { n=read(),m=read(); T=max(1,(int)sqrt(double(n)/(2.0*log2(double(n))))); cnt=n/T; if(n%T!=0) ++cnt; for(int i=1;i&lt;=n;i++) { a[i]=read(); u[i]=a[i]; bl[i]=(i-1)/T; } sort(u+1,u+n+1); len=unique(u+1,u+n+1)-u; for(int i=1;i&lt;=n;i++) pos[i]=lower_bound(u+1,u+len+1,a[i])-u; preWork(); int l,r; for(int i=1;i&lt;=m;i++) { l=read(),r=read(); l=(l+last-1)%n+1,r=(r+last-1)%n+1; if(l&gt;r) swap(l,r); printf(&quot;%d\\n&quot;,query(l,r)); } return 0;} 和这道题类似的有许多： P2709 小B的询问 P4135 作诗 P1972 [SDOI2009]HH的项链 P1494 [国家集训队]小Z的袜子 这类分块题，如果不强制在线，大多可以通过莫队解决。","link":"/2021/04/13/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97/"},{"title":"【专题】最近公共祖先(LCA)&amp;树上差分","text":"LCA算法介绍 LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 本文下方的N为点个数,M为询问次数.u和v为被询问的2个节点编号. LCA算法实现 普通实现 如果询问LCA(u,v),分别从u和v开始向上遍历,直到遇到LCA. 时间复杂度\\(O(NM)\\). 倍增实现 不难发现,普通实现的时间主要耗费在向上遍历这个过程.有些点对的LCA离它们自己很远,一个一个的向上走实在太浪费时间.考虑任何一个整数都可以拆分成2的幂的和,如果能利用这个拆分,能将单次查询的时间复杂度优化到\\(O(\\log n)\\). 为了判断探测到的节点是不是LCA,我们可以先计算每个节点向上走\\(2^k\\)层走到的节点编号,这一步可以用DFS实现(后面代码有).用\\(f[x][k]\\)表示从x开始向上走\\(2^k\\)层走到的节点编号.先令\\(f[x][0]\\)等于\\(father(x)\\).然后循环计算\\(f[x][i]=f[f[x][i-1]][i-1]\\)(循环次数取决于节点深度). 要优化寻找过程其实是比较困难的.普通人(比如我)听到倍增都会想到类似\\(1,2,4,8,\\dots\\)这样增加步数.但倍增探测步数后,很可能就跳过了LCA,找到了另一个公共祖先.这是需要撤销步骤,减小探测步数,再次尝试.但这种实现对时间复杂度和编程复杂度的增加都不是我们想要的. 先贤们给出了一种很好的实现.就是把探测步数的变化过程变成从大到小(\\(2^k,2^{k-1},2^{k-1},\\dots,1\\)).考虑将普通整数拆分成2次的幂的和过程,我们就是从大到小减少幂次的(5=4+1).设已经算好的幂的和为\\(m\\),下一次准备增加的幂的幂次为\\(k\\),如果\\(m+2^k&lt;n\\),那么\\(m+=2^{k-1}\\),否则\\(k--\\),发现没有!我们只利用了\"\\(&gt;n\\)\"这个限制条件,就很好的实现了从大到小减小幂次.在倍增求LCA中,这个限制是\\(father[u]!=father[v]\\).这样不断逼近后,求得的\\(father[u]\\)是LCA的儿子,再获取它的父亲即可. LCA(u,v)的结果有2种情况,第一种是等于u或v,也就是1个点是另一个点的祖先;第二种是不等于u或v.第一种情况是不能用上述的方法计算的. 在开始计算LCA时,算一下\\(depth[u]\\)和\\(depth[v]\\),如果不等,就提升深度小的节点(设其为\\(u\\),使其重新赋值为它的深度与\\(v\\)相等的祖先).如果此时\\(u=v\\),说明\\(u\\)是\\(v\\)的祖先.如果不等,就执行下面的操作. 令探测步数\\(k\\)等于\\(log2(depth[x])\\)下取整,如果\\(f[x][k]!=f[y][k]\\),执行\\(x=f[x][k],y=f[y][k]\\),否则执行\\(k--\\).是不是和拆分整数很像?由于步数是够了的,我们最后一定可以到达LCA(u,v)的下一层.return\\(f[x][0]\\)即可. 计算log2(x) 先把log2(x)打出来,节省时间. 12for(int i=1;i&lt;=19;i++) lg[1&lt;&lt;i]++;for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1]; dfs求\\(f[x][k]\\) 12345678910111213void dfs(int x,int fa)//当前节点和father节点 { f[x][0]=fa,depth[x]=depth[fa]+1; int len=g[x].size(); for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1];//和求ST表有异曲同工之妙 } for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) dfs(g[x][i],x);//注意是树,存了father节点 }} 屑LCA 123456789101112int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v);//保证v的深度更大 while(depth[v]&gt;depth[u]) { v=f[v][lg[depth[v]-depth[u]]];//此步的时间复杂度为log(depth[v]-depth[u]) } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; return f[u][0];} 不重要的总代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5,LG=19;int n,m,s;int lg[N&lt;&lt;1],depth[N];int f[N][20];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void dfs(int x,int fa)//当前节点和father节点 { f[x][0]=fa,depth[x]=depth[fa]+1; int len=g[x].size(); for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1];//和求ST表有异曲同工之妙 } for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) dfs(g[x][i],x);//注意是树,存了father节点 }}int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v);//保证v的深度更大 while(depth[v]&gt;depth[u]) { v=f[v][lg[depth[v]-depth[u]]];//此步的时间复杂度为log(depth[v]-depth[u]) } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; return f[u][0];}int main(){ n=read(),m=read(),s=read(); for(int i=1;i&lt;n;i++) { int x,y; x=read(),y=read(); g[x].push_back(y),g[y].push_back(x); } for(int i=1;i&lt;=19;i++) lg[1&lt;&lt;i]++; for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1];//log2(1)=1,log2(2)=2,log2(3)=2,log2(4)=3... dfs(s,0); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(); printf(&quot;%d\\n&quot;,LCA(u,v)); } return 0;} 记得把lg数组开大一点,不然会像我一样RE LCA例题 题型 queryPlus 在得到答案的步骤上下功夫,比如\"寻找中点\".这类问题直接求LCA然后处理即可. getPlus 在寻找LCA的函数中下功夫,比如P1967 [NOIP2013 提高组] 货车运输),问的是路径上最小值,需要更改LCA函数. P3379 【模板】最近公共祖先（LCA） 总不可能还没拿经验吧XD P3938 斐波那契 Des 小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。 小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。 如果我们把这种关系用图画下来，前六个月大概就是这样的： (去洛谷看图,我还没弄好图床) 其中，一个箭头 A → B 表示 A 是 B 的祖先，相同的颜色表示同一个月出生的兔子。 为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 m 个 问题：她想知道关于每两对兔子 \\(a_i\\) 和 \\(b_i\\) ，他们的最近公共祖先是谁。你能帮帮小 C 吗？ 一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，5 和 7 的最近公共祖 先是 2，1 和 2 的最近公共祖先是 1，6 和 6 的最近公共祖先是 6。 Sol 看完了才发现这和上面那道传统意义上的LCA根本不同!不过都看出来做法了就切了它吧! 记得小学看某本趣味数学讲斐波那契就提到了这个经典的兔子问题,规律就是,每个月出生的兔子数量的序列是斐波那契数列.这道题稍有不同,是(1,1,1,2,3,5...). 设兔子的id是\\(x_i\\),有\\(x_i=x_p+x_q(p&lt;q&lt;i,且x_p和x_q在上一个月出生)\\).根据题目的定义,\\(x_i\\)的父亲是\\(p\\)最小的\\(x_p\\).要找到这个\\(x_p\\),只需要知道\\(q\\)最大的\\(x_q\\),也就是上一个月出生的编号最大的那个兔子.而这群兔子的编号序列就是斐波那契数列(1,2,3,5,8,13...).将每个被询问兔子所有的祖先加入数组中,最后从同一深度开始匹配即可.注意查询编号对应的\\(x_q\\)需要用二分查找. 至于斐波那契数列的个数,我计算了一下,大概在第60项的时候到达了\\(10^{13}\\).所以本算法的时间复杂度为\\(O(a[i]\\log a[i]*m)\\)(其实就是常数大亿点的\\(O(m)\\)). My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define min(a,b) ((a)&lt;(b)?(a):(b))using namespace std;const int N=1e2+5;long long fib[N],sub[N],s1[N],s2[N];long long m,p1,p2,u,v,p;inline long long read(){ long long x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return x;} inline long long search(const long long &amp;x){ return sub[lower_bound(fib+1,fib+70,x)-fib];}int main(){ sub[2]=1,sub[3]=2; for(int i=4;i&lt;=70;i++) sub[i]=sub[i-1]+sub[i-2]; fib[1]=1,fib[2]=2; for(int i=3;i&lt;=70;i++) fib[i]=fib[i-1]+fib[i-2]; //这2个数组可要好好推一推。。。 m=read(); for(int i=1;i&lt;=m;i++) { u=read(),v=read(),p1=p2=0; s1[++p1]=u; do { u=u-search(u); s1[++p1]=u; }while(u!=1); s2[++p2]=v; do { v-=search(v); s2[++p2]=v; }while(v!=1); p=min(p1,p2); for(int i=1;i&lt;=p;i++) { if(s1[p1-p+i]==s2[p2-p+i]) { printf(&quot;%lld\\n&quot;,s1[p1-p+i]); break; } } } return 0;} T70138 寻找中点 Des Windy和Zero居住在同一个国家，该国家有N个城市。Windy居住在X城市，Zero居住在Y城市。任意两个城市之间有且只有一条路径相通（中间可能经过其它城市）。有一天，Windy和Zero想见面，他们想把见面的地点定在城市X和城市Y的中间。现在请你告诉他们会见地点应该在哪里？ Sol 先计算2点间的路径(通过计算LCA实现),然后可以把中点城市的深度算出来,遍历到中点城市即可.(仍然需要倍增). My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/*- 首先输出离城市X近的城市的编号*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=1e5+5;int n,m;int lg[N&lt;&lt;2],depth[N];int f[N][20];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct lowestCommonAncestor{ void lg2() { for(int i=1;i&lt;=15;i++) lg[1&lt;&lt;i]++; for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1]; } void pre(int x,int father) { int len=g[x].size(); depth[x]=depth[father]+1; f[x][0]=father; for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i&lt;len;i++) { if(g[x][i]!=father) { pre(g[x][i],x); } } } int getLca(int x,int y) { if(depth[x]&gt;depth[y]) swap(x,y); for(int i=lg[depth[y]-depth[x]];i&gt;=0;i--) { if(depth[f[y][i]]&gt;=depth[x]) y=f[y][i]; } if(x==y) return x; for(int i=lg[depth[x]];i&gt;=0;i--) { if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; } return f[x][0]; } void solve(int x,int y) { if(x==y) { printf(&quot;%d\\n&quot;,x); return; } if(f[x][0]==y || f[y][0]==x) { printf(&quot;%d %d\\n&quot;,x,y); return; } int flag=true; if(depth[x]&lt;depth[y]) { flag=false; swap(x,y); } int anc=getLca(x,y); int dis=depth[x]+depth[y]-depth[anc]*2; int midDis=depth[x]-dis/2; for(int i=lg[depth[x]-midDis];i&gt;=0;i--) { if(depth[f[x][i]]&gt;=midDis) x=f[x][i]; } if(dis%2==1) { if(flag) printf(&quot;%d %d\\n&quot;,x,f[x][0]); else printf(&quot;%d %d\\n&quot;,f[x][0],x); } else printf(&quot;%d\\n&quot;,x); }}lca;int main(){ n=read(); for(int i=1;i&lt;n;i++) { int u=read(),v=read(); g[u].push_back(v); g[v].push_back(u); } lca.lg2(); lca.pre(1,0); m=read(); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(); lca.solve(u,v); } return 0;} Note 本来f数组开成了f[N][N],MLE了.结果以为是vector存邻接表的问题.呵呵. 树上差分算法介绍 给你一颗树,每次将路径\\((s,t)\\)上的所有点值加1,问最后最大点值是多少. 在树上运用差分思想即可解决. 树上差分算法实现 从根节点向下dfs,在回溯的时候加上差分标记.合理设置差分标记保证当前节点的点值正确即可. 差分思想的本质是记录某节点与另外节点的关系。在数组上，是与前面一个位置的元素的关系；而在树上，是与儿子的关系。 设需要添加路径\\((u,v)\\),\\(LCA(u,v)=lca\\). 对于对点值进行更新的点查分,执行\\(sub[u]++,sub[v]++,sub[lca]--,sub[father[lca]]--\\). 对于对边值进行更新的边差分,将边值下移到对应点.执行\\(sub[u]++,sub[v]++,sub[lca]-=2\\). 树上差分例题 P3128 [USACO15DEC]Max Flow P Des FJ给他的牛棚的N(2≤N≤50,000)个隔间之间安装了N-1根管道，隔间编号从1到N。所有隔间都被管道连通了。 FJ有K(1≤K≤100,000)条运输牛奶的路线，第i条路线从隔间si运输到隔间ti。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 Sol 板子题. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5,K=1e5+5,LG=17;int n,k,now,ans;int sub[N],depth[N],lg[N];int f[N][LG];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void pref(int x,int fa)//pretreat f[][]{ f[x][0]=fa,depth[x]=depth[fa]+1; for(int k=1;k&lt;=lg[depth[x]];k++) { f[x][k]=f[f[x][k-1]][k-1]; } int len=g[x].size(); for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) pref(g[x][i],x); }}int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v); while(depth[u]&lt;depth[v]) { v=f[v][lg[depth[v]-depth[u]]]; } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) { if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; } return f[u][0];}void getAns(int x,int fa){ int len=g[x].size(); for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) { getAns(g[x][i],x); sub[x]+=sub[g[x][i]]; } ans=max(ans,sub[x]); }}int main(){ n=read(),k=read(); for(int i=1;i&lt;=LG;i++) lg[1&lt;&lt;i]++; for(int i=2;i&lt;=n;i++) lg[i]+=lg[i-1]; for(int i=1;i&lt;n;i++) { int u=read(),v=read(); g[u].push_back(v); g[v].push_back(u); } pref(1,0);//无根树可将任何一个节点作为根 for(int i=1;i&lt;=k;i++) { int u=read(),v=read(); int lca=LCA(u,v); sub[u]++,sub[v]++,sub[lca]--,sub[f[lca][0]]--; } getAns(1,0); printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(LCA)/"},{"title":"【专题】树形动态规划","text":"简介 树形动态规划就是在树上进行的动态规划! 由于树的性质,父节点蕴含的信息肯定比子节点多.所以树形 DP 一般递归进行.在求解了子节点对应的子问题后,合并出父节点的信息. 能有树形 DP 解决的问题仍然具有动态规划的一般性质: 最优子结构 子问题的重叠性 无后效性 题目仍然具有一般动态规划的特征: 要求输出的信息是所有可能用到信息的一部分 具有不同的约束条件 根据约束条件确定转移状态,状态对应的值是答案信息. 类型 基础类型(约束条件为父亲/儿子) 本类问题很接近树形动态规划的本质.父子节点间相互有联系(其实就是状态).如果你第一次接触树形 DP,想要合适地转移或记录状态,其实比较困难.但好在本类问题的解法比较固定. P1352 没有上司的舞会 父节点选了子节点就不能选,父节点不选子节点就可以选或不选.是否意味着子节点的状态需要由父节点来确定呢? 回顾以前的动态规划,从来就没有这个道理! 其实.每个节点只有2种状态,选,或不选.父节点的状态完全可以从子节点转移过来.所以就有了方程 \\(f[u][0]=r[u]+\\sum_{edge(u,v)}f[v][1],f[u][1]=\\sum _{edge(u,v)}max(f[v][1],f[v][0])\\) 最后答案取\\(max(f[root][0],f[root][1])\\). SP1437 PT07Z - Longest path in a tree 设从根向下遍历的最长长度为\\(d1\\),次长长度为\\(d2\\),那么\\(ans=d1+d2\\).对于每个子树也是这样.满足无后效性(父节点的\\(d1\\)和\\(d2\\)必然从子节点的\\(d1\\)转移得到(可以归纳证明)). 如果\\(son.d1+son.d2+1&gt;father.d1\\),那么\\(father.d2=father.d1,father.d1=son.d1+son.d2+1\\). 否则,如果\\(son.d1+son.d2+1&gt;father.d2\\).那么\\(father.d2=son.d1+son.d2+1\\). P2016 战略游戏 约束条件为每个节点自己或儿子至少有一个放了士兵.自己放不放完全取决于儿子放没有. \\(f[u][0]=\\sum f[v][1]\\\\f[u][1]=1+\\sum min(f[v][1],f[v][0])\\) #10157. 「一本通 5.2 例 5」皇宫看守 上一题的升级版. 本题的约束条件为每个节点的父亲,儿子或自己必须有一个安排了警卫.我们总是首先考虑子节点向父节点的转移方式.不难发现,和子节点被谁看到有关.设\\(f[u][0],f[u][1],f[u][2]\\)分别表示节点被父亲,自己,儿子看到. 那么 \\(f[u][0]=\\sum_{edge(u,v)}min(f[v][1],f[v][2]),\\) \\(f[u][1]=c[u]+\\sum_{edge(u,v)}min(f[v][0],f[v][1],f[v][2]),\\) \\(f[u][2]=\\sum_{edge(u,v)}min(f[v][1],f[v][2])+d.\\) 其中\\(d=min(f[v][2]-min(f[v][1],f[v][2]))\\),保证至少有一个儿子看到. 结合背包(约束条件为选择根/枝条个数) P2015 二叉苹果树 子节点对父节点的依赖在于剩下能保留的枝条数量.但如果运用背包思想加维,就可去除这个依赖,即算出所有子节点可能的状态(不同的保留数量). 本题树为二叉树,具有特殊性质,所以可以用更简单的方法求解(给子节点分配数量). P2014 [CTSC1997]选课 与上一题相似,不在赘述.DP 方程为\\(f[u][sz]=max(f[u][sz],f[u][sz-k]+f[v][k])\\). P1273 有线电视网 其实这道题没有约束条件,把每个节点的信息保留好即可. DP 方程:\\(f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w)\\).","link":"/2021/03/22/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】状压 DP","text":"前言 前置知识: 位运算,基础动态规划 位运算的实际运用 判断第 i 位是否为 0 1S&amp;(1&lt;&lt;(i-1))==0 将第 i 位置为 1 1S|(1&lt;&lt;(i-1)) 将第 i 位置为 0 1S&amp;~(1&lt;&lt;(i-1)) 例题 POJ2411 Mondriaan's Dream Des Squares and rectangles fascinated the famous Dutch painter Piet Mondriaan. One night, after producing the drawings in his 'toilet series' (where he had to use his toilet paper to draw on, for all of his paper was filled with squares and rectangles), he dreamt of filling a large rectangle with small rectangles of width 2 and height 1 in varying ways. Expert as he was in this material, he saw at a glance that he'll need a computer to calculate the number of ways to fill the large rectangle whose dimensions were integer values, as well. Help him, so that his dream won't turn into a nightmare! 给出一个W行H列的广场,用1*2小砖铺盖,小砖之间互相不能重叠,问有多少种不同的铺法？ 1&lt;=W，H&lt;=11 Sol 每一行的状态只影响下一行,于是我们可以枚举状态来确定下一行怎么放.具体的操作看其他的题解吧. 这里用的 DFS 其实更适合入门. My code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;typedef long long ll;using namespace std;const int N=20,S=1&lt;&lt;13;int w,h,s;ll f[N][S];//第i行状态为s1,第i+1行状态为s2,当前在第d列 void dfs(int i,int s1,int s2,int d) { //不同的s1可能推出相同的s2 //列在d-1结束 if(d==w) {f[i+1][s2]+=f[i][s1];return;} if((s1&amp;(1&lt;&lt;d))==0) { //如果s1第d位是0 dfs(i,s1,s2|(1&lt;&lt;d),d+1);//将s2的第d位置为1 if(d&lt;w-1 &amp;&amp; (s1&amp;(1&lt;&lt;(d+1)))==0) { //如果第d+1位也是0 dfs(i,s1,s2,d+2); //横着放,不用管 } } else dfs(i,s1,s2,d+1); //放不了,也不用管 }int main() { while(cin&gt;&gt;w&gt;&gt;h &amp;&amp; w) { s=1&lt;&lt;w; memset(f,0,sizeof f); f[1][0]=1,dfs(1,0,0,0); for(int i=2;i&lt;=h;i++) { for(int j=0;j&lt;s;j++) { if(f[i][j]) dfs(i,j,0,0); } } cout&lt;&lt;f[h+1][0]&lt;&lt;endl; } return 0;}","link":"/2021/03/26/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%8A%B6%E5%8E%8B-DP/"},{"title":"【专题】算法正确性的证明-分治","text":"假设我们希望证明整个一系列无穷多个数学命题 A1，A2，A3，…， （它们合起来成为一般命题A）．假设a）通过某些数学论证证明了：如果r是任意正整数，且如果命题Ar已知是真的，则可推出命题Ar＋1也真；b）第一个命题A1已知是真的．那么，序列的所有命题必然都是真的，从而A得证． 摘自《什么是数学》。 前言 本文的大部分内容都受到《算法图解》的启发. 快速排序的正确性 基线条件:快速排序对只有一个元素或没有元素的数组管用(直接返回) 归纳条件: 快速排序对有2个元素的数组管用(会分成2个子数组,左边小于基准值,右边大于基准值). 快速排序对有3个元素的数组管用(分成2个子数组,一个元素数量为2,一个元素数量为1). 快速排序对有4个元素的数组管用(分成2个子数组,一个元素数量为2,另一个元素数量也为2). ...... 快速排序对有n个元素的数组管用. 基线条件+归纳条件,我们已经归纳证明了快速排序的正确性.","link":"/2021/03/13/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E-%E5%88%86%E6%B2%BB/"},{"title":"【专题】线性动态规划","text":"前言: 本文介绍了基础的线性动态规划,并给出了例题. 最长上升(不下降)子序列(LIS) 做法 \\(O(n^2)\\) 如果是不下降只用把f[i]&lt;f[j]改成f[i]&lt;=f[j] 方程:f[i]=max(f[j]+1) j∈i+1~n了 ps:每个位置的初始长度都是1!!!! 1234567891011121314151617181920212223242526272829303132333435363738//最长上升序列#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std;int n,a[5005],f[5005]; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; f[i]=1; }// f[n]=1;每个位置都是1 for(int i=n-1;i&gt;=1;i--) { for(int j=i+1;j&lt;=n;j++) { if(a[i]&lt;a[j]) f[i]=max(f[i],f[j]+1); } } int ans=0; for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i]); } cout&lt;&lt;ans; return 0;} \\(O(n\\ log\\ n)\\) O(n*logn)的进阶算法,主要思想是贪心和二分 导弹拦截 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100005],p,f[100005],k=0;int main(){ while(cin&gt;&gt;a[p]) { p++; } f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&lt;=f[k]) { f[++k]=a[i]; } else { int x=upper_bound(f,f+k,a[i],greater&lt;int&gt;())-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; k=0; memset(f,0,sizeof(f)); f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&gt;f[k]) { f[++k]=a[i]; } else { int x=lower_bound(f,f+k,a[i])-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; return 0; } 主要是贪心思想,对于每个a[i],如果a[i]&gt;f[end],a[i]就接在f[end]; 反之,替换掉f数组中大于a[i]的最小的(upper_bound(f.begin,f.end,a[i])) 不好严格证明,如下为示例: 样例: 121413 7 9 16 38 24 37 18 4 19 21 22 63 15 过程: 1234567891377 97 9 16 387 9 16 247 9 16 187 9 16 18 197 9 16 18 19 21 22 637 9 15 18 19 21 22 63 最长公共子序列(LCS) 描述 给定一个序列X=&lt;x1,x2,x3,x4...,xm&gt;，另一个序列Z=&lt;z1,z2,z3,z4...,zk&gt;，若存在一个严格递增的X的下标序列&lt;i1,i2,i3,...,ik&gt;对所有的1,2,3,...,k，都满足x(ik)=zk，则称Z是X的子序列 比如Z=&lt;B,C,D,B&gt;是X=&lt;A,B,C,B,D,A,B&gt;的子序列 做法 \\(O(n^2)\\) 方程:f(i,j)={f[i-1,j-1](a[i]=a[j]),max(f[i-1][j],f[i][j-1])(a[i]≠a[j]} 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;char a[205],b[205];int f[205][205]; int main(){// ios::sync_with_stdio(false); scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); strlen() int lena=strlen(a+1),lenb=strlen(b+1);//从下标1开始计算长度 size t cdecl strlen (const char Str) for(int i=1;i&lt;=lena;i++) { for(int j=1;j&lt;=lenb;j++) { if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); } } cout&lt;&lt;f[lena][lenb]; return 0;} 最经典的是这个图 img \\(O(n\\ log\\ n)\\) 具体看【题解】P1439 【模板】最长公共子序列.将LCS转化为LIS. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,t,f[N],r;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct line{ int x,y;}a[N];bool cmp(const line &amp;a,const line &amp;b){ return a.x&lt;b.x;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { t=read(); a[t].x=i; } for(int i=1;i&lt;=n;i++) { t=read(); a[t].y=i; } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(a[i].y&gt;f[r]) f[++r]=a[i].y; else *upper_bound(f+1,f+r,a[i].y)=a[i].y; } printf(&quot;%d\\n&quot;,r); return 0;}","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】线段树-进阶(含主席树)","text":"概览 介绍了标记永久化线段树和主席树. 标记永久化线段树 例题:P1083 [NOIP2012 提高组] 借教室 Des 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来\\(n\\)天的借教室信息，其中第\\(i\\)天学校有\\(r_i\\)个教室可供租借。共有\\(m\\)份订单，每份订单用三个正整数描述，分别为\\(d_j,s_j,t_j\\)，表示某租借者需要从第\\(s_j\\)天到第\\(t_j\\)天租借教室（包括第\\(s_j\\)天和第\\(t_j\\)天），每天需要租借\\(d_j\\)个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供\\(d_j\\)个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第\\(s_j\\)天到第\\(t_j\\)天中有至少一天剩余的教室数量不足\\(d_j\\)个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 Sol 这道题很容易相当直接用线段树做区间减法,过程中判断教室还够不够.但是,许多同学的线段树被卡了时间.我们就来看看如何写线段树才能过这道题. 1234567void pdown(int l,int r,int p){ ll mid=(l+r)&gt;&gt;1; tag[ls[p]]+=tag[p],ans[ls[p]]+=(mid-l+1)*tag[p]; tag[rs[p]]+=tag[p],ans[rs[p]]+=(r-mid)*tag[p]; tag[p]=0;} 在普通的push_down函数中,需要执行2次乘法,2次加法,还要将tag[p]赋值为0.粗略的看,这样延迟下传的好处是能减少一次update的时间.但如果数据满足一定条件,再执行几次update,每次都会执行多次push_down,花费的时间甚至可能更多.","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91-%E8%BF%9B%E9%98%B6(%E5%90%AB%E4%B8%BB%E5%B8%AD%E6%A0%91)/"},{"title":"【专题】莫队算法","text":"莫队 假设询问若干个区间的答案，但已知 \\([L,R]\\) 的答案，将计算左右端点增减 1 对答案更改的时间复杂度记为 \\(O(1)\\)，要想求出 \\([L',R']\\) 的答案则需要 \\(O(|L-L'|+|R-R'|)\\)。即将询问看作点后 2 点在二维平面上的曼哈顿距离。如果有多个询问，且询问间两两可以转移，想要得到走过所有点的最短路径（即哈密尔顿路径），则可跑一次曼哈顿最小生成树。但曼哈顿最小生成树的求解较为复杂，用莫队算法可以得到一个较好的询问处理顺序。 莫队算法将询问按左端点分块，每个块内的询问再按右端点排序。这样，右端点的移动是依次递增的，每个块内右端点的移动复杂度为 \\(\\Omega(n)\\)，设块长为 t，则左端点移动一次复杂度为 \\(\\Omega (t)\\)。左右端点移动的总复杂度为 \\(\\Omega(\\frac {n^2}t +nt)\\)，根据均值不等式算出来块长为 \\(t=\\sqrt n\\) 最合适，当然，块长会根据题目变化。 例题 小B的询问 带修莫队 在普通的莫队算法中，有一个很重要的概念是指向左右端点的左、右指针。指针位置的变化就代表了复杂度的增加。一般的题目中，一次修改带来的操作应是 \\(O(1)\\) 的，或者至少在可接受范围内。那么我们就可以引入一个“时间轴”的概念，设置一个时间指针来代表进行了多少修改。需要注意，因为这个时间指针需要前移或后移，那么修改操作就必须是可逆的。设一个操作为 \\((l,r,t)\\) ，那么新操作 \\((l',r',t')\\) 到原操作的距离则可看作三维空间中的曼哈顿距离。但是，我们仍然可以分块计算操作。 在之前的莫队算法中，我们注意到有 2 个关键字都需要排序。但显然不可能都保持有序，于是把左端点的位置降级为左端点所在块的位置。就算左端点在块内无序，移动的距离也相对较少。也就是说，我们实际上是找到了一种简单的方式将左右端点的移动都控制在 \\(O(n\\sqrt n)\\)。在下面的分析中，这种感觉会更强烈。 将左端点和右端点所在的块作为一二关键字排序，时间作为第三关键字排序（也可以交换一下顺序，甚至根据题目特点确定更好的排序方式，不再赘述）。将左右端点所在块的组合称之为新块，总块数设为 c，块长设为 t。那么可以列出下面的复杂度表格： 时间指针 左端点 右端点 跨块 \\(\\Omega(nc^2)\\) \\ \\(\\Omega(nc)\\) 块内 \\(\\Omega(nc^2)\\) \\(\\Omega(tn)\\) \\(\\Omega(tn)\\) 整理一下，再乱用记号，得到 \\(O(\\cfrac {n^3} {t^2}+tn)\\)，那么，块长为 \\(n^{\\cfrac 23}\\) 最合适（终于推对了）！总块数为 \\(n^{\\cfrac 13}\\)。 当然，带修莫队的复杂度并不优秀，它主要运用在分块不能解决的树上莫队的问题中。 树上莫队 利用欧拉序 例题 P4074 [WC2013] 糖果公园 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 树的欧拉序 欧拉序有 2 种，一种只记录节点出入栈，一种每次访问节点都记录。这里讲的是第一种 对树进行深度有限遍历，当一个节点入栈（递归栈）时，将它加入序列，当一个节点出栈时，也将它加入序列。得到的序列就是树的欧拉序。 假设有一颗树： 这棵树的欧拉序即为： 11 2 3 3 4 4 5 5 2 6 7 7 8 8 6 1 不难看出，设有一节点 u 在欧拉序中的位置分别为 \\(p_1,p_2\\)，那么 \\((p_1,p_2)\\) 代表的节点为 u 的子树所代表的节点组成的集合。 那么，假设 u 和 v 是兄弟关系，在 v 的欧拉序前，一定已经遍历完了 u 及其子树。 利用上面 2 点，我们可以得到欧拉序的几种应用： 求节点到任意父亲的权值和：从父亲访问欧拉序，若第一次遇见某节点，加上它的权值，若第二次遇见，减去它的权值。 求某个子树的权值和：累加欧拉序中 \\((u,u')\\) 内所有节点的权值和，再除以 2. 求任意 2 点路径上的权值和：设任意节点到根节点的权值和为 \\(root(u)\\)，那么 \\((u,v)=root(u)+root(v)-\\mathrm {val}(\\mathrm {LCA}(u,v))\\). 对欧拉序执行带修莫队 在上面讨论欧拉序时，求 2 点路径权值和是用到了 LCA 的，但每移动一次指针都要用到 LCA 显然不好操作，于是我们将与 LCA 有关的操作转移到询问上去。用 \\((l,r,t)\\) 直接记录区间的答案，表示 \\(root(r)-root(l)\\)，显然，这样做可能会漏掉 LCA，但直接特判就好了。 这里可以用另一种欧拉序将 LCA 转换为 RMQ 问题实现 \\(O(1)\\) 查询 LCA。并且，由于 2 种欧拉序的代码差不了多少，可以写在一个 DFS 里。 还是这棵树： 在 DFS 时每遇到一个栈中节点，就将它推入欧拉序： 11 2 3 2 4 2 5 2 1 6 7 6 8 6 1 假设有节点 u，v. u 在欧拉序中最后一次出现的位置是 \\(p_1\\)，v 在欧拉序中第一次出现的节点是 \\(p_2\\) ，那么 \\([p_1,p_2]\\) 中深度最小的节点即为 LCA(u,v). 这是因为：假设 u 在欧拉序中第一次出现的位置是 \\(q_1\\)，那么 \\([q_1,p_1]\\) 包含了 u 的子树。LCA(u,v) 第一次出现的位置和最后一次出现的位置间也是它的子树。其实，就算是记录每个节点第一次出现的位置，照样能求出 LCA，因为子树的深度必定小于 LCA 的深度。 另外，由于每个节点自己会记录一次，也会让自己的父亲被记录一次，所以这种欧拉序的长度不超过 \\(2n\\)。 莫队操作的细节 代码 1我真是最傻逼的傻逼，以后再说吧！ 分析 分块中对整块答案的预处理及其重要。若用分块解决此题，必然要记录整块区间某种糖果的数量，但这个区间根本无法加减。也就是说，无法用前缀和存储，甚至无法处理出整块区间 未完待续 将节点分块","link":"/2021/04/22/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"},{"title":"【专题】递推","text":"水水水水水 问题 A: 铺瓷砖 题目描述 用红色的 1×1 和黑色的 2×2 两种规格的瓷砖不重叠地铺满 n×3 的路面，求出有多少种不同的铺设方案。 输入 一行一个整数 n，0&lt;n&lt;1000。 输出 一行一个整数，为铺设方案的数量模12345的结果。 1:1 2:3 4:5 5:11 也就是2n+1,2n-1滴规律 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,ans=1; int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; if\\(n==1\\) cout\\&lt;\\&lt;ans; else \\{ for\\(int j=2;j\\&lt;=n;j++\\) \\{ if\\(j\\%2==0\\) \\{ ans=ans\\*2+1; \\} else \\{ ans=ans\\*2-1; \\} ans\\%=12345; \\} \\} cout\\&lt;\\&lt;ans; return 0; } 问题 B: 彩带 题目描述 一中 90 周年校庆，小林准备用一些白色、蓝色和红色的彩带来装饰学校超市的橱窗，他希望满足以下两个条件： (1) 相同颜色的彩带不能放在相邻的位置； (2) 一条蓝色的彩带必须放在一条白色的彩带和一条红色的彩带中间。 现在，他想知道满足要求的放置彩带的方案数有多少种。例如，如图 所示为橱窗宽度n=3 的所有放置方案，共 4 种。 输入 一行一个整数 n，表示橱窗宽度(或者说彩带数目)。 输出 一行一个整数，表示装饰橱窗的彩带放置方案数。 样例输入 Copy 3 样例输出 Copy 4 提示 对 30% 的数据满足：1≤n≤15。 对 100% 的数据满足：1≤n≤45。 斐波那契数列,但前两项都是2 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,f[50]; int main() { ios::sync_with_stdio(false); f\\[1\\]=f\\[2\\]=2; cin&gt;&gt;n; for\\(int j=3;j\\&lt;=n;j++\\) \\{ f\\[j\\]=f\\[j-1\\]+f\\[j-2\\]; \\} cout\\&lt;\\&lt;f\\[n\\]; return 0; } 1389: 城市路径 题目描述 地图上有 n 个城市，一只奶牛要从 1 号城市开始依次经过这些城市，最终到达 n 号城市。但是这只奶牛觉得这样太无聊了，所以它决定跳过其中的一个城市(但是不能跳过 1 号和 n 号城市)，使得它从 1 号城市开始，到达 n 号城市所经过的总距离最小。假设每一个城市 i 都有一个坐标(x i ，y i )，从 (x 1 ，y 1 ) 的城市 1 到 (x 2 ，y 2 ) 的城市 2 之间的距离为 | x 1 -x 2 | + | y 1 -y 2 | 。 输入 第 1 行 1 个正整数 n，表示城市个数。 接下来的 n 行，每行 2 个数 x i 和 y i ，表示城市 i 的坐标。 输出 一行一个数，使得它从1号城市开始，跳过某一个城市，到达n号城市所经过的最小总距离。 样例输入 Copy 4 0 0 8 3 11 -1 10 0 样例输出 Copy 14 提示 【样例说明】 跳过 2 号城市。 【数据规模】 对于 40% 的数据满足：n≤1000。 对于 100% 的数据满足：3≤n≤100000，-1000≤x i ，y i ≤1000。 pz:这不是枚举吗? #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int n,x[100005],y[100005],maxx,tot; int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=2;i&lt;=n;i++) { tot+=abs(x[i-1]-x[i])+abs(y[i-1]-y[i]); } for(int i=2;i&lt;n;i++) { int save=(abs(x[i-1]-x[i])+abs(y[i-1]-y[i])+abs(x[i+1]-x[i])+abs(y[i+1]-y[i]))-(abs(x[i-1]-x[i+1])+abs(y[i-1]-y[i+1])); if(save&gt;0&amp;&amp;save&gt;maxx) maxx=save; } cout&lt;&lt;tot-maxx; return 0; } 2020/3/28 20:21 歇息一下 问题 D: 偶数个3 题目描述 编程求出所有的 n 位数中，有多少个数中有偶数个数字 3。 输入 一行一个正整数 n，0&lt;n&lt;1000。 输出 一行一个正整数，表示 n 位数中有多少个数有偶数个 3，这个数可能会很大，请输出它%12345的值。 样例输入 Copy 2 样例输出 Copy 73 2020/3/28 22:10 1408: 数塔问题 题目描述 设有一个三角形的数塔，顶点为根结点，每个结点有一个整数值。从顶点出发，可以向左走或向右走，如图所示： 若要求从根结点开始，请找出一条路径，使路径之和最大，只要输出路径的和。 输入 第一行为n(n&lt;10)，表示数塔的层数 从第2行至n+1行，每行有若干个数据，表示数塔中的数值。 输出 输出路径和最大的路径值。 样例输入 Copy 5 13 11 8 12 7 26 6 14 15 8 12 7 13 24 11 样例输出 Copy 86 pz:dpdpdp #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,f[15][15],a[15][15],ans; int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ for\\(int j=1;j\\&lt;=i;j++\\) \\{ cin&gt;&gt;a\\[i\\]\\[j\\]; \\} \\} f\\[1\\]\\[1\\]=a\\[1\\]\\[1\\]; for\\(int i=2;i\\&lt;=n;i++\\) \\{ for\\(int j=1;j\\&lt;=i;j++\\) \\{ f\\[i\\]\\[j\\]=max\\(f\\[i-1\\]\\[j-1\\],f\\[i-1\\]\\[j\\]\\)+a\\[i\\]\\[j\\]; \\} \\} for\\(int i=1;i\\&lt;=n;i++\\) \\{ if\\(f\\[n\\]\\[i\\]&gt;ans\\) ans=f\\[n\\]\\[i\\]; \\} cout\\&lt;\\&lt;ans; return 0; }","link":"/2020/03/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E9%80%92%E6%8E%A8/"},{"title":"【图论】最短路问题","text":"单源最短路 设有向图 \\(G=(V,E)\\)，默认从点 \\(u\\) 到点 \\(v\\) 只有一条边。定义路径为 \\(p\\) 为由节点组成的多元组 \\((u_1,u_2,u_3,\\dots,u_n)\\)。那么路径 \\(p\\) 的长度 \\(l = u_1u_2+u_2u_3+\\dots+u_{n-1}u_n\\)。定义 \\(u_1\\) 的起点为路径的起点，\\(u_n\\) 的终点为路径的终点，那么起点为 \\(s\\)，终点为 \\(t\\) 的长度最短的路径 \\(s\\rightarrow t\\) 就叫做从 \\(s\\) 到 \\(t\\) 的最短路。 单源最短路算法的目的是求出图中一个节点到任意其他节点的路径 \\(s\\rightarrow t\\) 的最短路的长度。 Bellman-Ford 算法 设 \\((s,v_1,v_2,\\dots,v_n,t)\\) 为从 \\(s\\) 到 \\(t\\) 的最短路，那么 \\((s,v_1,v_2,\\dots,v_n)\\) 也必然为从 \\(s\\) 到 \\(v_n\\) 的最短路。设路径的元素个数减 1 为路径的步长，那么当求出了从 \\(s\\) 出发的所有步长为 \\(k\\) 的最短路，就可以求出所有步长为 \\(k+1\\) 的最短路。 设 \\(s\\) 到 \\(t\\) 的最短路长度为 \\(dist(t)\\)，Bellman-Ford 算法在求出步长为 \\(k\\) 的最短路后，遍历所有边，检查满足 \\(dist(u)+val(edge)&lt;dist(w)\\) 的不等式的存在。对成立的不等式的 \\(u,v\\)，执行 \\(dist(w)=dist(u)+val(edge)\\) 的“松弛”操作。这样，就可以求出步长为 \\(k+1\\) 的最短路。 初始时已求出步长为 0 的最短路，且 \\(dist(s)=0,dist(t)=inf(t\\neq s)\\). 显然，最短路的步长最大为 \\(n-1\\)，所以在执行 \\(n-1\\) 轮上述操作后，Bellman-Ford 算法求出了从 \\(s\\) 出发到任意点的最短路径的长度。 如果在执行了 \\(n-1\\) 轮上述操作后，还有可以被松弛的节点，就说明图中存在负环。 队列优化（SPFA 算法） 只有在求解步长为 \\(k\\) 的最短路时被松弛了的节点才能更新步长为 \\(k+1\\) 的节点，那么可以用队列记录这些节点，在求解步长为 \\(k+1\\) 的节点时只用这些节点来松弛其它节点。可以证明这样不会影响正确性。 SPFA 判断负环有 2 种方式： 记录每个点的被松弛次数，如果大于 \\(n-1\\)，就说明存在负环。 记录到每个点的最短路步长，如果大于 \\(n-1\\)，就说明存在负环。 第二种方式的效率要高一些。 Dijkstra 算法 算法流程不再赘述。 设集合 \\(S\\) 为算法中用到的已选点集，\\(short(u)\\) 表示从源点 \\(s\\) 到 \\(u\\) 的最短路距离。那么当算法进行到第 \\(k\\) 步时，\\(card(S)=k\\)。可以用数学归纳法证明对于 \\(\\forall k\\le card(V),k\\ge 1\\) 有 \\(dist(u)=short(u)(u\\in S)\\)。 全源最短路 求出图中任意点 \\(s\\) 到任意点 \\(t\\) 的最短路长度的算法。 Floyd 算法 设 \\(dp(i,j,k)\\) 表示从 \\(i\\) 到 \\(j\\) 可经过编号前 \\(k\\) 个点的最短路长度。初始时设所有 \\(dp(i,i,k)=0\\)，其余为 \\(inf\\)。若存在从 \\(i\\) 到 \\(j\\) 的路径，则设 \\(dp(i,j,k)=len(i,j)\\)。即 \\(dp(i,j,0)\\) 为原图的邻接矩阵。算法在外层枚举 \\(k\\)，内层枚举 \\(i,j\\)，若 \\(dp(i,k,k-1)+dp(k,j,k-1)&lt;dp(i,j,k)\\)，则更新 \\(dp(i,j,k)=dp(i,k,k-1)+dp(k,j,k-1)\\)。 代码 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dp[i][j][k]=min(dp[i][j][k],dp[i][k][k-1]+dp[k][j][k-1]); 空间优化 当 \\(i,j\\neq k\\) 时，\\(dp(i,j,k)\\) 的更新仅依赖于 \\(dp(i,k,k-1)\\) 和 \\(dp(k,j,k-1)\\)。当 \\(i=k,j\\neq k\\) 时，有 \\(dp(i,k,k-1)+dp(k,j,k-1)=0+dp(k,j,k-1)\\)，则 \\(dp(k,j,k)\\) 会更新为 \\(dp(k,j,k-1)\\)。 同理，当 \\(i\\neq k,j=k\\) 时，会导致 \\(dp(i,k,k)\\) 更新为 \\(dp(i,k,k-1)\\)。当 \\(i,j=k\\) 时，有 \\(dp(i,k,k-1)+dp(k,j,k-1)=0=dp(i,j,k)\\)。也就是说，求解 \\(\\forall dp(i,j,k)\\) 依赖的值不会改变，可以去掉 \\(k\\) 这一维。 应用 求传递闭包 传递闭包 将f[i][j]=f[i][k]+f[k][j] 更改为 f[i][j]=f[i][k]|f[k][j]. 求无向图的最小环 最小环为权值和最小的环. 考虑 Floyd 的性质.在还未更新f[i][j]时,f[i][j]代表的是从i到j不经过k的最短路. 联系环的特征.设一个环中编号最大节点为 k ,那么环的最短长度w=g[i][k]+g[k][j]+f[i][j]. 例题: P6175 无向图的最小环问题 My code: 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long long#define min(a,b) ((a)&lt;(b)?(a):(b))using namespace std;const int N=105,INF=1e12;int n,m,ans=INF;int g[N][N],d[N][N];signed main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=j) g[i][j]=d[i][j]=INF; for(int i=1;i&lt;=m;i++) { int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; g[u][v]=min(g[u][v],w),g[v][u]=min(g[v][u],w); d[u][v]=min(d[u][v],w),d[v][u]=min(d[v][u],w); } for(int k=1;k&lt;=n;k++) { for(int i=1;i&lt;k;i++) for(int j=i+1;j&lt;k;j++) ans=min(ans,g[i][k]+g[k][j]+d[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]),d[j][i]=d[i][j]; } if(ans==INF) printf(&quot;No solution.&quot;); else printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2021/03/19/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"title":"【小记】2019成都市青少年编程应用挑战赛","text":"今天 2019年12月8日上午 星期日，我参加了一场奇怪的比赛。 网址：https://www.stackedu.com/cd/ 这玩意在成外举行，学校让参加的，我们学校一共去了50个人（直接去考） 2个小时，一共5道。前3道都是水题，第四道是给一个数字串并删除几个数字获得最大的，搜索就行了。第五道考了一个图论，Floyd暴力分拿了。 考试考完感觉很蒙圈，这到底是个什么比赛？网址是小栈教育提供的，举办方又是成都市科学教育协会？？？ 反正干就对了，奥利给！！！","link":"/2019/12/08/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%912019%E6%88%90%E9%83%BD%E5%B8%82%E9%9D%92%E5%B0%91%E5%B9%B4%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E6%8C%91%E6%88%98%E8%B5%9B/"},{"title":"【小记】CSP-J2019游记&amp;解题报告","text":"考前一天晚上失眠.......(其实主要不是因为考试的原因) 很幸运,我们学校就是一个考点,本场作战,应该有一点加持吧. 上午在家复习,看到一篇关于PN532模拟小米手环加密卡的文章,于是,,,,,,,,你们懂的,荒废了. 下午1点过正式出征,在熟悉的学校排了一会,碰到几个同学,甚至还有小学同学! 2点半开考,先让我们看了10分钟卷子,我说这个完善程序第二题怎么这么简单啊(大雾),结果最后做自闭了.... 选择题出奇简单,事实证明我全对.而且,一个基础知识题都没有!CCF真的是大刀阔斧的改革! 读程序没什么可说的,逼疯众考生第二题只试了几组数据就写出来了,错了一个判断. 就是这道: 看样子是数据试少了(雾*2) 实际上你看看这答案解析不是在试数据是在干嘛!要不然谁搞得懂CCF出的鬼题是什么意思! 阅读程序第三道的最后一题,简直跪了,考场上猜了D 实际上我的思路是对的.最好的情况,也就是输出最小,就是每次都2分. 100 个节点的每层节点数量就是 （1,2,4,8,16,32,37）分别乘对应权值即可 1+4+12+32+80+192+259 但是,我天真的列出来1,2,4,8,16,32,64,算出来600多,呵呵... 完善程序第一道,简单,全对. 但这个思路清奇,加上位运算的使用,可以学习一下. 最后来说说完善程序第二道,难哭 重了几层数组,出题人不数数的吗!!!!! 好了,来说说正解. 我们先抛开双关键字,看看单关键字,最普通的基数排序. 找到一篇很好的文章:https://www.itcodemonkey.com/article/11750.html 这里是计数排序算法演示 : 还有网上找的代码: #include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace std; void COUNTINGSORT(int *A,int *B,int len,int k){ if(A == NULL || k &lt;= 0 || len &lt;= 0){ return; } int C[k+1],i; //初始化 for(i = 0;i &lt;= k;i++){ C[i] = 0; } //统计值为A[i]的个数,C[i]是等于i的元素个数 for(i = 0;i &lt; len;i++){ C[A[i]] ++; } //标记1 //确定值A[i]在最终输出数组B中位置,C[i]是小于等于i的元素个数 for(i = 1;i &lt;= k;i++){ C[i] += C[i-1]; } //输出到数组B中 for(i = len-1;i &gt;= 0;i--){ //index元素A[i]在数组B中的下标 int index = C[A[i]]; B[index] = A[i]; //如果有相同值元素的情况 C[A[i]] --; } //B下标从1开始 } int main(){ int A[8] = {2,5,3,0,2,3,0,3}; int B[9]; COUNTINGSORT(A,B,8,5); for(int i = 1;i &lt;= 8;i++){ printf(\"%d\\n\",B[i]); } return 0; } 在这个地方，其实相当于把程序的标记1做完了，下面的for循环就是在做前缀和,做完后是: 1 3 6 7 7 9 做了前缀和有什么用呢?看下面代码: for(i = len-1;i &gt;= 0;i--){ //index元素A[i]在数组B中的下标 int index = C[A[i]]; B[index] = A[i]; //如果有相同值元素的情况 C[A[i]] --; } 相当于题中的 ord[--cnt[b[i]]] = i 到这里便不难理解了. 最后回到考题双关键字,就是多套了几个数组,没什么区别. 自测分数84，等着出成绩吧，反正四川慢的很。（心里还有一点小激动呢） 最后 复赛good luck! 附2019CSP-J初赛试题及答案 链接: https://pan.baidu.com/s/1FmJHHaYZZSwDC_6J7I8x4A&amp;shfl=shareset 提取码: u6kv","link":"/2019/10/19/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91CSP-J2019%E6%B8%B8%E8%AE%B0&%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"【小记】Contest 210205","text":"在210205的校内测试.包含模拟,动态规划等算法. 题目已存档至硬盘 万能遥控器 第一道就是毒瘤模拟,TAT.先不改了,记录一下我的代码和标程吧. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;int n;char ip[100][50],ans[100][50];string s;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}bool special(int &amp;len){ for(int i=0;i&lt;len-2;i++) { if(s[i]==':'&amp;&amp;s[i+1]==':'&amp;&amp;s[i+2]==':') return true; } return false;}void solve(){ for(int j=0;j&lt;100;j++) { for(int k=0;k&lt;50;k++) { ip[j][k]='x'; ans[j][k]='x'; } } cin&gt;&gt;s; int len=s.length(),flag=-1,p=0,p_group=-1; if(special(len)) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } for(int j=0;j&lt;len;j++) { if(j&lt;len-1&amp;&amp;s[j]==':'&amp;&amp;s[j+1]==':') { if(flag==-1) flag=p; else { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } p++; j++; p_group=-1; } else if(s[j]==':') { p++; p_group=-1; } else ip[p][++p_group]=s[j]; } if((p&lt;7&amp;&amp;flag==-1) || p&gt;7 || (p==6 &amp;&amp; flag&gt;=0)) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } for(int j=0;j&lt;=p;j++) { int tot=0; for(int k=0;k&lt;50;k++) { if(ip[j][k]=='x') break; else if((ip[j][k]&gt;='0'&amp;&amp;ip[j][k]&lt;='9') || (ip[j][k]&gt;='A'&amp;&amp;ip[j][k]&lt;='F')) { tot++; } else { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } } if(tot&gt;4) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } else { for(int k=0;k&lt;4-tot;k++) { ans[j][k]='0'; } for(int k=4-tot;k&lt;4;k++) { ans[j][k]=ip[j][k-4+tot]; } } } for(int j=0;j&lt;=p;j++) { for(int k=0;k&lt;4;k++) { if(ans[j][k]=='x') { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } cout&lt;&lt;ans[j][k]; } if(j!=p) cout&lt;&lt;':'; if(j==flag) { for(int k=1;k&lt;=(7-p);k++) { printf(&quot;0000&quot;);//bug,but solved if(k+j!=7) putchar(':'); } } } cout&lt;&lt;endl;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { solve(); } return 0;} 137行,学OI来写的最多的一次. 标程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;char s[100], a[100];int main(){ freopen( &quot;ipv6.in&quot;, &quot;r&quot;, stdin ); freopen( &quot;ipv6.out&quot;, &quot;w&quot;, stdout ); int n; scanf( &quot;%d\\n&quot;, &amp;n ); for ( int ii = 1; ii &lt;= n; ii++ ) { memset( s, '0', sizeof(s) ); memset( a, '0', sizeof(a) ); char c; int p1 = 0, p2 = 0, p3 = 0, p4 = 0, k = 0, point = 0; while ( (c = getchar() ) != EOF &amp;&amp; c != '\\n' ) { s[++k] = c; if ( c == ':' ) { p1 = 0; p2++; }else p1++; if ( p1 &gt; 4 || p2 &gt; 7 ) p4 = 1; if ( c == ':' &amp;&amp; s[k - 1] == ':' ) { p3++; point = k; } if ( p3 &gt; 1 ) p4 = 1; } if ( !p3 &amp;&amp; p2 &lt; 7 ) p4 = 1; if ( p3 &amp;&amp; p2 == 7 &amp;&amp; point != 2 &amp;&amp; point != k ) p4 = 1; for ( int i = 1; i &lt;= k; i++ ) a[i] = s[k - i + 1]; if ( p4 ) { printf( &quot;INVALID\\n&quot; ); continue; } int q = 0; p1 = 0; for ( int i = 1; i &lt;= k; i++ ) { s[++q] = a[i]; p1++; if ( a[i] == ':' ) { q--; while ( p1 &lt; 5 ) { s[++q] = '0'; p1++; } s[++q] = ':'; p1 = 0; if ( a[i + 1] == ':' ) { while ( p2 &lt;= 7 ) { for ( int j = 1; j &lt;= 4; j++ ) s[++q] = '0'; s[++q] = ':'; p2++; } q--; p1 = 4; } } } for ( int i = 39; i &gt;= 1; i-- ) printf( &quot;%c&quot;, s[i] ); cout &lt;&lt; endl; } return(0);} 收藏钻石 这道题很有意思呀,乍一看以为是二分答案,结果要分成2个陈列架.然后想到用一块板子将钻石们分开,左右2边分别二分答案,但这样复杂度是 O ( n 2 l o g n ) O(n^2 log\\ n) O(n2logn).考虑优化,首先第一层枚举板子的循环肯定不能再优化了,难道优化二分答案? 结果真的是优化二分答案,考场上想出了一种DP方案. 若 m 表 示 所 有 满 足 a [ i ] − a [ i − m ] ≤ k 的 m 的 最 小 值 , 则 f [ i ] = m a x ( f [ i − 1 ] , m + 1 ) 若m表示所有满足a[i]-a[i-m]\\le k的m的最小值,则\\\\f[i]=max(f[i-1],m+1) 若m表示所有满足a[i]−a[i−m]≤k的m的最小值,则f[i]=max(f[i−1],m+1) 然后正向和反向分别DP一次,再插板,即可求出最终答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,k,s[N],ans,l[N],r[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ freopen(&quot;diamond.in&quot;,&quot;r&quot;,stdin); freopen(&quot;diamond.out&quot;,&quot;w&quot;,stdout); n=read(); k=read(); for(int i=1;i&lt;=n;i++) { s[i]=read(); } sort(s+1,s+n+1); l[1]=r[n]=1; l[0]=r[n+1]=0; for(int i=2;i&lt;=n;i++) { int x=l[i-1]; while(s[i]-s[i-x+1]&lt;=k&amp;&amp;i-x&gt;=0) { x++; } l[i]=max(l[i-1],x-1);// cout&lt;&lt;l[i]&lt;&lt;' '; }// cout&lt;&lt;endl; for(int i=n-1;i&gt;=1;i--) { int x=r[i+1]; while(s[i+x-1]-s[i]&lt;=k&amp;&amp;i+x&lt;=n+1) { x++; } r[i]=max(r[i+1],x-1);// cout&lt;&lt;r[i]&lt;&lt;' '; }// cout&lt;&lt;endl; for(int i=0;i&lt;=n;i++) { ans=max(ans,l[i]+r[i+1]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} sequence 最难的一道DP.看了题解,还结合了另外的算法,于是先去把字符串哈希做了. 决定以后hash的mod就用1e9+7和1e7+7,base为131 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=1e4+5,mod=1e9+7,base=131;int n,ans;ll a[N];string s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; int len=s.length(); for(int j=0;j&lt;len;j++) { a[i]=(a[i]*base+(ll)s[j])%mod; } } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]==a[i+1]) ans++; } cout&lt;&lt;n-ans; return 0;} 回到这道题,我的思考过程落脚于将数列分开的\"切点\".切点前数列的长度一定小于等于切点后数列的长度.然后就开始愉快的正向DFS模拟了,每次可以将剩下没切的数列切下一块,但切的长度,要么是小于等于剩下长度的二分之一,要么是等于剩下的长度(切完).中途会比较本次切的部分与上次切的部分的大小. 一份代码就出炉了: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e3+5,mod=1e9+7;int n,ans;int s[N];bool cmp(const int &amp;l1,const int &amp;r1,const int &amp;l2,const int &amp;r2)//if l1 to r1&gt;l2 to r2{ if(r1-l1&gt;r2-l2) return true; else if(r1-l1==r2-l2) { for(int i=l1;i&lt;=r1;i++) { if(s[i]&lt;s[l2+i-l1]) return false; if(s[i]==s[l2+i-l1]&amp;&amp;i==r1) return false; } return true; } else return false;}void solve(int l,int r,int pre_l,int pre_r){ if(l==r) { (ans+=1)%=mod; return; } if(s[l]==0) return; int pre_size=pre_l-pre_r+1; for(int i=pre_size;i&lt;=((r-l+1)/2);i++) { if(cmp(l,l+i-1,pre_l,pre_r)) solve(l+i,r,l,l+i-1); } if(cmp(l,r,pre_l,pre_r)) { solve(r,r,l,r); }}int main(){ freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%1d&quot;,&amp;s[i]); } solve(1,n,0,0); cout&lt;&lt;ans%mod; return 0;} 首先DFS不是正解DP,复杂度就被卡掉了,其次正确性还出了问题,另外,根本就没考虑到cmp函数会是正解程序优化的着重部分,复杂度Up. 如果复杂度过高,n=10的部分解也有30分,也是个不错的选择,但因为正确性问题,最终只得到了10分. 开始正解分析: 本题的答案需要mod 1e9+7,显然考虑DP求总方案数.定义f[i][j]为取[i,j]为最后一段的总方案数,那么f[i][j]可以由f[k][i-1]转移得到(k&lt;i-1).","link":"/2021/02/05/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Contest%20210205/"},{"title":"【小记】Hello,Hexo!","text":"Welcome to Hexo! 2021/2/21 搭建了在github上的hexo博客!计划将csdn和博客园的所有博客搬过来,并稍微美化一下. 在搭建过程中用到的资料: 超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否 CSDN博客迁移到Hexo(提供格式转换)_huoji555的博客-CSDN博客 超详细Hexo+Github博客搭建小白教程 - 知乎 (zhihu.com)","link":"/2021/02/21/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Hello,Hexo!/"},{"title":"【小记】OI 日记（2021&#x2F;5）","text":"5月 210521 把数学下面的分类替换了，用《具体数学》里面的方法分类。","link":"/2021/05/21/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91OI-%E6%97%A5%E8%AE%B0%EF%BC%8820215%EF%BC%89/"},{"title":"【小记】SSZX集训 Contest 20210203 递推,最小生成树,矩阵快速幂,染色","text":"在210203的测试. 题目已存档至百度网盘 前言: 还行,就是有人AK,令人不爽 方阵(matrix) 标程是记录每行每列的染色时间,我的做法是从指令最后往前处理,染色过的就不能再染了.时间复杂度为 O ( n + n m + q ) O(n+nm+q) O(n+nm+q),可以通过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*从后往前排，排过的就锁住不能再排了问题：1、快写居然出问题了 */#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXQ=1e6+5,MAXN=1e3+5;int n,m,q,x[MAXQ],y[MAXQ],z[MAXQ],tot;bool vish[MAXN],visl[MAXN],vis_map[MAXN][MAXN];int ans[MAXN][MAXN];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s*x;}//void write(int x)//{// if(x&lt;0)// {// x=-x;// putchar('-');// }// else if(x&gt;9)// {// write(x/10);// }// putchar();//}int main(){ freopen(&quot;matrix.in&quot;,&quot;r&quot;,stdin); freopen(&quot;matrix.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); q=read(); const int tot_map=n*m; for(int i=1;i&lt;=q;i++) { x[i]=read();y[i]=read();z[i]=read(); } for(int i=q;i&gt;=1;i--) { int h=y[i]; if(x[i]==1&amp;&amp;vish[h]==false) { for(int j=1;j&lt;=m;j++) { if(vis_map[h][j]==false) { ans[h][j]=z[i]; vis_map[h][j]=true; tot++; } } vish[h]=true; } if(x[i]==2&amp;&amp;visl[h]==false) { for(int j=1;j&lt;=n;j++) { if(vis_map[j][h]==false) { ans[j][h]=z[i]; vis_map[j][h]=true; tot++; } } visl[h]=true; } if(tot==tot_map) break; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { printf(&quot;%d&quot;,ans[i][j]); putchar(' '); } putchar('\\n'); } return 0;} 另外,此题的write函数居然出锅了,应该这么写: 12345678910111213void write(int x){ if(x&lt;0) { x=-x; putchar('-'); } else if(x&gt;9) { write(x/10); } putchar(x%10+48);} 即putchar(x%10+48)不是putchar(`x%10+48`) 坐标系(coordinate) 此题为Openjudge那道奶牛散步数据加强版,递推经典题呀.递推关系式为 f n = 2 f n − 1 + f n − 2 f_n=2f_{n-1}+f_{n-2} fn​=2fn−1​+fn−2​.但今天做的时候显然忘记了,于是先搞了一个dfs把前几项算了出来.又因为前几天在接受数学的熏陶,弄了很久的差分表,结果发现根本弄不出来,直接吐血.(其实显然弄不出来,因为答案并不能被表示为多项式) 但好就好在,偶从差分表中看出了规律,最后列出了递推关系式. 另外,这道题数据范围过大,考虑优化. 方案一: 打表 在本机测试了用时: 1231000000000999999966Use Time:16.217000 也就是说,我们将复杂度优化到 1 0 7 10^7 107即可. 我 们 已 经 知 道 了 f n = 2 f n − 1 + f n − 2 , 那 么 显 然 , 要 知 道 f n , 只 用 知 道 f n − 1 和 f n − 2 . 选 择 打 出 所 有 f n 与 f n + 1 ( n = 1 0 7 k , k 为 正 整 数 ) 我们已经知道了f_n=2f_{n-1}+f_{n-2},那么显然,要知道f_n,只用知道f_{n-1}和f_{n-2}.选择打出所有f_n与f_{n+1}(n=10^7k,k为正整数) 我们已经知道了fn​=2fn−1​+fn−2​,那么显然,要知道fn​,只用知道fn−1​和fn−2​.选择打出所有fn​与fn+1​(n=107k,k为正整数) 具体操作如下代码,也是考试时写出来的.打表的数据是用原本的未优化代码生成的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n;ll biao1[1005]={0,627935421,438953224,542068249,329814112,560895073,119554882,817838024,413683704,457693522,548686427,625090930,854797397,507897869,61876493,38377219,305397032,834552550,86754567,509991039,595114395,406847212,670491536,432878314,135680620,898309326,728242939,198112061,177816349,19047210,455754392,852650532,521176598,71125034,245305647,837039919,188113267,56598060,432474979,432717386,87865010,771920945,438742654,288408342,246724129,896686551,339943192,339062029,917394372,746339567,880572807,739796257,59753287,776287897,225152152,836502060,948930900,475746791,722277745,851272656,790561977,985377610,885700761,132420780,835281543,520522277,705708011,107967744,357214655,287632826,452485219,234406704,490642737,105936544,662318372,10700633,44184524,425184700,853280967,501062760,425337376,984713729,821083793,448257541,299730624,956477347,53544543,258784453,686484973,12946211,133711137,828167667,821810848,728440912,992782964,810060630,81297710,592494925,333385653,68086064,999999966};ll biao2[1005]={0,316019740,372654023,224763656,22469312,782122008,34120220,931864090,425814224,323613731,426904732,655133268,419960676,600143856,636422754,404303050,514440356,364914981,228761950,38777592,133257557,122058434,66188449,284201981,606451036,708146069,58038914,491958600,718356299,472529774,855728576,454092882,3075198,128033925,672313652,274523182,685346016,965382417,79327031,70919624,314176084,524093558,507000754,423517629,401454042,306672104,839594331,294033500,29439574,960708835,59713600,296223267,981986607,148291544,877858011,326733601,500718454,694404815,412489057,164309652,746610433,220032885,261585106,940108177,802956593,46695727,852179533,782419693,57729179,975765453,190151629,400743276,947414172,856017108,746680441,337348962,303616399,286766519,671925310,423986587,856516568,213870031,317318877,493679984,182995823,98269674,305866735,16514990,809398153,525848172,231896493,533455685,956438514,294996456,409710864,32400151,771974784,207954764,741176549,835969528};int main(){// freopen(&quot;coordinate.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;coordinate.out&quot;,&quot;w&quot;,stdout); register long long f[3]={3,7}; register long long mod=1e9+7; cin&gt;&gt;n; if(n&lt;=2) { cout&lt;&lt;f[n-1]&lt;&lt;endl; return 0; } if(n&lt;=10000000) { for(register int i=3;i&lt;=n;i++) { f[2]=(2*f[1]+f[0])%mod; f[0]=f[1],f[1]=f[2]; } cout&lt;&lt;f[2]&lt;&lt;endl; } else { int k=n/10000000; n%=10000000; f[0]=biao1[k]; f[1]=biao2[k]; if(n&lt;=1) { cout&lt;&lt;f[n]&lt;&lt;endl; return 0; } for(register int i=2;i&lt;=n;i++) { f[2]=(2*f[1]+f[0])%mod; f[0]=f[1],f[1]=f[2]; } cout&lt;&lt;f[2]&lt;&lt;endl; } return 0;} 方案二: 矩阵快速幂 递推关系式的优化都可以用到矩阵快速幂,前几天讲课时也提到过,我已经写了一篇新的博客来介绍.","link":"/2021/02/03/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91SSZX%E9%9B%86%E8%AE%AD%20Contest%2020210203%20%E9%80%92%E6%8E%A8,%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91,%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82,%E6%9F%93%E8%89%B2/"},{"title":"【小记】刷题记录-2021.3","text":"3月份的刷题记录! #开头为WOJ,P开头为洛谷.其余用字母标注.标有未的说明当天未做完或放弃. 3月9日 专题:线段树 new #1684 【线段树 或 树状数组】快速求和计算 #1723 区间修改单点查值 #2138 修改序列 线段树模版(双倍经验为什么不拿呢) P2184 贪婪大陆 P4588 [TJOI2018]数学计算 线段树-queryPlus P4513 小白逛公园 #2088 程序设计竞赛 SP1557 GSS2 - Can you answer these queries I #2126 哨戒炮(未) 线段树-pushupPlus P5490 【模板】扫描线(未) 线段树-扫描线 old 今天都在做新题. re P5018 [NOIP2018 普及组] 对称二叉树 二叉树.Manacher也可? 3月10日 new P3834 【模板】可持久化线段树 2（主席树） 主席树! old 日拱一卒无有尽,功不唐捐终入海. re #2126 哨戒炮 线段树-pushUpPlus P1531 I Hate It 线段树,单点修改区间询问 contest Standings - Codeforces Round #706 (Div. 2) - Codeforces 3月11日 new P1083 [NOIP2012 提高组] 借教室 差分,二分答案. 3月12日 new 【模板】最近公共祖先（LCA） - 洛谷 (luogu.com.cn) LCA模版 T168100 星图（升级版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 树状数组+离散化 P3128 USACO15DECFlow P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) LCA+树上差分 P3938 斐波那契 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 数学,图论 re P2058 NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) %你,合理存储数据(queue,vector) 3月13日 old SP1716 GSS3 - Can you answer these queries III 线段树pushUpPlus re SP1805 HISTOGRA - Largest Rectangle in a Histogram 单调栈 3月15日 new P1967 [NOIP2013 提高组] 货车运输 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 生成树pathMinMax+LCA-getPlus P4047 [JSOI2010]部落划分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 生成树pathMinMax P1991 无线通讯网 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 生成树pathMinMax T70138 寻找中点 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) LCA-queryPlus P2872 [USACO07DEC]Building Roads S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 最小生成树 old P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) HDU Problem - 2838 Cow Sorting 树状数组-queryPlus","link":"/2021/03/12/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-2021.3/"},{"title":"【小记】对ABBYY FineReader功能的探究","text":"ABBYY FineReader,一个强大的PDF阅读器和OCR识别器! 阅读主界面 OCR主界面 资源就不贴了,不过提示一下大家:Google Search 懒 得 勤 快,就可以找到. 经过研究,发现以下几点: 1.可以用此工具代替打印机扫描软件,支持连续扫描,同步OCR 2.OCR识别率挺高,但对公式,表格支持不太好 3.保存格式不要用\"可搜索的PDF\",卡的要死 4.电子书只能保存epub格式 5.可发送文档到KINDLE!","link":"/2019/11/02/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E5%AF%B9ABBYY%20FineReader%E5%8A%9F%E8%83%BD%E7%9A%84%E6%8E%A2%E7%A9%B6/"},{"title":"【小记】惨痛の教训","text":"2021/2/2 16:03 #3827 The XOR Largest Pair 因为乱改了maxn,导致WA91分的代码变成了WA9分,调试了半个小时,终于发现了问题… 教训: 一定要把目前得分最多的代码存档! 2021/2/2 19:35 gcd(-1,1)=-1(辗转相除法) gcd(-1,1)=1(数学意义上)","link":"/2021/02/02/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%83%A8%E7%97%9B%E3%81%AE%E6%95%99%E8%AE%AD/"},{"title":"【小记】我的首次AK记","text":"哈哈哈！本蒟蒻终于在今天中午机房测试中AK全场了（其实没啥技术含量，只有5个水题，对，全都很水）","link":"/2019/10/21/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%88%91%E7%9A%84%E9%A6%96%E6%AC%A1AK%E8%AE%B0/"},{"title":"【小记】梦开始的地方","text":"明天就是CSP（NOIP）2019年初赛了，我注册了博客园，希望能够以此手段督促自己，更好的成长","link":"/2019/10/18/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"},{"title":"【小记】Manjaro Linux使用1月滚粗记","text":"每个OIer都有对Linux的向往(雾) 这不,一个月前我便看上了Manjaro,主要原因是因为Manjaro软件包全,安装简便,下面就来说说我退回windows的原因: 1.桌面卡顿,我用的gnome桌面,切换窗口,新建窗口时总是没有windows那种丝滑. 2.软件不全,虽然有QQ,微信,Chrome,但是还是满足不了我的搞机需求 3.资料太少,manjaro的网上资料少的一批,贴吧人都没有 4.使用不便(搞了半天都没弄好C++的调试环境,dock栏还不见了!!!),Linux嘛,大家懂的,我怎么会用呢...... 综上,换回了windows10 LTSB 2016!!!爽!!!!","link":"/2019/10/20/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Manjaro%20Linux%E4%BD%BF%E7%94%A81%E6%9C%88%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"title":"【小记】滑蒻稽的 代 码 规 范","text":"updated on 2021/3/10 话说代码规范这个东西啊,就是为了形成一个模式,让你在编程的时候不用动太多脑子去思考\"这个变量定义在哪???\"之类的问题! 特例 为了方便,特例中的代码风格优先级最高.不受下方约束.多为常用模版. 1234567inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } 123456void write(int x){ if(x&lt;0) {putchar('-');x=-x;} if(x&gt;9) write(x/10); putchar(x%10+48);} 空格 一般不打空格 if语句中&amp;&amp;和||前后必须加. 若if语句与执行语句处于同一行,if语句后加空格,例: if(huaruojiJuruo==true) cout&lt;&lt;\"huaruojiJuruo.\"; 空行 include后有一空行. 全局变量声明与第一个函数中有一空行. 不同函数间有一空行. 在函数中为区分不同功能区可加空行(输入部分与计算部分). 例: 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n,a[105];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } for(int i=1;i&lt;=n;i++) { a[i]+=a[i-1]; } cout&lt;&lt;a[n];} 换行 对于执行意义不同的两条语句,分行写. 执行意义或符号相同的两条语句,在同一行写并用逗号隔开. 使用右边界,长度为100. 花括号 在未知执行语句有几行的情况下,一律在if for while 语句后加入花括号.如果为了发布题解等进行亚行可以理解. 例: 123456789101112for(int i=1;i&lt;=n;i++){ int a=1;}if(n==3){ cout&lt;&lt;&quot;No\\n&quot;;}while(1){ cout&lt;&lt;&quot;yes\\n&quot;;} 缩进 使用一个tab作为缩进. 变量 对于多个函数要使用值但不修改的变量,定义在函数内部,或传参传引用传指针. 对于多个函数要修改的变量,定义为全局变量. 变量使用小驼峰命名法. 对于全局变量,基本按照变量占用内存空间从小到大顺序分行定义:单个普通类型变量(bool,char,int,long long),数组类型变量(长度小),数组类型变量(长度大),STL容器.","link":"/2021/03/12/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%BB%91%E8%92%BB%E7%A8%BD%E7%9A%84-%E4%BB%A3-%E7%A0%81-%E8%A7%84-%E8%8C%83/"},{"title":"【杂项】C++程序计时器模版(用于计算某个代码块用时)","text":"12345678910111213#include&lt;time.h&gt;#include&lt;stdio.h&gt;int main(){ double dur; clock_t start,end; start = clock(); foo();//dosomething end = clock(); dur = (double)(end - start); printf(&quot;Use Time:%f\\n&quot;,(dur/CLOCKS_PER_SEC));} 精确到毫秒","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91C++%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E6%A8%A1%E7%89%88(%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97%E7%94%A8%E6%97%B6)/"},{"title":"【杂项】OI中的C++语法基础&amp;进阶技巧","text":"前言: 写这个的目的主要是为了总结在OI中用到的C++语法奇淫巧技以及在入门的时候没学好的C/C++语言语法部分 数据类型 OI中常用的数据类型大小 数据类型 范围 位数 int -2147483648~2147483647 10 unsigned int 0~4294967295 10 long long -9223372036854775808~92233,72036,85477,5807 19 unsigned long long 0~18446744073709551615 20 总之,9位数能安全地用int存下,18位数用long long,19位数或是 2 64 2^{64} 264以内用unsigned long long. 另外,合理利用unsigned类型的自动溢出机制可以实现取模运算中的骚操作–快速乘. 输入输出相关(printf,cout) printf 关于printf菜鸟教程已经讲得很详细了,下面给出几个实例: 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ printf(&quot;%-6d\\n&quot;,3); printf(&quot;%+06d\\n&quot;,3); printf(&quot;%010.2f\\n&quot;,32434.434); unsigned long long a=1; for(int i=1;i&lt;=64;i++) a*=2; a--; printf(&quot;%llu&quot;,a); return 0;} 输出: 12343+000030032434.4318446744073709551615 关于scanf输入单个字符的问题 scanf(\"%c\")会将空格输入 scanf(\" %c\")则不会. 结构体(struct) 结构体以前比较常用的是带结构体排序,就不再提及.高阶技巧便是把结构体当作一个简单版class用,可以封装一些函数,结构体中的运算符重载也能节约不少时间. 初始化 12345678910111213141516171819202122struct test{ int a,b,c; test(int p,int q) { a=p,b=q; } test(char s) { c=s-'A'; }};int main(){ test a=test(3,5); test b(3,5); test c('A'); cout&lt;&lt;a.a&lt;&lt;' '&lt;&lt;b.b&lt;&lt;' '&lt;&lt;c.c; return 0;} 输出: 13 5 0 简单来讲就是让新建一个结构体变量的操作变方便了 运算符重载 别看代码短,其实有很多东西 12345678910111213141516171819202122232425262728293031323334353637383940414243struct test{ int a,b,c; test(int p,int q) { a=p,b=q; } /* 下面这个函数的返回值为bool,重载的运算符为&lt;,运算符左边的数据类型为test,右边 的数据类型也为test 括号内const和&amp;的用途在于加速和不改变源值 第二个const放在非静态成员函数的尾部，表示该非静态成员函数不修改对象内容 */ bool operator &lt; (const test &amp;m) const { if(a&lt;m.a) return false; else return true; } bool operator &gt; (const test &amp;m) const { if(b&gt;m.b) return true; else return false; } int operator + (const test &amp;m) const { return a+b+m.a+m.b; } test operator - (const test &amp;m) const { test q(a-m.a,b-m.b); return q; }};int main(){ test a=test(3,5); test b(2,6); test c(3,7); cout&lt;&lt;(a&lt;b)&lt;&lt;' '&lt;&lt;(a&gt;b)&lt;&lt;' '&lt;&lt;(a+b)&lt;&lt;' '&lt;&lt;(b-c+a); return 0;} 输出: 11 0 16 6 面向对象编程 参看菜鸟教程 字符串处理 transform函数 将字符串按照指定规则进行转换.使用方法为transform(源字符串首迭代器,源字符串尾迭代器,存放字符串首迭代器,转换规则(::tolower或::toupper)). 123string a=&quot;asvssd&quot;;transform(a.begin(),a.end(),a.begin(),::toupper);cout&lt;&lt;a; 输出: ASVSSD assign函数 用于重置字符串的值. Example 12345678910111213141516171819202122232425262728293031323334// string::assign#include &lt;iostream&gt;#include &lt;string&gt;int main (){ std::string str; std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;; // used in the same order as described above: str.assign(base); std::cout &lt;&lt; str &lt;&lt; '\\n'; str.assign(base,10,9); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;brown fox&quot; str.assign(&quot;pangrams are cool&quot;,7); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;pangram&quot; str.assign(&quot;c-string&quot;); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;c-string&quot; str.assign(10,'*'); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;**********&quot; str.assign&lt;int&gt;(10,0x2D); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;----------&quot; str.assign(base.begin()+16,base.end()-12); std::cout &lt;&lt; str &lt;&lt; '\\n'; // &quot;fox jumps over&quot; return 0;} Output 1234567The quick brown fox jumps over a lazy dog.brown foxpangramc-string**********----------fox jumps over reverse函数 1template &lt;class BidirectionalIterator&gt; void reverse(BidirectionalIterator first, BidirectionalIterator last); 反转给定范围的容器序列 关于 memset 学 OI 两年多,现在才知道 memset 是把内存重置.之前一直不理解 memset 的原理. 比如memset(a,0x3f,sizeof a),如果a是 int 数组,那么a中的每个数都会变成0x3f3f3f3f. 位运算 补码与负数 首先，C++ 中的负数是按补码形式存储的，也就是说-1会存储为1111 1111（假设只有8位）。 在进行左移和右移位运算时，溢出的部分（不管是小于0还是大于最大值）都会被舍弃。比如0000 0111 是一个8位有符号整型，将其右移7位，会得到1000 0000。并且要注意，此时的第一位是符号位，符号位为1表示该数是按补码存储的负数。也就是说，该数现在的实际值是-128（补码的补码就是原码1111 1111）。 异或，并，或在单位运算上的作用 设 \\(i=0\\ \\rm or \\ 1\\) ，那么 i^1 可以将 i 取反，i&amp;1 相当于不对 i 进行任何操作，i&amp;0 相当于得到0，i|1 相当于得到1。 在状压 DP 中的运用 获取某一位的值（位从0开始编号）： 1int getBit(int a,int b) {return (a&gt;&gt;b)&amp;1;} 前面说过，&amp;1 相当于不对该位进行任何操作，&amp;0 相当于得到0。那么， 整个操作相当于将 (a&gt;&gt;b) 除第一位保留外，其他位都置0，也就是获取了 a&gt;&gt;b 的第一位。 将某一位置为 1： 1int set1(int a,int b) {return a|(1&lt;&lt;b);} 同理，不在讲述。 将某一位置为 0： 1int set0(int a,int b) {return a&amp;~(1&lt;&lt;b);} 逗号表达式 用逗号分隔的几个表达式其实是一个表达式，该表达式的值是最后一个表达式的值。 比如x=1,y=2,z=3，执行x=++x,++y,++z，最终x的值等于4（编译了才知道这是个UB，不过意思到了就行）。 像 a=3,s.pop(); 这种语句能执行的原因就是 s.pop() 是有值的。但 a=3,return; 就不能执行，因为 return; 并没有值。","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91OI%E4%B8%AD%E7%9A%84C++%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80&%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/"},{"title":"【杂项】c++ map的使用","text":"题目描述： n（n&lt;=200000)个数(1.5*10^9范围内)，输出重复的数（最多10000个）出现的次数 代码： #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;cstdio&gt; using namespace std; map&lt;int,int&gt; a; int n,t; int main() { freopen(\"count.in\",\"r\",stdin); //打开输入文件 freopen(\"count.out\",\"w\",stdout); //打开输出文件 cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;t; a\\[t\\]++; \\} for\\(map\\&lt;int,int&gt;::iterator it=a.begin\\(\\);it\\!=a.end\\(\\);it++\\) cout\\&lt;\\&lt;it-&gt;first\\&lt;\\&lt;&quot; &quot;\\&lt;\\&lt;it-&gt;second\\&lt;\\&lt;&quot; &quot;\\&lt;\\&lt;endl; fclose\\(stdin\\);//关闭输入文件 fclose\\(stdout\\);//关闭输出文件 } 几个操作总结： 1.定义map&lt;数据类型，数据类型&gt; 变量名; 2.首元素：x.begin() 3.尾元素:x.end() 4.遍历: 先定义一个迭代器: map&lt;数据类型，数据类型&gt;::iterater it; 接着: it=a.begin();it!=a.end();it++ 这里it相当于指针. 4.输出元素: 定义的第一个:it-&gt;first 第二个:it-&gt;second","link":"/2019/10/23/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91c++%20map%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"【杂项】一个程序弄懂C++面向对象编程","text":"没有继承和友元函数的内容,而且太乱了,以后可能会修改,但对我来说够用了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//huaruoji on 2021/2/1#include &lt;bits/stdc++.h&gt;using namespace std;struct test{ //struct中的成员均为public成员 static int pi,e;//声明了pi和e,但此处只是声明,不能接着赋值 int a,b,c;//实例变量 test(int p,int q)//构造函数定义 { a=p,b=q; } test(char s)//构造函数定义 { c=s-'A'; } /* 下面这个函数的返回值为bool,重载的运算符为&lt;,运算符左边的数据类型为test,右边 的数据类型也为test 括号内const和&amp;的用途在于加速和不改变源值 第二个const放在非静态成员函数的尾部，表示该非静态成员函数不修改对象内容 */ bool operator &lt; (const test &amp;m) const { if(a&lt;m.a) return false; else return true; } bool operator &gt; (const test &amp;m) const { if(b&gt;m.b) return true; else return false; } int operator + (const test &amp;m) const { return a+b+m.a+m.b; } test operator - (const test &amp;m) const { test q(a-m.a,b-m.b); return q; } //声明成员函数 bool isab(void) const;//const可加可不加 int *address(void); //但这里const不能加,因为返回的是地址 //定义成员函数 bool compare(int com) { return (com&lt;a); } int compare2(test rec) { return (this-&gt;compare(5)&lt;rec.compare(1));//this指针的用法 }};//定义test中的成员函数 bool test::isab() const{ return (a==b);}int *test::address()//一个返回地址的函数 { return &amp;a; }int test::pi;//定义了piint test::e=2;//定义并初始化了e int main(){ test::pi=1;//初始化了pi test a=test(3,5);//main函数中的局部对象 test b(3,5); test c('A'); test d(4,6); cout&lt;&lt;a.a&lt;&lt;' '&lt;&lt;b.b&lt;&lt;' '&lt;&lt;c.c&lt;&lt;' '&lt;&lt;a.isab()&lt;&lt;endl; cout&lt;&lt;(a&lt;b)&lt;&lt;' '&lt;&lt;(a&gt;b)&lt;&lt;' '&lt;&lt;(a+b)&lt;&lt;' '&lt;&lt;(b-d+a)&lt;&lt;endl; int m=*b.address(); cout&lt;&lt;m&lt;&lt;endl; cout&lt;&lt;a.compare(1)&lt;&lt;endl; cout&lt;&lt;a.compare2(b); return 0;}","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%84%E6%87%82C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"title":"【杂项】用图示的方法理解充分条件和必要条件","text":"前言 乱搞的 必要条件 假设说有 4 个命题,分别为 \\(P_1,P_2,P_3,Q\\) ,相互只存在一个关系,即 \\(P_1\\and P_2 \\and P_3 \\rightarrow Q\\) ,且 4 个命题与其他命题都无关联.那么 \\(P_1,P_2,P_3\\) 都是 \\(Q\\) 的必要条件. 充分条件 沿用上面的 4 个命题,但把关系改成 \\(P_1\\or P_2 \\or P_3 \\rightarrow Q\\), 那么 \\(P_1,P_2,P_3\\) 都是 \\(Q\\) 的充分条件. 再难一点? 这次,关系变成了 \\((P1\\and P_2) \\or P_3 \\rightarrow Q\\). \\(P_3\\) 仍然是 \\(Q\\) 的充分条件,但 \\(P_1,P_2\\) 算什么? 如果把 \\(P_1\\and P_2\\) 看作一个新命题 \\(P\\) ,那么 \\(P_1,P_2\\) 是 \\(P\\) 的必要条件, \\(P\\) 是 \\(Q\\) 的充分条件. 总结 若 \\(P\\) 是 \\(Q\\) 的必要条件,那么 \\(\\lnot P\\rightarrow \\lnot Q\\), \\(Q\\rightarrow P\\). 若 \\(P\\) 是 \\(Q\\) 的充分条件,那么 \\(P\\rightarrow Q,\\lnot Q\\rightarrow \\lnot P\\).","link":"/2021/04/08/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E7%94%A8%E5%9B%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/"},{"title":"【杂项】重读C++ Primer Plus","text":"前言:重读C++ Primer Plus,温故而知新 重读C++ Primer Plus,温故而知新 第3章 处理数据 关于int的长度 short至少16位； int至少与short一样长； long至少32位，且至少与int一样长； long long至少64位，且至少与long一样长。 int可以为16,24,32,64位,在windows中与long一样长,为32位. 各种数据类型的长度 别再傻傻上网查了!在头文件climits中都有! sizeof sizeof用于变量根本不用加括号,例: 数据的初始化 12345int b(23);//int b=23; int physics[1000]{};//int physics[1000];physics[1,2,3...1000]=0;int math[1000];cout&lt;&lt;3000000000//this is ok.int a=2147483649//a will be -2147483647 上面几种初始化方式在c++98中都是可行的 十六进制(hex),八进制(octal) 表示方法:0x42,042 输出方法:cout&lt;&lt;hex&lt;&lt;42;cout&lt;&lt;oct&lt;&lt;42; char 12cout&lt;&lt;'a';//编译器将会把'a'当作字符常量,因此输出字符achout&lt;&lt;int('a');//输出a的ASCII值 double","link":"/2021/02/17/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E9%87%8D%E8%AF%BBC++%20Primer%20Plus/"},{"title":"【比赛】ABC 199 210424","text":"概述 题号 算法 得分 A 模拟 100 B 模拟 200(1) C 字符串，规律 300 D 图论计数 0(4) E 0 F 0 总分 难度 自评 Rank 600 \\ 5 2363 彻底失败了！ A Square Inequality 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a,b,c;int main() { cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;((a*a+b*b&lt;c*c)?(&quot;Yes&quot;):(&quot;No&quot;)); return 0;} B Intersection 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,a[1005],b[1005],f[1005],ans;int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++) { for(int j=a[i];j&lt;=b[i];j++) ++f[j]; } for(int i=1;i&lt;=1000;i++) if(f[i]==n) { ++ans; } cout&lt;&lt;ans; return 0;} C IPFL 设置一个标记，如果整块翻转一次就 xor 1。当交换单个字符时，判断标记状态。如果状态为 true 就将 x 和 y 设置为翻转后的位置，再交换。具体也不想多说了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,q;string s;bool mode;inline int get(const int &amp;x) { if(x&gt;n) return x-n; else return x+n;}int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; cin&gt;&gt;s&gt;&gt;q; int op,x,y; for(int i=1;i&lt;=q;i++) { cin&gt;&gt;op&gt;&gt;x&gt;&gt;y; if(op==1) { if(mode==true) swap(s[get(x)-1],s[get(y)-1]); else swap(s[x-1],s[y-1]); } else { mode^=1; } } if(mode==true) cout&lt;&lt;s.substr(n,n)&lt;&lt;s.substr(0,n); else cout&lt;&lt;s; return 0;} D RGB Coloring 2 DFS 计数，相连的点不能有同种颜色。整张图不一定连通。 但是我的写法是有问题的，，，从一个点出发 DFS 不一定能按照一定顺序不回溯地遍历完所有点。 正确的做法是先一次 DFS 记录遍历顺序（其实就是求连通块），然后再一次 DFS 设置颜色。 这里暴露出来一个问题：如果要给图中的所有节点“设置”一个值，仅一次 DFS 是不够的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Correction on 2021-04-25 08:32:37#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=25;int n,m;ll ans,curAns;vector&lt;int&gt; g[N];bool vis[N],curVis[N];int col[N];void getRoute(int u,vector&lt;int&gt; &amp;r) { curVis[u]=true; r.push_back(u); for(auto v:g[u]) { if(!curVis[v]) getRoute(v,r); }}void dfs(int u,vector&lt;int&gt; &amp;r,int cnt) { for(auto v:g[u]) { if(col[v]==col[u]) return; } if(cnt==(int)r.size()) { ++curAns; return; } int v=r[cnt]; for(int j=1;j&lt;=3;j++) { col[v]=j; dfs(v,r,cnt+1); col[v]=0; }}int main() { cin&gt;&gt;n&gt;&gt;m; int u,v; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;u&gt;&gt;v; g[u].push_back(v); g[v].push_back(u); } vector&lt;int&gt; route(N,0); for(int i=1;i&lt;=n;i++) { if(!vis[i]) { route.clear(); memset(curVis,0,sizeof curVis); getRoute(i,route); for(auto i:route) vis[i]=true; curAns=0; for(int j=1;j&lt;=3;j++) { memset(col,0,sizeof col); col[i]=j; dfs(i,route,1); } if(curAns!=0 &amp;&amp; ans==0) ans=1; ans*=curAns; } } cout&lt;&lt;ans; return 0;} 总结 下次应该避开蚊子。 今天写的时候完全心不在焉，不过我已经知道问题在哪了。","link":"/2021/04/24/%E3%80%90%E6%AF%94%E8%B5%9B%E3%80%91210424-ABC-199/"},{"title":"【比赛】Codeforces Round 706 (Div. 2)","text":"standings 祝贺!萌新的第一场cf!废话不多说我们还是来写下题解吧. A. Split it! Des 字符串. 给一个字符串,看能否按照题目中的要求分割成多个字符串. Sol 太简单就不说了,其实就是计算一个回文串的长度.但与严格的回文串又不太一样. My code 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int T,n,k;char s[105];int main(){ cin&gt;&gt;T; while(T--) { cin&gt;&gt;n&gt;&gt;k; scanf(&quot;%s&quot;,s+1); int mid=(n+1)&gt;&gt;1,p=0; for(int i=1;i&lt;mid;i++) { if(s[i]==s[n-i+1]) p++; else break; } if(p&gt;=k) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;} B. Max and Mex Des 数学,规律. 每次计算一个multiset里的\\(\\lceil \\frac {max+mex} 2 \\rceil\\),并丢入multiset,问最后multiset中不重复的元素个数. Sol 本题的各种数据规模都有点大,无论用何种方法模拟题意都会超时.但既然这只是第二题,肯定要寻找特殊的规律. \\(mex\\)是什么?除非遇到这种从小到大填满了的集合\\({0,1,2,3,4,5}\\).\\(mex=6\\).其他集合的\\(mex\\)都小于集合里的任何一个元素.加上上取整的特性,我们可以发现\\(\\lceil \\frac {max+mex} 2 \\rceil\\)永远比现在的\\(mex\\)大.也就是说无论执行多少次操作,\\(mex\\)都不会被更新,且\\(\\lceil \\frac {max+mex} 2\\rceil\\)的值是唯一的.答案统计一下不同的数的个数就行了.对于\"填满了\"的集合进行特判. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+10;int T,n,k,mex,maxx;int a[N],bj[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ T=read(); while(T--) { n=read(),k=read(); mex=0,maxx=0; memset(bj,0,sizeof(bj)); for(int i=1;i&lt;=n;i++) { a[i]=read(); maxx=max(maxx,a[i]); if(a[i]&lt;=1e5+5) bj[a[i]]=true; } for(int i=0;i&lt;=1e5+5;i++) { if(bj[i]==false) { mex=i; break; } } int cal=ceil((double(mex)+double(maxx))/2.0); int notin=true; for(int i=1;i&lt;=n;i++) { if(cal==a[i]) notin=false; } if(k==0) notin=false; if(cal&gt;maxx) notin=k; printf(&quot;%d\\n&quot;,n+notin); } return 0;} C. Diamond Miner Des 几何,数学. 在x轴上有许多矿工,在y轴上有许多钻石.每个矿工挖一个钻石,问最小的\\(\\sum dis(矿工,钻石)\\). Sol 我直接猜的贪心做法,A了... 本来是这样想的:\\(\\sqrt {25+25}=7,\\sqrt {25+1}=5\\).25本身比较大,再加一个比较大的值,对根号运算结果的影响较小. 那么我们直接将x轴和y轴上的数按绝对值排序,大的和大的搞在一起,小的和小的搞在一起就ok了. 实际上这就是正解! \\[ |AD|+|BC|&lt;|AO|+|DO|+|BO|+|CO|=|AB|+|CD| \\] 运用四边形不等式,可以证明任意两条路线不相交的选择方法就是最优的. My code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int T,n,a,b;int x[N],y[N],p1,p2;double ans;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ T=read(); while(T--) { n=read(); p1=p2=ans=0; for(int i=1;i&lt;=2*n;i++) { a=read(),b=read(); if(a==0) y[++p2]=abs(b); if(b==0) x[++p1]=abs(a); } sort(x+1,x+n+1); sort(y+1,y+n+1); for(int i=1;i&lt;=n;i++) { ans+=sqrt((double)x[i]*x[i]+(double)y[i]*y[i]); } printf(&quot;%.10f\\n&quot;,ans); } return 0;} D. Let's Go Hiking Des 游戏策略 Sol 看完这道题的官方解答才觉得自己思考的太不严谨了.下面我尝试把官方解答复述一遍. Qingshan不会选择\\(x=1\\)或\\(x=n\\).因为Daniel可以选择\\(y=2\\)或\\(y=n\\)使得Qingshan下一步不能移动.那么,青山只会选择满足\\(1&lt;x&lt;n\\)的\\(x\\).同理Qingshan不会选择满足\\(p_x&lt; p_{x+1}\\)或\\(p_x&lt;p_{x-1}\\).Qingshan只会选择x(\\(1&lt;x&lt;n\\)),并满足\\(p_x&gt;p_{x+1},p_x&gt;p_{x-1}\\). 如果Qingshan最开始不选择最长单调序列上的点,她显然会输.所以她一定只能选择最长单调序列上的点. 令\\(l\\)为最长单调序列的长度,\\(c\\)最长单调序列的个数.总有\\(l \\ge 2\\),\\(c\\ge 1\\). 当\\(c&gt;2\\),Qingshan会输.毕竟Qingshan比Daniel先走. 当\\(c=1\\),设最长单调序列为\\(p_s,p_{s+1},\\dots,p_{s+l-1}\\),Qingshan选择\\(p_{s+l-1}\\).情况分为: 如果\\(l\\ mod\\ 2=0\\),Daniel选择\\(p_s\\),Qingshan无论向左走还是向右走都会输.如果Qingshan向左走,Daniel向右走.设2人选择了足够多的回合,下一回合是Qingshan,且她选择\\(x=s+\\frac l 2\\).Daniel随后选择\\(x=s+\\frac l 2-1\\).Qingshan无路可走.如果Qingshan向右走,能走的次数没有Daniel多.综上,Qingshan会输. 如果\\(l\\ mod\\ 2=1\\),Daniel选择\\(p_{s+1}\\),Qingshan会输(过程与\\(l\\ mod\\ 2=0\\).的情况类似). 当\\(c=2\\).2个最长单调序列只能形似\\(p_{m-l+1}&lt;p_{m-l+2}&lt;\\dots &lt;p_m&gt;p_{m+1}&gt;\\dots &gt;p_{m+l-1}\\).否则Qingshan会输. Qingshan选择\\(p_m\\),Daniel只能选择\\(p_{m-l+1}\\)或\\(p_{m+l-1}\\).然后Qingshan只能朝着Daniel的方向走.这里不妨设Daniel选择了\\(p_{m-1+1}\\).如果\\(l\\ mod\\ 2=0\\),Qingshan会输.如果\\(l\\ mod\\ 2=1\\),Qingshan会赢. 检查最长单调序列的长度和形状可以在\\(O(n)\\)内做到. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,cntUp,cntDown,p,maxl,nowSt;int a[N],st[N],bj[N];int main(){ cin&gt;&gt;n&gt;&gt;a[1]; cntUp=cntDown=1; maxl=0; for(int i=2;i&lt;=n;i++) { cin&gt;&gt;a[i]; if(a[i]&gt;a[i-1]) { cntUp++; if(cntUp==maxl) { st[++p]=nowSt; } if(cntUp&gt;maxl) { maxl=cntUp; p=0; nowSt=i; st[++p]=nowSt; bj[p]=1; } cntDown=1; } else { cntDown++; if(cntDown==2) { nowSt=i-1; } if(cntDown==maxl) { st[++p]=nowSt; } if(cntDown&gt;maxl) { maxl=cntDown; p=0; st[++p]=nowSt; bj[p]=0; } cntUp=1; } } if(p==2 &amp;&amp; st[1]==st[2] &amp;&amp; maxl%2==1 &amp;&amp; bj[1]==1 &amp;&amp; bj[2]==0) { printf(&quot;1\\n&quot;); } else { printf(&quot;0\\n&quot;); } return 0;} Note 这道题讨论的分支很多,但最后得出的结论十分简单.一定要养成这种严谨的思维! E. Garden of the Sun Des There are many sunflowers in the Garden of the Sun. Garden of the Sun is a rectangular table with n rows and m columns, where the cells of the table are farmlands. All of the cells grow a sunflower on it. Unfortunately, one night, the lightning stroke some (possibly zero) cells, and sunflowers on those cells were burned into ashes. In other words, those cells struck by the lightning became empty. Magically, any two empty cells have no common points (neither edges nor corners). Now the owner wants to remove some (possibly zero) sunflowers to reach the following two goals: When you are on an empty cell, you can walk to any other empty cell. In other words, those empty cells are connected. There is exactly one simple path between any two empty cells. In other words, there is no cycle among the empty cells. You can walk from an empty cell to another if they share a common edge. Could you please give the owner a solution that meets all her requirements? Note that you are not allowed to plant sunflowers. You don't need to minimize the number of sunflowers you remove. It can be shown that the answer always exists. Sol 需要注意: Magically, any two empty cells have no common points (neither edges nor corners). 这导致一个很重要的特性:无论第\\(i\\)列和第\\(i+2\\)列长什么样,将\\(i+1\\)列全部挖空也不会出现环.与后面的解决方案密切相关.官方给出的方法是将2,5,8,11...列全部挖空.还没有连通的地方就单独补上,可以保证不会出现环.说实话,个人认为这种做法太有技巧性了,和国内比赛不太类似.那么今天的CF题解就到这了! 总结 读完整题,注意标粗的地方. 比赛的时候不知道修正在哪,下次不会傻傻的去洛谷问了. CF上\\(n\\le 1e5,t=100\\)可以使用\\(n\\log n\\)的方法. 把想法精确的用文字表示出来,不要出现遗漏细节的情况.","link":"/2021/03/12/%E3%80%90%E6%AF%94%E8%B5%9B%E3%80%91Codeforces-Round-706-(Div.-2)/"},{"title":"【比赛】洛谷 5 月月赛 &amp; MCOI Round 5 Div.2","text":"概述 题号 算法 得分 A 饱食 组合，数学 100 B 魔仙 数学，规律 5 C 追杀 5 D 粘液 0 总分 难度 自评 Rank 110 \\ 2.5 306 A 饱食 简单的组合计数。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n; string s;ll cnt[10];int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; if(s[0]=='M') ++cnt[1]; if(s[0]=='C') ++cnt[2]; if(s[0]=='O') ++cnt[3]; if(s[0]=='I') ++cnt[4]; } cout&lt;&lt;cnt[1]*cnt[2]*cnt[3]+cnt[1]*cnt[2]*cnt[4]+cnt[1]*cnt[3]*cnt[4]+cnt[2]*cnt[3]*cnt[4]; return 0;} B 魔仙 Des 魔仙女王的宝石被古娜拉黑暗之神偷走了！古娜拉黑暗之神藏在魔仙堡的 \\(n\\) 个穹顶中的任意一个里面，这 \\(n\\) 个穹顶编号为 \\(1 \\sim n\\)，第 \\(i\\) 个穹顶可以将其赋予 \\(a_i\\) 的魔力，\\(a_i\\) 必须是整数。 如果所有穹顶的魔力之和为 \\(0\\)，之积为 \\(n\\)，那么我们称这种情况是可以轻易搜索出古娜拉黑暗之神的。 魔仙女王让占星魔仙求一种赋予魔力的情况使得是可以轻易搜索出古娜拉黑暗之神的。 Sol 注意本题是“SPJ”，“一种方案即可”，而且题目的构造方式奇特，应该先找找规律看（然而考试的时候没有想到）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int T,n;int a[1005],p;bool ok;void dfs(int p,int mul) { if(n%mul!=0) return; if(abs(mul)&gt;n) return; if(ok) return; if(p==n) { int cnt=0,mul=1; for(int i=1;i&lt;=p;i++) { cnt+=a[i]; mul*=a[i]; } if(cnt==0 &amp;&amp; mul==n) { for(int i=1;i&lt;=p;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; ok=true; } return; } for(int i=max(-n,a[p]);i&lt;=n;i++) { if(i==0) continue; a[p+1]=i; dfs(p+1,mul*i); }}int main() { ios::sync_with_stdio(false); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;T; for(int i=1;i&lt;=T;i++) { n=i; cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;; ok=false; a[0]=-1e9; dfs(0,1); if(ok==false) cout&lt;&lt;&quot;w33zAKIOI\\n&quot;; } return 0;} 用上面这份可以通过前两个 subtask 的程序可以得到输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#1: w33zAKIOI#2: w33zAKIOI#3: w33zAKIOI#4: -2 -1 1 2 w33zAKIOI#5: w33zAKIOI#6: w33zAKIOI#7: w33zAKIOI#8: -4 -2 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 2 4 w33zAKIOI#9: w33zAKIOI#10: w33zAKIOI#11: w33zAKIOI#12: -6 -1 -1 -1 1 1 1 1 1 1 1 2 -3 -2 -2 -1 1 1 1 1 1 1 1 1 -3 -1 -1 -1 -1 -1 1 1 1 1 2 2 -2 -2 -1 -1 -1 -1 1 1 1 1 1 3 -2 -1 -1 -1 -1 -1 -1 -1 1 1 1 6 -1 -1 -1 -1 -1 -1 -1 -1 1 2 2 3 w33zAKIOI#13: w33zAKIOI#14: w33zAKIOI#15: w33zAKIOI#16: -8 -2 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 -4 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 4 -2 -2 -2 -2 -1 -1 1 1 1 1 1 1 1 1 1 1 -2 -2 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 2 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 2 8 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 2 2 2 2 w33zAKIOI#17: w33zAKIOI#18: w33zAKIOI#19: w33zAKIOI#20: -10 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 -5 -2 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 10 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 2 5 w33zAKIOI#21: w33zAKIOI#22: w33zAKIOI#23: w33zAKIOI#24: -12 -2 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 -6 -4 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 -4 -3 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 -4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 2 3 -3 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 4 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 3 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 2 12 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 4 6 w33zAKIOI#25: w33zAKIOI#26: w33zAKIOI#27: w33zAKIOI#28: -14 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 -7 -2 -2 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 -7 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 7 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 14 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 2 2 7 w33zAKIOI#29: w33zAKIOI#30: w33zAKIOI 可以发现，似乎若 n 能被 4 整除，那么就有方案。 如果设置在找到一个解后就返回，有输出： 123456789101112131415161718192021222324252627282930#1: w33zAKIOI#2: w33zAKIOI#3: w33zAKIOI#4: -2 -1 1 2 #5: w33zAKIOI#6: w33zAKIOI#7: w33zAKIOI#8: -4 -2 1 1 1 1 1 1 #9: w33zAKIOI#10: w33zAKIOI#11: w33zAKIOI#12: -6 -1 -1 -1 1 1 1 1 1 1 1 2 #13: w33zAKIOI#14: w33zAKIOI#15: w33zAKIOI#16: -8 -2 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 #17: w33zAKIOI#18: w33zAKIOI#19: w33zAKIOI#20: -10 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 #21: w33zAKIOI#22: w33zAKIOI#23: w33zAKIOI#24: -12 -2 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #25: w33zAKIOI#26: w33zAKIOI#27: w33zAKIOI#28: -14 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 #29: w33zAKIOI#30: w33zAKIOI 由于在代码中为了防止方案本质上重复（只是输出顺序不同的方案即为本质上重复），从上一个记录的数开始枚举，因此输出的序列必定是单调递增的（这里的单调递增与严格递增区分），所以每个有方案的数被程序输出的第一种方案一定形似。其实就是说我们可以从暴力程序的输出中归纳出规律了！ 设 \\(n=4k\\)。若 \\(k\\) 是奇数，有 \\(n=2\\times \\frac {n} {-2} \\times (-1)^{k}\\times 1^{3k-2}\\)；若 \\(k\\) 为偶数，有 \\(n=(-2)\\times \\frac {n} {-2} \\times 1^{3k}\\times (-1)^{k-2}\\)。 有程序： 到这里，这道题就已经做出来了。但是，为什么当 \\(n\\) 不是 4 的倍数时，就没有解（从分数上来看也是这样的）？这里请去看 大佬的题解。 简单来讲，就是： 奇数个奇数的和一定是奇数，所以奇数没有方案。 偶数个偶数的积一定被 4 整除，所以 2 的倍数没有方案。 这两句话已经足够解释了。 My code 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int T,n;int main() { ios::sync_with_stdio(false); cin&gt;&gt;T; for(int i=1;i&lt;=T;i++) { cin&gt;&gt;n; if(n%4!=0) cout&lt;&lt;&quot;w33zAKIOI\\n&quot;; else { int k=n/4; if(k%2==0) { cout&lt;&lt;-2&lt;&lt;' '&lt;&lt;n/-2&lt;&lt;' '; for(int i=1;i&lt;=3*k;i++) cout&lt;&lt;1&lt;&lt;' '; for(int i=1;i&lt;=k-2;i++) cout&lt;&lt;-1&lt;&lt;' '; } else { cout&lt;&lt;2&lt;&lt;' '&lt;&lt;n/-2&lt;&lt;' '; for(int i=1;i&lt;=k;i++) cout&lt;&lt;-1&lt;&lt;' '; for(int i=1;i&lt;=3*k-2;i++) cout&lt;&lt;1&lt;&lt;' '; } cout&lt;&lt;endl; } } return 0;} Note 一堆人吵着应该评红我是/tuu 了。 比赛的时候看掉了数的个数为 \\(n\\) 的条件，不知道如果注意到这个条件能不能写出来。 C 追杀 本题为耗时最长的一道。 最开始以为用一个巧妙一点的就可以做出，还因为空间限制重构了一次。结果发现根本上思路就是错的。 如果“救活”一个人，那么会造成许多连锁反应，不是模拟可以搞定的。 存一下垃圾代码吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//WA5#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=6e4+5,M=1e3+5;int n,m,alive; int life[M],killCnt[M],u[N],v[N],vis[M],ans[M];short saveCnt[M][N];int main() { ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; fill(life+1,life+m+1,3); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;u[i]&gt;&gt;v[i]; ++killCnt[v[i]]; --life[v[i]]; } int cnt[M]; for(int i=1;i&lt;=m;i++) { memset(cnt,0,sizeof cnt); for(int j=n;j&gt;=1;j--) { if(u[j]!=i) continue; ++cnt[v[j]]; if(killCnt[v[j]]&gt;=3 &amp;&amp; killCnt[v[j]]-cnt[v[j]]&lt;3 &amp;&amp; vis[v[j]]!=i) { ++saveCnt[i][j]; vis[v[j]]=i; } } } for(int i=1;i&lt;=m;i++) if(life[i]&gt;0) ++alive; for(int i=1;i&lt;=m;i++) { for(int j=n+1;j&gt;=1;j--) { saveCnt[i][j]+=saveCnt[i][j+1]; int tmp=alive+saveCnt[i][j]; if(life[i]==1) --tmp; ++ans[tmp]; } } for(int i=0;i&lt;=m;i++) { cout&lt;&lt;ans[i]&lt;&lt;' '; } return 0;} D 粘液 什么玩意？ 复诊去了。 总结 失败的洛谷月赛，恶臭的数学题。 比赛应该认真对待，在还有时间的时候，完全可以把B题的暴力写出来，从暴力找到规律并不是什么难事。","link":"/2021/05/03/%E3%80%90%E6%AF%94%E8%B5%9B%E3%80%91%E6%B4%9B%E8%B0%B7-5-%E6%9C%88%E6%9C%88%E8%B5%9B-&-MCOI-Round-5-Div.2/"},{"title":"【测试】210423 省选","text":"概述 题号 算法 得分 A DP 0 B 矩阵乘法，数学，递推 0 C 分块，FFT 20 总分 难度 自评 20 省选~NOI 1.25 A 序列 上来直接懵了，根本没有遇到过的题目描述方式。 \\[ [x]= \\begin{cases} 1,\\quad \\text {if x is true}\\\\ 0,\\quad \\text {if x is false} \\end{cases} \\] B 递推 2 个变量的递推式，仍然可以用矩乘。答案是一个等比数列，我tm居然想了好久这么算这个玩意。 如果能算等比数列+矩阵快速幂优化，可拿55分，否则30. 考试中推过式子，发现了一点规律，但无法形象化描述，其实就是正解的第一步，但离正解还差得远。 无穷项的等比数列涉及到高中数列知识，挂掉。 为什么拿了 0 分呢？因为文件读写写错 + 没考虑负数取模问题（(a%P+P)%P）。 C 序列 前 40 分其实很可做，但我没想到 10 分，又写挂了 10 分，凉凉。 暴力做法分为链和树，链上做法类似线性 DP，树上做法类似树形 DP。 有 10 分的暴力要考虑到完全二叉树的性质，不懂。 总结 都这么大的人了，文件读写还要错（其实归根结底是慌了）？ 负数取模 菜！","link":"/2021/04/23/%E3%80%90%E6%B5%8B%E8%AF%95%E3%80%91210423-(%E7%9C%81%E9%80%89)/"},{"title":"【测试】210428 提高","text":"概述 题号 算法 得分 A 数字 数位 DP 13 B 跳蚤 线段树，树状数组 47 C 棋盘 多项式，DP 5 总分 难度 自评 65 提高~省选 5 A 数字 二进制数位 DP，关键是限定了上界和下界，并不会！ 有 25 分的 subtask 很可做（T 二进制下最多 15 个 1），但搜超时了。优化了一下，理论上时间缩短了 15 倍，然后过了。可怜的 25 分就这样没了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5,M=1e5+5;int P=998244353;int n,m,k;namespace s1 { int sta[400],vis[20][20]; int hx[5]={0,-1,0,1,0},hy[5]={0,0,1,0,-1}; int ans; void dfs(int x,int y) { vis[x][y]=true; for(int i=1;i&lt;=4;i++) { int fx=x+hx[i],fy=y+hy[i]; if(!vis[fx][fy] &amp;&amp; sta[(fx-1)*m+fy] &amp;&amp; fx&gt;=1 &amp;&amp; fx&lt;=n &amp;&amp; fy&gt;=1 &amp;&amp; fy&lt;=m) dfs(fx,fy); } } int count() { int ret=0; memset(vis,0,sizeof vis); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(sta[(i-1)*m+j] &amp;&amp; !vis[i][j]) { dfs(i,j); ++ret; } } } return ret; } void getSta(int x) { if(x==n*m) { if(count()==k) { ++ans; ans%=P; } return; } sta[x+1]=true; getSta(x+1); sta[x+1]=false; getSta(x+1); } void solve() { getSta(0); cout&lt;&lt;ans; }}namespace s2 { void solve() { ll ans=0; for(int i=1;i&lt;=m;i++) { ans+=(ll)i; ans%=(ll)P; } cout&lt;&lt;ans; }}int main() { freopen(&quot;chess.in&quot;,&quot;r&quot;,stdin); freopen(&quot;chess.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(n*m&lt;=15) s1::solve(); else if(n==1) s2::solve();// s1::solve(); return 0;} B 跳蚤 对跳蚤步长分类讨论，分成树状数组和线段树做。 47 分能拿的都拿了，很满意。本来就是最简单的一道 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5;int q,op[N],x[N],y[N];bool sub2=true,sub3=true;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace s1 { int a[N][2],p; void solve() { for(int i=1;i&lt;=q;i++) { if(op[i]==1) a[++p][0]=x[i],a[p][1]=y[i]; else if(op[i]==2) { for(int j=1;j&lt;=p;j++) { if(a[j][0]==-1) continue; a[j][0]+=a[j][1]; if(a[j][0]&gt;100000) a[j][0]=-1; } } else { int ans=0; for(int j=1;j&lt;=p;j++) { if(a[j][0]==-1) continue; if(a[j][0]&gt;=x[i] &amp;&amp; a[j][0]&lt;=y[i]) ++ans; } printf(&quot;%d\\n&quot;,ans); } } }}namespace s2 { struct line { int x,t; int nxt,pre; }a[N]; int p,head,tail; void solve() { for(int i=1;i&lt;=q;i++) { if(op[i]==1) { if(x[i]&gt;100) continue; if(head==0 || tail==0) { head=tail=1; a[head].x=x[i],a[head].t=y[i]; a[head].nxt=a[head].pre=0; p=1; } else { a[tail].nxt=++p; a[p].pre=tail,a[p].nxt=0; a[p].x=x[i],a[p].t=y[i]; tail=p; } } else if(op[i]==2) { for(int j=head;j;j=a[j].nxt) { a[j].x+=a[j].t; if(a[j].x&gt;100) { if(j==head) { head=a[j].nxt; } else if(j==tail) { tail=a[j].pre; } else { a[a[j].pre].nxt=a[j].nxt; a[a[j].nxt].pre=a[j].pre; } } } } else { int ans=0; for(int j=head;j;j=a[j].nxt) { if(a[j].x&gt;=x[i] &amp;&amp; a[j].x&lt;=y[i]) ++ans; } printf(&quot;%d\\n&quot;,ans); } } }}namespace s3 { int c[N*3]; int lowbit(int x) {return x&amp;(-x);} void update(int x,int k) {while(x&lt;=300000){c[x]+=k;x+=lowbit(x);}}; int query(int x) {int sum=0;while(x){sum+=c[x];x-=lowbit(x);}return sum;} int d; void solve() { for(int i=1;i&lt;=q;i++) { if(op[i]!=2) { x[i]+=100000,y[i]+=100000; } } for(int i=1;i&lt;=q;i++) { if(op[i]==1) { update(x[i]-d,1); } else if(op[i]==2) { ++d; } else { printf(&quot;%d\\n&quot;,query(y[i]-d)-query(x[i]-d-1)); } } }}int main() { freopen(&quot;flea.in&quot;,&quot;r&quot;,stdin); freopen(&quot;flea.out&quot;,&quot;w&quot;,stdout); q=read(); for(int i=1;i&lt;=q;i++) { op[i]=read(); if(op[i]!=2) { x[i]=read(),y[i]=read(); if(op[i]==3 &amp;&amp; y[i]&gt;100) sub2=false; if(op[i]==1 &amp;&amp; y[i]!=1) { sub3=false; } } } if(sub2) s2::solve(); else if(sub3) s3::solve(); else s1::solve(); return 0;} C 棋盘 完全不懂的多项式 + DP。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;typedef unsigned long long ll;using namespace std;ll T,l1,r1,l2,r2;namespace s1 { ll a[2000],ans; void solve() { for(ll i=l1;i&lt;=r1;i++) { for(ll j=l2;j&lt;=r2;j++) { if((i|j)==T) { if(!a[i&amp;j]) ++ans; a[i&amp;j]=true; } } } cout&lt;&lt;ans&lt;&lt;endl; }}namespace s3 { int tot,ans; bool vis[1&lt;&lt;16]; int getBit(ll x,ll k) { return (x&gt;&gt;k)&amp;1; } int getCnt(ll x) { for(int i=63;i&gt;=0;i--) { if(getBit(x,i)==1) return i; } return -1; } void dfs(int x,ll a,ll b,ll c) { if(x==tot) { if(a&gt;=l1 &amp;&amp; a&lt;=r1 &amp;&amp; b&gt;=l2 &amp;&amp; b&lt;=r2) { if(!vis[c]) ++ans; vis[c]=true; } return; } if(getBit(T,x+1)==1) { ll tmp=(ll)(1)&lt;&lt;(x+1); dfs(x+1,a|tmp,b|tmp,c&lt;&lt;1|1); dfs(x+1,a|tmp,b,c&lt;&lt;1); dfs(x+1,a,b|tmp,c&lt;&lt;1); } else dfs(x+1,a,b,c); } void solve() { tot=getCnt(T); dfs(-1,0,0,0); cout&lt;&lt;ans&lt;&lt;endl; }}int main() { freopen(&quot;number.in&quot;,&quot;r&quot;,stdin); freopen(&quot;number.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;T&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2; if(l1&lt;1024 &amp;&amp; r1&lt;1024) s1::solve(); else s3::solve(); return 0;}","link":"/2021/04/28/%E3%80%90%E6%B5%8B%E8%AF%95%E3%80%91210428-%E6%8F%90%E9%AB%98/"},{"title":"【测试】210510","text":"概述 题号 算法 得分 A 子集选取 DP 30 B 送礼物 分数规划 0 C 字符串树 可持久化 trie，LCA 100 总分 难度 自评 130 提高~省选 5 其实是 JSOI 2015 的题当作模拟测试。 A 子集选取 Des 给定 \\(n\\) 个元素的集合 \\(S= \\left\\{ \\ 1,2...n \\right\\}\\) 和整数\\(k\\)，现在要从\\(S\\) 中选出若干子集 \\(A_{i,j}\\)（\\(A \\subseteq S\\)，\\(1 \\le j \\le i \\le k\\)）排成下面所示边长为 \\(k\\) 的三角形（因此总共选出了 \\(\\frac{1}{2} k(k+1)\\) 个子集）。 \\[ \\begin{align} &amp;A_{1,1}\\\\ &amp;A_{2,1}\\quad A_{2,2}\\\\ &amp;A_{3,1}\\quad A_{3,2}\\quad A_{3,3}\\\\ &amp;\\vdots\\qquad\\ \\ \\ \\vdots\\qquad\\; \\vdots\\quad \\; \\; \\; \\; \\; \\ddots\\\\ &amp;A_{k,1}\\quad A_{k,2}\\quad A_{k,3}\\quad \\cdots\\quad A_{k,k} \\end{align} \\] 此外，JYY 对选出的子集之间还有额外的要求：选出的这些子集必须满足 \\(A_{i,j} \\subseteq A_{i,j-1}\\) 且 \\(A_{i,j} \\subseteq A_{i-1,j}\\)。 JYY 想知道，求有多少种不同的选取这些子集的方法。因为答案很大，JYY 只关心输出答案模 \\(1,000,000,007\\) 的值。 对于两种选取方案 \\(A = \\left\\{ \\ A_{1,1} , A_{2,1} , A_{k,k} \\right\\}\\) 和 \\(B = \\left\\{ \\ B_{1,1} , B_{2,1} , B_{k,k} \\right\\}\\) 只要存在 \\(i,j\\) 满足 \\(A_{i,j} \\neq B_{i,j}\\)，我们就认为 \\(A\\) 和 \\(B\\) 是不同的方案。 Sol 直接爆搜打表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int P = 1e9 + 7;int n, k, S;ll ans;int sta[15][15];int getbit(int x, int k) { return (x &gt;&gt; k) &amp; 1;}bool subset(int a, int b) { for(int i = 0; i &lt; n; i++) { if(getbit(a, i) &gt; getbit(b, i)) return false; } return true;}void check() { bool ok = true; for(int i = 1; i &lt;= k; i++) { for(int j = 1; j &lt;= i; j++) { if(j - 1 != 0 &amp;&amp; !subset(sta[i][j - 1], sta[i][j])) { ok = false; break; } if(j != i &amp;&amp; !subset(sta[i - 1][j], sta[i][j])) { ok = false; break; } } } if(ok) { ++ans; ans %= P; }}void search(int x, int y) { if(y - 1 != 0 &amp;&amp; !subset(sta[x][y - 1], sta[x][y])) return; if(y != x &amp;&amp; !subset(sta[x - 1][y], sta[x][y])) return; if(x == k &amp;&amp; y == k) { check(); return; } int hx, hy; if(y == x) hx = x + 1, hy = 1; else hx = x, hy = y + 1; for(int i = 0; i &lt; S; i++) { sta[hx][hy] = i; search(hx, hy); }}int main() { cin &gt;&gt; n &gt;&gt; k; S = 1 &lt;&lt; n; search(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 可以发现规律就是 \\(ans = 2^{nk}\\)。但是，赛时写错了判断子集的函数。应该是循环到 \\(n\\) 而不是 \\(k\\)。 找到的规律就变得复杂起来，还要分 \\(n\\le k\\) 和 \\(n &gt;k\\) 讨论。 正解： 由于集合中的元素互不影响，所以可以先考虑一个元素的做法，然后运用乘法原理算出总答案。 接着就是神仙做法： 从左下角的点走 n 步，每步可以向上或向右，方案数为 \\(2^n\\)。 FSY 的神仙解释： 容我说详细一点： 设 \\(f(k)\\) 表示边长为 \\(k\\) 时选一个元素的答案，\\(f(0)=1\\)，那么 \\[ f(k)=\\sum_{i=1}^k f(k-i)+1=2^k \\] 因为每增加一行，该行一定有若干个 1 作为前缀，其余位全为 0. 若没有 1，则对上方的转移矩阵没有限制，方案数为 \\(f(k-1)\\). 若前缀为 1 个 1，那么该列必然全为 1，方案数为 \\(f(k-2)\\). 若前缀为 2 个 1，那么前两列必然全为 1，方案数为 \\(f(k-3)\\). ... 若前缀为 k-2 个 1，方案数为 \\(f(1)\\). 若前缀为 k-1 个1，方案数为 \\(f(0)=1\\). 若前缀为 k 个 1，只有一种方案. My code 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const ll P = 1e9 + 7;ll n, k, ans;ll fpm(ll a, ll b, ll p) { ll ans = 1; for(; b; b &gt;&gt;= 1, a = (a * a) % p) if(b &amp; 1) ans = (ans * a) % p; return ans % p;}int main() { cin &gt;&gt; n &gt;&gt; k; ll t = n * k; ans = fpm(2, t, P); cout &lt;&lt; ans &lt;&lt; endl; return 0;} B 送礼物 Des 假设礼品店一共有 \\(N\\) 件礼物排成一列，每件礼物都有它的美观度。排在第 \\(i\\ (1\\leq i\\leq N)\\) 个位置的礼物美观度为正整数 \\(A_i\\)。JYY 决定选出其中连续的一段，即编号为 \\(i,i+1,\\cdots,j-1,j\\) 的礼物。选出这些礼物的美观程度定义为 \\[\\frac{M(i,j)-m(i,j)}{j-i+K}\\] 其中 \\(M(i,j)\\) 表示 \\(\\max\\{A_i,A_{i+1},\\cdots,A_j\\}\\)，\\(m(i,j)\\) 表示 \\(\\min\\{A_i,A_{i+1},\\cdots,A_j\\}\\)，\\(K\\) 为给定的正整数。 由于不能显得太小气，所以 JYY 所选礼物的件数最少为 \\(L\\) 件；同时，选得太多也不好拿，因此礼物最多选 \\(R\\) 件。JYY 应该如何选择，才能得到最大的美观程度？由于礼物实在太多挑花眼，JYY 打算把这个问题交给会编程的你。 Note 分数规划，没学。 场上一直磕 C 题，就没有仔细看，而且拿着完全没感觉。 C 字符串树 Des 字符串树本质上还是一棵树，即 \\(N\\) 个节点 \\(N-1\\) 条边的连通无向无环图，节点从 \\(1\\) 到 \\(N\\) 编号。与普通的树不同的是，树上的每条边都对应了一个字符串。萌萌和 JYY 在树下玩的时候，萌萌决定考一考 JYY。每次萌萌都写出一个字符串 \\(S\\) 和两个节点 \\(U,V\\)，JYY 需要立即回答 \\(U\\) 和 \\(V\\) 之间的最短路径（即 \\(U,V\\) 之间边数最少的路径，由于给定的是一棵树，这样的路径是唯一的）上有多少个字符串以 \\(S\\) 为前缀。 JYY 虽然精通编程，但对字符串处理却不在行。所以他请你帮他解决萌萌的难题。 Sol 之前 txx 做过的题，所以知道是用可持久化 trie。 然后 yy 了一会可持久化 trie 是什么样子，发现好像挺简单的！有了可持久化线段树和动态开点的基础后，写这个玩意完全不是事儿！ 然后就搞了 2 个多小时，居然 AC 力！ 做法： 给每一个节点建立一个字典树，存储从根节点下来的字符串（）。字符串上每一位都要使字典树的 cnt 值加一。对于询问 (u,v)，答案为 get(u) + get(v) - 2 * get(lca(u,v))。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 1e5 + 5;int n, Q;int edgeCnt = 0, head[N];struct edges { int nxt, v; string s;} edge[N];void addEdge(int u, int v, string s) { edge[++edgeCnt].nxt = head[u], head[u] = edgeCnt; edge[edgeCnt].v = v, edge[edgeCnt].s = s;}namespace trie { int nodeCnt, rt[N]; struct node { int cnt; int ch[26]; }c[N * 11]; void make(const string &amp;s, int now, int fa) { int len = s.size(); c[++nodeCnt] = c[rt[fa]]; rt[now] = nodeCnt; now = nodeCnt; for(int i = 0; i &lt; len; i++) { int v = s[i] - 'a'; if(!c[now].ch[v]) c[now].ch[v] = ++nodeCnt; else { c[++nodeCnt] = c[c[now].ch[v]]; c[now].ch[v] = nodeCnt; } ++c[nodeCnt].cnt; now = nodeCnt; } }}namespace LCA { int lg[1 &lt;&lt; 17], f[N][17], dep[N]; void prework() { for(int i = 1; i &lt;= 17; i++) lg[1 &lt;&lt; i] = 1; for(int i = 1; i &lt;= N; i++) lg[i] += lg[i - 1]; } void build(int u, int fa) { dep[u] = dep[fa] + 1, f[u][0] = fa; for(int i = 1; i &lt;= lg[dep[u]]; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = head[u]; i; i = edge[i].nxt) if(edge[i].v != fa) build(edge[i].v, u); } int get(int x, int y) { if(dep[x] &gt; dep[y]) swap(x, y); while(dep[y] &gt; dep[x]) y = f[y][lg[dep[y] - dep[x]]]; if(x == y) return x; for(int i = lg[dep[x]]; i &gt;= 0; i--) if(f[x][i] != f[y][i]) x= f[x][i], y= f[y][i]; return f[x][0]; }}void build(int u, int fa, const string &amp;s) { trie::make(s, u, fa); for(int i = head[u]; i; i = edge[i].nxt) { if(edge[i].v != fa) build(edge[i].v, u, edge[i].s); }}int query(int u, int v, const string &amp;s) { int len = s.size(), anc = LCA::get(u, v); u = trie::rt[u], v = trie::rt[v], anc = trie::rt[anc]; for(int i = 0; i &lt; len; i++) { int to = s[i] - 'a'; u = trie::c[u].ch[to], v = trie::c[v].ch[to], anc = trie::c[anc].ch[to]; } return trie::c[u].cnt + trie::c[v].cnt - 2 * trie::c[anc].cnt;}int main() { ios::sync_with_stdio(false); cin.tie(0); int u, v; string s; cin &gt;&gt; n; for(int i = 1; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; s; addEdge(u, v, s); } build(1, 0, &quot;&quot;); LCA::prework(); LCA::build(1, 0); cin &gt;&gt; Q; for(int i = 1; i &lt;= Q; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; s; cout &lt;&lt; query(u, v, s) &lt;&lt; endl; } return 0;} Note 拿 vector 存图，出现了十分鬼畜的错误。 在调试到 100 行输入字符串 s 的时候，会莫名其妙的出现 cpu error，然后跳转到 algo_vector.h 去，不懂什么意思。换成邻接表就没问题。 反正以后尽量别拿 vector 存图了。","link":"/2021/05/10/%E3%80%90%E6%B5%8B%E8%AF%95%E3%80%91210510/"},{"title":"【测试】210517（校内，提高，树状数组，二分答案）","text":"概述 题号 算法 得分 A 炸怪物 二分答案 100 B 序列平均值 平衡树，数学，树状数组 100 C 盒子（AGC 043F） 费用流，对偶原理 0 总分 难度 自评 200 不好评价 10 A 炸怪物 设共进行了 \\(n\\) 次爆炸，把第 \\(i\\) 个怪物当作 \\(k_i\\) 次爆炸中心，则需要满足： \\[ nb+k_1(a-b)\\ge h_1\\\\ nb+k_2(a-b)\\ge h_2\\\\ \\dots\\\\ nb+k_n(a-b)\\ge h_n \\] 且 \\(k_1+k_2+\\dots+k_n=n\\)。 那么二分答案 \\(n\\) ，按照上取整的方式计算 \\(k_1+k_2+\\dots+k_n\\) 是否小于等于 \\(n\\) 即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 5;int n, a, b, maxh, h[N];bool check(int k) { int cnt = 0; for(int i = 1; i &lt;= n; i++) { int tmp = h[i] - b * k; if(tmp &gt; 0) { cnt += ceil(double(tmp) / double(a - b)); } } return cnt &lt;= k ? true : false;}signed main() { freopen(&quot;bomb.in&quot;, &quot;r&quot;, stdin); freopen(&quot;bomb.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a, &amp;b); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;h[i]); maxh = max(maxh, h[i]); } int l = 1, r = ceil(double(maxh) / double(b)), mid, ans; while(l &lt;= r) { mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } printf(&quot;%lld\\n&quot;, ans); return 0;} B 序列平均值 Des 给定序列 \\(A={A_1,A_2,\\dots,A_n}\\)，求 \\(\\dfrac{A_l+A_{l+1}+\\dots+A_{r}}{r-l+1}\\ge k\\) 的区间 \\([l,r]\\) 的数量。 Sol #1 树状数组 维护前缀和数组 \\(s_i=A_1+A_2+\\dots+A_i\\)，原式转换为 \\(s_r-s_{l-1}\\ge kr-kl+k\\)。对于每个 \\(i\\) 有固定的特征值 \\(s_{l-1}-kl\\)，设 \\(q_i=s_{i-1}-ki\\)，只需查询满足 \\(q_i+k\\le q_j(i&lt;j)\\) 的不等式数量即可。 离散化 \\(q_i+k\\) 的值即可用树状数组查询，复杂度 \\(O(n\\log n)\\)。 Sol #2 平衡树 枚举区间右端点 \\(r\\)，在平衡树内维护 \\(s_r-s_{l-1}-k\\cdot (r-l+1)\\) 的值，设 \\(s_r-s_{l-1}-k\\cdot (r-l+1)=f_l\\)，若 \\(\\forall f_l\\ge 0\\)，则执行 \\(ans\\gets ans+1\\)。右端点移动时，执行 \\(f_i\\gets f_i+A_r-k(1\\le i&lt;r)\\)，并在平衡树内插入 \\(A_r-k\\) 表示 \\(f_r\\)。 区间查询操作与加和操作均只需要 \\(O(\\log n)\\) 的时间，总复杂度 \\(O(n\\log n)\\)。 My code（#2） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 5;int n, k;ll ans;namespace tr { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], rnd[N], cnt, rt; ll tag[N], val[N], sz[N]; void newNode(int &amp;k, int x) { val[++cnt] = x, rnd[cnt] = rand(), sz[cnt] = 1; lc(cnt) = rc(cnt) = 0; k = cnt; } inline void update(int p) { sz[p] = sz[lc(p)] + sz[rc(p)] + 1; } void push(int p) { if(tag[p]) { val[lc(p)] += tag[p], val[rc(p)] += tag[p]; tag[lc(p)] += tag[p], tag[rc(p)] += tag[p]; tag[p] = 0; } } void split(int p, ll k, int &amp;x, int &amp;y) { if(!p) { x = y = 0; return; } push(p); if(val[p] &lt;= k) { x = p; split(rc(x), k, rc(x), y); update(x); } else { y = p; split(lc(y), k, x, lc(y)); update(y); } } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { push(x); rc(x) = merge(rc(x), y); update(x); return x; } else { push(y); lc(y) = merge(x, lc(y)); update(y); return y; } } void ins(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); newNode(z, v); rt = merge(merge(x, z), y); } void out(int u) { if(!u) return; push(u); out(lc(u)); cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; val[u] &lt;&lt;' ' &lt;&lt; sz[u] &lt;&lt; '\\n'; out(rc(u)); }} using namespace tr;int main() { srand(time(0)); freopen(&quot;average.in&quot;, &quot;r&quot;, stdin); freopen(&quot;average.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1, t; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;t); if(i == 1) { ins(rt, t - k); if(t - k &gt;= 0) ++ans; } else { tag[rt] += t - k; val[rt] += t - k; ins(rt, t - k);// out(rt); int a = 0, b = 0; split(rt, -1, a, b); ans += sz[b]; rt = merge(a, b); } } printf(&quot;%lld\\n&quot;, ans); return 0;} Note 树状数组更好写也更简单，没想到的主要原因是没有写出“子序列的算术平均值大于或等于 K“的数学式子，从最简单的定义思考不一定会更复杂。 实际上我的平衡树解法也依赖于那个式子的变形（\\(A_l+A_{l+1}+\\dots+A_{r}-k\\cdot (r-l+1)\\ge 0\\)），反正就是绕了一圈。 C 盒子 AGC043 F题，还没有翻译，Mr. Z 什么意思我不用多说了吧。/kk 居然是 zxy 写过的题 Orz，【Atcoder Grand Contest 043】【AGC043】F - Jewelry Box（对偶原理）（费用流）_zxyoi_dreamer的博客-CSDN博客。","link":"/2021/05/17/%E3%80%90%E6%B5%8B%E8%AF%95%E3%80%91210517%EF%BC%88%E6%A0%A1%E5%86%85%EF%BC%8C%E6%8F%90%E9%AB%98%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89/"},{"title":"【笔记】Splay","text":"前言 个人学习笔记。 大部分内容来自 Splay - OI Wiki (oi-wiki.org)。 参考： OI 中转站 - 模板 (yhx-12243.github.io) Splay 简介 一种平衡树。 结构 节点维护信息 rt tot fa[i] ch[i][0/1] val[i] cnt[i] sz[i] 根节点编号 节点个数 父亲 左右儿子编号 节点权值 权值出现次数 子树大小 操作 基本操作 maintain(x)：在改变节点位置后，将节点 \\(x\\) 的 \\(\\text{size}\\) 更新。 get(x)：判断节点 \\(x\\) 是父亲节点的左儿子还是右儿子。 clear(x)：销毁节点 \\(x\\)。 123inline void maintain(int x) {sz[x]=sz[lc(x)]+sz[rc(x)]+cnt[x];}inline bool get(int x) {return x==rc(fa[x]);} //left child -&gt; 0; right child -&gt; 1;inline void clear(int x) {lc(x)=rc(x)=sz[x]=fa[x]=val[x]=cnt[x]=0;} 旋转操作 旋转操作可以将节点上移一个位置，旋转后的树仍然是 BST。 这是普通的单旋操作（zig &amp; zag）： 具体分析旋转步骤（假设需要旋转的节点为 \\(x\\)，其父亲为 \\(y\\)，以右旋为例） 将 \\(y\\) 的左儿子指向 \\(x\\) 的右儿子，且 \\(x\\) 的右儿子（如果 \\(x\\) 有右儿子的话）的父亲指向 \\(y\\)；ch[y][0]=ch[x][1]; fa[ch[x][1]]=y; 将 \\(x\\) 的右儿子指向 \\(y\\)，且 \\(y\\) 的父亲指向 \\(x\\)；ch[x][chk^1]=y; fa[y]=x; 如果原来的 \\(y\\) 还有父亲 \\(z\\)，那么把 \\(z\\) 的某个儿子（原来 \\(y\\) 所在的儿子位置）指向 \\(x\\)，且 \\(x\\) 的父亲指向 \\(z\\)。fa[x]=z; if(z) ch[z][y==ch[z][1]]=x; 左旋代码： 1234567void zig(int x) { int y=fa[x],z=fa[y]; lc(y)=rc(x); if(rc(x)) fa[rc(x)]=y; rc(x)=y; fa[y]=x; fa[x]=z; if(z) ch[z][y==ch[z][1]]=x; maintain(y); maintain(x);} 右旋代码： 1234567void zag(int x) { int y=fa[x],z=fa[y]; rc(y)=lc(x); if(lc(x)) fa[lc(x)]=y; lc(x)=y; fa[y]=x; fa[x]=z; if(z) ch[z][y==ch[z][1]]=x; maintain(y); maintain(x);} 利用异或，可以将 2 个操作合并为一个 rotate 函数： 1234567void rotate(int x) { int y=fa[x],z=fa[y],chk=get(x); ch[y][chk]=ch[x][chk^1]; if(ch[x][chk^1]) fa[ch[x][chk^1]]=y; ch[x][chk^1]=y; fa[y]=x; fa[x]=z; if(z) ch[z][y==ch[z][1]]=x; maintain(y); maintain(x);} 虽然这个 rotate 看起来不容易写，但完全可以先写出一个 zig 或 zag，再进行替换。 splay 操作 splay 操作 splay(x,S)：将 x 通过旋转操作换为树 S 的根。 如果 splay 操作总是使用单旋的话，复杂度可能达到 \\(O(n)\\)。于是，Tarjan 在 1985 年提出了“双旋”的操作解决这个问题，将 splay 操作的均摊复杂度降至 \\(O(\\log n)\\)。 设 x 为当前节点，y 为 x 的父亲，z 为 y 的父亲（如果有），那么双旋可以分为 6 种情况： 第 1,2 种： 若 y 无父亲，与普通的单旋一样，执行 rotate(x)。 第 3,4 种： 若 get(x)==get(y)，则先执行 rotate(y)，再执行 rotate(X)。 第 5,6 种： 若 get(x)!=get(y)，则执行 2 次 rotate(x)。 手玩一下就会很清晰！ 这张图可以直观的感受一下双旋的优越性（如果只用单旋就仍然是一条链）： 代码： 12345void splay(int x, int g = 0) { for(; fa[x] != g; rotate(x)) if(fa[fa[x]] != g) rotate(get(x) == get(fa[x]) ? fa[x] : x) if(g == 0) rt = x;} 插入操作 插入操作步骤如下（假设插入的值为 \\(k\\)）： 如果树空了，则直接插入根并退出。 如果当前节点的权值等于 \\(k\\) 则增加当前节点的大小并更新节点和父亲的信息，将当前节点进行 Splay 操作。 否则按照二叉查找树的性质向下找，找到空节点就插入即可（请不要忘记 Splay 操作）。 1234567891011121314151617void insert(int k) { for(int u = rt, f = 0; ; f = u, u = ch[u][val[u] &lt; k]) { if(val[u] == k ) { ++cnt[u]; maintain(u); maintain(f); splay(u); break; } else if(!u) { ed = 0; val[++tot] = k; ++cnt[tot]; fa[tot] = f; if(f) ch[f][val[f] &lt; k] = tot; maintain(tot); maintain(f); splay(tot); break; } }} 我已经写得很简洁了为什么还是这么长 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n;int sz[N], ch[N][2], cnt[N], val[N], fa[N], rt, tot;#define lc(x) ch[x][0]#define rc(x) ch[x][1]inline void maintain(int x) {sz[x] = sz[lc(x)] + sz[rc(x)] + cnt[x];}inline bool get(int x) {return x == rc(fa[x]);} //left child -&gt; 0; right child -&gt; 1;inline void clear(int x) {lc(x) = rc(x) = sz[x] = fa[x] = val[x] = cnt[x] = 0;}void rotate(int x) { int y = fa[x], z = fa[y], chk = get(x); ch[y][chk] = ch[x][chk^1]; if(ch[x][chk^1]) fa[ch[x][chk^1]] = y; ch[x][chk^1] = y; fa[y] = x; fa[x] = z; if(z) ch[z][y == ch[z][1]] = x; maintain(x); maintain(y); }void splay(int x, int g = 0) { for(; fa[x] != g; rotate(x)) if(fa[fa[x]] != g) rotate(get(x) == get(fa[x]) ? fa[x] : x); if(g == 0) rt = x;}void insert(int k) { for(int u = rt, f = 0; ; f = u, u = ch[u][val[u] &lt; k]) { if(val[u] == k ) { ++cnt[u]; maintain(u); maintain(f); splay(u); break; } else if(!u) { val[++tot] = k; ++cnt[tot]; fa[tot] = f; if(f) ch[f][val[f] &lt; k] = tot; maintain(tot); maintain(f); splay(tot); break; } }} int rk(int k) { for(int res = 0, u = rt; ; ) { if(k &lt; val [u]) u = lc(u); else { res += sz[lc(u)]; if(k == val[u]) { splay(u); return res + 1; } res += cnt[u]; u = rc(u); } }}int kth(int k) { for(int u = rt; ; ) { if(lc(u) &amp;&amp; k &lt;= sz[lc(u)]) u = lc(u); else { k -= cnt[u] + sz[lc(u)]; if(k &lt;= 0) { splay(u); return val[u]; } u=rc(u); } }}int pre() { int u = lc(rt); while(rc(u)) u=rc(u); splay(u); return u;}int nxt() { int u=rc(rt); while(lc(u)) u=lc(u); splay(u); return u;}void del(int x) { rk(x); int u = rt; if(cnt[rt] &gt; 1) --cnt[rt], maintain(rt); else if(!lc(rt) &amp;&amp; !rc(rt)) clear(rt), rt=0; else if(!lc(rt) || !rc(rt)) { rt = lc(rt) ? lc(rt) : rc(rt), fa[rt] = 0; clear(u); } else { int t = pre(); fa[rc(u)] = t; rc(t) = rc(u); clear(u); maintain(rt); }}int main() { scanf(&quot;%d&quot;,&amp;n); int op, x; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op == 1) insert(x); else if(op == 2) del(x); else if(op == 3) printf(&quot;%d\\n&quot;,rk(x)); else if(op == 4) printf(&quot;%d\\n&quot;,kth(x)); else if(op == 5) { insert(x); printf(&quot;%d\\n&quot;,val[pre()]); del(x); } else { insert(x); printf(&quot;%d\\n&quot;,val[nxt()]); del(x); } } return 0;} 一些小问题 为什么删除操作不需要 splay ? 因为删除操作会先进行 rank 操作，已经将要删除的点 splay 了。 例题 P3391 【模板】文艺平衡树 如果要翻转一个区间 \\([l,r]\\), 就先执行 splay(l-1,0), 然后执行 splay(r+1,l-1)。这会导致什么呢？ 区间 \\([1,l-1]\\) 全部在根节点及其左子树，区间 \\([r+1,n]\\) 全部在根节点的右儿子及其右子树。这样，\\([l,r]\\) 就位于根节点的右儿子的左子树，只需要给 lc(rc(rt)) 打上标记即可。 由于 l-1 可能等于 0，因此先插入 INF，-INF 或将值域整体移动。 这里选择了第二种方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5; // n ~ mint n, m;inline int read() { int s = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') {if(c == '-') s = 0; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') {x = x &lt;&lt; 3 + x &lt;&lt; 1 + c ^48; c = getchar();} return s ? x : -x;}namespace Splay { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int rt, tot; int ch[N][2], sz[N], fa[N], val[N], tag[N]; inline int get(int x) {return x == rc(fa[x]);} inline void maintain(int x) {sz[x] = sz[lc(x)] + sz[rc(x)] + 1;} void rotate(int x) { int y = fa[x], z = fa[y], chk = get(x); ch[y][chk] = ch[x][chk^1]; if(ch[x][chk^1]) fa[ch[x][chk^1]] = y; ch[x][chk^1] = y, fa[y]= x; fa[x] = z; if(z) ch[z][y == ch[z][1]] = x; maintain(y); maintain(x); } void splay(int x, int g = 0) { for( ; fa[x] != g; rotate(x)) if(fa[fa[x]] != g) rotate(get(x) == get(fa[x]) ? fa[x] : x); if(g == 0) rt = x; } void insert(int k) { for(int u = rt, f = 0; ; f = u, u = ch[u][val[u] &lt; k]) { if(!u) { val[++tot] = k; sz[tot] = 1; fa[tot] = f; maintain(tot); if(f) ch[f][val[f] &lt; k] = tot, maintain(f); splay(tot); break; } } } void pushDown(int x) { if(x &amp;&amp; tag[x]) { tag[lc(x)] ^= 1; tag[rc(x)] ^= 1; swap(lc(x), rc(x)); tag[x] = 0; } } int kth(int k) { for(int u = rt; ; ) { pushDown(u); if(lc(u) &amp;&amp; k &lt;= sz[lc(u)]) u = lc(u); else { k -= sz[lc(u)] + 1; if(k &lt;= 0) return u; u=rc(u); } } } void reverse(int l, int r) { int x = kth(l), y = kth(r + 2); splay(x, 0); splay(y, x); tag[lc(rc(rt))] ^= 1; } void output(int u) { pushDown(u); if(lc(u)) output(lc(u)); if(val[u] != 1 &amp;&amp; val[u] != n+2) printf(&quot;%d &quot;, val[u]-1); if(rc(u)) output(rc(u)); }}int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n + 2; i++) { Splay::insert(i); } int l, r; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;,&amp;l,&amp;r); Splay::reverse(l, r); } Splay::output(Splay::rt); return 0;}","link":"/2021/05/03/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Splay/"},{"title":"【笔记】upper_bound和lower_bound","text":"前言: upper_bound和lower_bound是C++ STL提供的二分查找函数 upper_bound和lower_bound要求被查找的区域已经从小到大排好序. upper_bound用于查找区域内第一个大于目标值的元素的位置,lower_bound用于查找区域内第一个大于等于目标值的元素的位置. upper_bound和lower_bound均有2种用法.(来自C语言中文网) 123456//在 [first, last) 区域内查找不小于 val 的元素ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val);//在 [first, last) 区域内查找第一个不符合 comp 规则的元素ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val, Compare comp); C++友情提供了函数greater(),可用于按从大到小排序的序列.例: 1lower_bound(a+1,a+n+1,x,greater&lt;int&gt;()); 注意2个函数返回的是指针,如果要求数组内元素下标可以这样用: 1lower_bound(a+1,a+n+1,x)-a; 例题:P2782 友好城市","link":"/2021/02/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91upper_bound%E5%92%8Clower_bound/"},{"title":"【笔记】《什么是数学》笔记","text":"《什么是数学》笔记 第一章 自然数 算数的规律 乘法的规律，交换律，结合律！古代的专家掌握的知识已经被现在的小学生搞透了呢！ 整数的表示 非十进制数的乘法与加法的计算： 先列出加法表与乘法表 7进制加法表与乘法表 运用加法表与乘法表进行计算 乘法实例 数学归纳法 数学归纳法 如果给定一系列命题As，As＋1，As＋2，…，这里s是某个正整数，且如果 a）对每个r≥s的值，Ar为真时能推出Ar＋1也为真； b）As已知是真的， 则所有命题As，As＋1，As＋2，…是真的．就是说，对所有的n≥s，An成立． 最小自然数原理（与反证法） 内容：自然数的任意非空子集必然有最小的元素． 可证明数学归纳法，但这里的数学归纳法不是上面那个推广版的，而是这个： 考虑任意一系列命题A1，A2，A3，…，使得 a）对任一正整数r，Ar为真时能推出Ar＋1也为真； b）已知A1为真． 根据这些条件可以得出结论：命题 A1，A2，A3，...，都是正确的． 使用反证法：假设数学归纳法的命题成立，但假设存在一个或多个正整数，组成集合 \\(S\\)，任意 \\(n\\in S\\) 都使得命题 \\(A_n\\) 不成立（假设结论不成立）．根据最小自然数原理，必定存在最小数 \\(r\\) 使得命题 \\(A_r\\) 不成立．而且根据 b），\\(r&gt;1\\)．那么 \\(A_{r-1}\\) 一定是成立的，这违背了 a）（推出了与条件矛盾的结果）．这就证明了数学归纳法的结论是正确的． 等差级数与等比级数 级数与数列的区别：级数由函数组成，数列由数字组成． 等差级数求和公式：\\(\\cfrac {n(n+1)} 2\\)． 证明： 数学归纳法．即按照前面数学归纳法的方式证明． 初等数学课本证明： \\[ Gn=1+2+\\dots+(n-1)+n\\\\ Gn=n+(n-1)+\\dots+2+1\\\\ \\] 在同一列的每对数的和是 \\(n+1\\)，共有 \\(2n\\)列．每列对应相加，再求和即可得到答案． 等比级数求和公式： 设 \\(Gn=a+aq+aq^2+\\dots+aq^{n-1}\\)，则 \\(Gn=\\cfrac {q^n-1} {q-1}\\cdot a\\)． 证明： 数学归纳法 初等数学课本证明： \\[ Gn=a+aq+aq^2+\\dots+aq^{n-1}\\\\ qG_n=aq+aq^2+\\dots+aq^n\\\\ qG_n-G_n=aq^n-a\\\\ G_n=\\frac {aq^n-a} {q-1} \\] 前 n 项平方和： \\[\\cfrac {n(n+1)(2n+1)} 6\\]． 前 n 项立方和： \\(\\left[\\cfrac {n(n+1)} 2\\right]^2\\)． 一个重要的不等式 对于任意的 \\(p&gt;-1,n\\in N^*\\)，有 \\((1+p)^n\\ge 1+np\\)． 对于任意的 \\(p&gt;-1且p\\neq0,n\\ge2且n\\in Z\\)，有 \\((1+p)^n&gt;1+np\\)． 杨辉三角与二项式定理 杨辉三角： 杨辉三角 从第 0 行开始，记第 n 行第 i 个数为 \\(\\large C_n^i\\)，则 \\(\\large C_n^i=\\cfrac {n!}{i!(n-i)!}\\)． 若设 \\(\\large C_0^0=C_1^0=C_1^1=1\\)，则有\\(\\large C_n^i=C_{n-1}^{i-1}+C_{n-1}^i\\)． 且 \\((a+b)^n=\\large a^{C_n^0}b^{C_n^n}+a^{C_n^1}b^{C_n^{n-1}}+\\dots+a^{C_n^n}b^{C_n^0}\\)（二项式定理）． 习题 1 其他的习题都没啥意思，这两个比较有意思： 习题 让你必须用平方和和立方和公式证明． 两个证明方式基本一样，就只证第 8 个． 设 \\(G_a=1^2+2^2+\\dots+(2n+1)^2\\)，\\(G_b=2^2+4^2+\\dots+(2n)^2=4(1^2+2^2+\\dots+n^2)\\)，则原式等于 \\(G_a-G_b=\\frac {2n+1(2n+2)(4n+3)} 6-4\\cdot\\frac {n(n+1)(2n+1)}{6}=\\frac {(n+1)(2n+1)(2n+3)} 3\\)． 2 关于下面的错误证明： 我们将“证明”任意两个正整数相等，例如5＝10． 首先给出一个定义：如果a和b是两个不等的正整数，我们定义max（a，b）是a，b中较大的一个．如果a＝b，我们令max（a，b）＝a＝b．例如max（3，5）＝max（5，3）＝5，而max（4，4）＝4．现在让An是这样的命题：“如果a，b是使max（a，b）＝n的任意两个正整数，则a＝b．” a）假设Ar成立；设a，b是任意两个使得max（a，b）＝r＋1的正整数．考虑两个整数 α＝a－1， β＝b－1， 则max（α，β）＝r，又由于我们假设Ar成立，因此α＝β，由此知a＝b．因此Ar＋1成立． b）A1显然成立．因为如果max（a，b）＝1，则由于a，b假设是正整数，所以都必须等于1．因此按数学归纳法，An对任意的n成立． 现在如果a和b是两个不管什么样的正整数，用r表示max（a，b），由于已证明了对任意的n，An是成立的，特别Ar是成立的，因此a＝b． 它说“考虑两个整数 α=a-1，β=b-1”，其实是不一定能找到的，因为满足 A1成立的 a 和 b 只有 a=1,b=1．但由于 a 和 b 的定义范围在 A2 也是正整数.可以考虑 a=1,b=1, 此时显然不能找到 \\(\\alpha =0,\\beta =0\\). 可以发现,在运用数学归纳法的证明过程中, A1,A2,A3,...,An 对于变量的定义域可能不同. Ar 的证明所依赖的变量的取值范围不能超过该变量在 Ar-1 上的定义域.","link":"/2021/04/02/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/"},{"title":"【笔记】二叉堆与可并堆","text":"前言 优先队列是一种抽象数据类型(Abstract Data Type), 抽象数据类型通过它可以执行的操作以及操作带来的效果进行定义. 也就是说, 同一种抽象数据类型可能有不同的具体实现方式. 比如, 优先队列可以通过数组、二叉排序树或二叉堆实现. 我们使用二叉堆仅仅是因为它的操作的时间复杂度低, 而不是因为只有二叉堆能实现优先队列. 二叉堆 定义 需要支持以下操作: 输出所有数据的最大值. 删除最大的数据 插入一个数据 这个抽象数据类型叫做优先队列, 即从队列里出来的数是优先级高的. 如果用链表或数组实现, 那么插入的复杂度为 \\(O(1)\\) ,输出和删除的复杂度为 \\(O(n)\\). 我们将数据间的关系用大小决定, 自然而然的, 有了树状结构的二叉堆, 如果要求一棵树的父节点大于子节点, 那么它的根一定是所有数中最大的. 要插入一个数, 也只需要自底向下地将其插入到一个合适的位置. 其实二叉堆就是用完全二叉树实现的堆. 二叉堆是一颗优先级树, 即树上父节点的优先级大于儿子的优先级. 在这里, 优先级由值的大小决定. 根据优先级树的定义, 有以下性质: 从上至下访问优先级树, 路径上经过的优先级是非递减的, 优先级树的任何一颗子树也是优先级树. 实现 存储: 使用完全二叉树存储, 并且树上每个父节点的值大于子节点. 插入操作: 将插入的数放至完全二叉树的末尾 反复执行操作: 如果插入的数大于父亲, 就将其和父亲交换 删除(或输出)操作: 输出最大的数 将完全二叉树末尾的节点删除, 并将根的值置为末尾的节点的值. 反复执行: 如果树中有父亲小于儿子, 则将父亲和较小的儿子交换. 可并堆 定义 可并堆也是一种抽象数据类型, 它支持优先队列的所有操作, 还支持合并操作, 即将 2 个优先队列合并为一个. 严格来说, 普通的二叉堆也可以实现合并操作. 即将 1 个二叉堆中的元素挨个加入到另一个二叉堆. 但复杂度显然为 \\(O(n\\log n)\\). 如果要合并多次, 则复杂度为 \\(O(n^2 \\log n)\\). 实现 左偏树 定义 定义二叉树上节点的右斜距离为它一直向右走到叶子节点所经过的节点数量. 那么, 叶子节点的右斜距离为 1. 一下简称右斜距离为\"距离\". 定义左偏树是一颗优先级树, 它的叶子节点的优先级为节点的值. 并且, 左偏树的任意节点需要满足左偏性质: 左子结点的距离不小于右子节点的距离. 外节点是没有右儿子的节点. 我们知道, 定义很难被推导, 它是被发明左偏树的先贤写出来的. 我们目前很难知道它为什么要这样定义. 但在推导出左偏树的性质, 以及运用它解题后, 我们可以领略到这样做的智慧. 根据左偏树的定义, 它有以下性质: 一颗左偏树的任何一个子树仍然是左偏树 如果一个节点有右儿子, 那么它一定有左儿子. 任何一个节点的值必定不大于(或不小于)子节点的值. 外节点的距离为 0(也可以定义为 1). 一个非外节点的距离等于右儿子的距离加 1. 根节点距离为 \\(k\\) ,且节点数量最少的左偏树是一颗深度为 \\(k\\) 的满二叉树. 证明 使用数学归纳法. 根节点距离为0, 数量最少的左偏树显然是深度为1的满二叉树(即只有根节点). 设根节点距离为 \\(n\\) ,且节点数量最少的左偏树是一颗深度为 \\(n\\) 的满二叉树这个命题成立. 那么想要构造一颗根节点距离为 \\(n+1\\) 的左偏树, 必然要给深度为 \\(n\\) 的满二叉树的最后一个节点添加一个右儿子. 添加右儿子的前提是添加一个左儿子. 而父节点深度加 1 的前提是它的兄弟的深度加 1. 要让它的兄弟的深度加 1,必然需要对兄弟执行添加左儿子和右儿子的操作. 这样, 父节点的父节点的深度也加了 1,又需要父节点的父节点的兄弟深度加 1.依此类推, 第 \\(n+1\\) 层将会全部挂满节点. 这虽然不是太严谨的证明, 但比网上的许多\"显然有\"\"一定有\"合理的多. 节点数为 \\(n\\) 的左偏树, 根节点的距离最大为 \\(\\log (n+1) -1\\). 证明 设根节点的距离为 k ,由性质 6 得 \\[ n\\ge2^{k+1}-1, \\] 即 \\(\\log (n+1)-1\\ge k\\). 证毕 由于 k 是整数,所以有 \\(\\lfloor\\log (n+1)\\rfloor-1\\ge k\\). 实现 node: 节点信息. 需要储存该节点的距离、左儿子、右儿子、父亲和值. 其中,当值为 0 时,代表该节点不存在(null). 当值为 -1 时,代表该节点被删除. 若值为 0 ,则距离为 -1. 若值为 -1 ,根本不能访问. merge: 合并 2 个堆, 并返回新的堆顶的值. del: 删除某个堆顶. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//P3377 左偏树/可并堆#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;namespace hp { #define ls c[x].l #define rs c[x].r struct node { int l,r,f,val,d; }c[N]; int find(int x) { if(c[x].f!=x) c[x].f=find(c[x].f); return c[x].f; } int merge(int x,int y) { if(!x||!y) return x+y; if(c[x].val&gt;c[y].val || (c[x].val==c[y].val &amp;&amp; x&gt;y)) swap(x,y); rs=merge(rs,y); if(c[ls].d&lt;c[rs].d) swap(ls,rs); c[ls].f=c[rs].f=x,c[x].d=c[rs].d+1; return x; } void del(int x) { c[x].val=-1,c[ls].f=ls,c[rs].f=rs; c[x].f=merge(ls,rs); }}int main() { #define c hp::c c[0].d=-1; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;c[i].val); c[i].f=i; } int op,x,y; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1) { scanf(&quot;%d&quot;,&amp;y); if(c[x].val==-1 || c[y].val==-1) continue; x=hp::find(x),y=hp::find(y); if(x!=y) hp::merge(x,y); } else { if(c[x].val==-1) printf(&quot;-1\\n&quot;); else { int f=hp::find(x); printf(&quot;%d\\n&quot;,c[f].val); hp::del(f); } } } return 0;} 时间复杂度 前面证的性质 7 是求得左偏树时间复杂度的关键.把执行一次合并函数(指不递归)的时间复杂度记为 \\(O(1)\\), 由于距离最大为 \\(\\log (n+1)-1\\) ,所以最多递归 \\(\\log (n)\\) 次. 那么, 合并和删除的时间复杂度都是 \\(O(\\log n)\\). 斜堆 只需要将左偏树中和距离有关的语句全部删掉,就成了斜堆. 斜堆合并的均摊复杂度应该是 \\(O(\\log n)\\). 但是最坏复杂度??? 实测斜堆可以过洛谷模版,后面我将以身试法把所有能用左偏树过的题改成斜堆看看它会不会被卡. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;namespace hp { #define ls c[x].l #define rs c[x].r struct node { int l,r,f,val; }c[N]; int find(int x) { if(c[x].f!=x) c[x].f=find(c[x].f); return c[x].f; } int merge(int x,int y) { if(!x||!y) return x+y; if(c[x].val&gt;c[y].val || (c[x].val==c[y].val &amp;&amp; x&gt;y)) swap(x,y); rs=merge(rs,y); swap(ls,rs); c[ls].f=c[rs].f=x; return x; } void del(int x) { c[x].val=-1,c[ls].f=ls,c[rs].f=rs; c[x].f=merge(ls,rs); }}int main() { #define c hp::c c[0].d=-1; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;c[i].val); c[i].f=i; } int op,x,y; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1) { scanf(&quot;%d&quot;,&amp;y); if(c[x].val==-1 || c[y].val==-1) continue; x=hp::find(x),y=hp::find(y); if(x!=y) hp::merge(x,y); } else { if(c[x].val==-1) printf(&quot;-1\\n&quot;); else { int f=hp::find(x); printf(&quot;%d\\n&quot;,c[f].val); hp::del(f); } } } return 0;} STL 堆+启发式合并 把小的堆合到大的堆上去. 这样每个节点被执行一次合并时, 所在堆的大小至少翻了倍. 所以每个节点最多被合并 \\(\\log n\\) 次,然后合并的复杂度是 \\(\\log n\\). 总复杂度是 \\(O(n\\log ^2 n)\\). 由于代码比较难写,而且复杂度高,就不写了. 随机堆 在斜堆的基础上, 每次通过 rand()%2 决定是否交换左右儿子. 但这样写会被洛谷的数据卡掉.","link":"/2021/04/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E5%8F%89%E5%A0%86%E4%B8%8E%E5%8F%AF%E5%B9%B6%E5%A0%86/"},{"title":"【笔记】分数规划","text":"分数规划 给出 \\(a_i\\) 与 \\(b_i\\)，求一组 \\(w_i\\in \\{0,1\\}\\)，使得 \\[ \\cfrac {\\sum_{i=1}^na_iw_i} {\\sum_{i=1}^{n}b_iw_i}\\tag1 \\] 最大或最小。 若枚举 \\(w_i\\) 的组成，需要 \\(O(2^n)\\) 的时间，显然接受不了。不过我们是可以在 \\(O(n)\\) 的时间内检验这个式子是否大于或小于某个值的。设式 1 大于 \\(m\\)，有 \\[ \\sum_{i=1}^n a_iw_i&gt;m\\sum_{i=1}^n b_iw_i,\\\\ \\] \\[ \\sum_{i=1}^n w_i(a_i-mb_i)&gt;0.\\tag2 \\] 对于式 2，若 \\(a_i-mb_i&gt;0\\)，则选择 \\(w_i\\) 为 1，反之为 \\(0\\)。就求得了式 2 的最大值。在式 2 最大时，若其值大于 0，说明式 1 是大于 \\(m\\) 的。 有检验是否可行的办法，自然可以二分最值求解 0/1 分数规划问题 （即 \\(w_i\\in\\{0,1\\}\\) 的分数规划问题）。 这里求得的 \\(m\\) 在数学意义上是小于式 1 的，并不是等于。我们只能通过加大精度的方法来减小误差，或者是用一个 bool 标记是否能取到 0 来得到理论上真正”等于“的答案。但是，浮点数运算本身就有误差，与其担心毒瘤出题人来卡这个，不如就用不那么精确但好写的做法。 例题 POJ2976 Dropping tests 有 \\(n\\) 个物品，可以选择 \\(n-k\\) 个，使得 \\(\\cfrac {\\sum a_i}{\\sum b_i}\\) 最大。 将 \\(a_i-m\\times b_i\\) 排序然后选择最大的 \\(n-k\\) 个即可，时间复杂度 \\(O(n\\log n\\times \\log(10^{18}))\\)。 按照题目描述，本题的答案最大值可能达到 \\(10^{12}\\) 次方，虽然上界设为 \\(10^9\\) 可以过，但还是小心为妙。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;const int N = 1005;const double eps = 1e-6;int n, k, a[N], b[N];double c[N]; bool check(double m) { double s = 0; for(int i = 1; i &lt;= n; i++) c[i] = a[i] - m * b[i]; sort(c + 1, c + n + 1); for(int i = n; i &gt; k; i--) s += c[i]; return s &gt; 0;}int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif while(cin &gt;&gt; n &gt;&gt; k &amp;&amp; n) { for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; double L = 0, R = 1e12; while(R - L &gt; eps) { double mid = (L + R) / 2; if(check(mid)) L = mid; else R = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; L * 100 &lt;&lt; '\\n'; } return 0;} P4377 [USACO18OPEN]Talent Show G 有 \\(n\\) 个物品，每个物品有两个权值 \\(a\\) 和 \\(b\\)。 你需要确定一组 \\(w_i\\in\\{0,1\\}\\)，使得 \\(\\displaystyle\\frac{\\sum w_i\\times a_i}{\\sum w_i\\times b_i}\\) 最大。 要求 \\(\\displaystyle\\sum w_i\\times b_i \\geq W\\)。 我们的目的在于确定一组 \\(w_i\\)，使得 \\(\\sum w_i\\times (a_i-m\\times b_i)\\) 最大，这类似于 0/1 背包，但是没有容量的限制。加入容量限制，即 \\(\\sum w_i\\times b_i\\ge W\\) 后，可以用 0/1 背包求解。 将背包的容量视作 \\(+\\infin\\)，那么背包容量属于 \\([W,+\\infin)\\) 时最大的价值即为式 2 的最大值。题目中容量最大值为 \\(250\\times 10^6=2.5\\times 10^8\\)，太大。 这里可以用到一个技巧，建立 \\([W,+\\infin)\\) 到 \\(W\\) 的映射，使得 \\(val(W)\\) 表示 \\(\\max(val([W,+\\infin)))\\)。 具体实现看代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 255, W = 1005;const double eps = 1e-6;int n, w, a[N], b[N];double f[W];bool check(double m) { f[0] = 0; fill(f + 1, f + w + 1, -1e9); for(int i = 1; i &lt;= n; i++) { for(int j = w; j &gt;= 0; j--) { int k = min(w, j + b[i]); f[k] = max(f[k], f[j] + a[i] - m * b[i]); } } return f[w] &gt; 0;}int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; n &gt;&gt; w; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i] &gt;&gt; a[i]; double L = 0, R = 1e9; while(R - L &gt; eps) { double mid = (L + R) / 2; if(check(mid)) L = mid; else R = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; floor(1000 * L) &lt;&lt; '\\n'; return 0;} P3199 [HNOI2009]最小圈 Des 每条边的边权为 \\(w\\)，求一个环 \\(C\\) 使得 \\(\\displaystyle\\frac{\\sum_{e\\in C}w}{|C|}\\) 最小。 Sol 求最小值，等价于找到使得任意 \\(\\displaystyle\\frac{\\sum_{e\\in C}w}{|C|}\\ge m\\) 成立的最大的 \\(m\\)，也就是 \\(\\displaystyle \\sum_{e\\in C}w-m|C|\\ge 0\\)。 将图中每条边的边权设置为 \\(w-\\cfrac m{|C|}\\cdot |C|=w-m\\)，若图中存在负环，则说明有 \\(\\displaystyle \\sum_{e\\in C}w-m|C|&lt; 0\\) 成立，反之没有。也就是说，我们只需要找到使得图中不存在负环的最大的 \\(m\\) 即可。 我本来使用的是这种判负环的方法： 123456789101112131415161718192021222324bool SPFA(int s, double m) { vis[s] = 1, dis[s] = 0; queue&lt;int&gt; q; q.push(s); while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; double w = g.w[i] - m; if(dis[u] + w &lt; dis[v]) { dis[v] = dis[u] + w; if(!vis[v]) { len[v] = len[u] + 1; if(len[v] &gt; n) return true; vis[v] = true; q.push(v); } } } } return false;} 但是运行效率极低，只有 2 个点过了，其余 TLE。 这里介绍一种 DFS 判负环的方法。首先将所有的 dis[i] 置为 0，vis[i] 置为 0，然后执行这段程序： 12345678910111213bool SPFA(int u, double m) { vis[u] = 1; for(int i = g.head[u]; i; i = g.nxt[i]) { int v = g.v[i]; double w = g.w[i] - m; if(dis[u] + w &lt; dis[v]) { dis[v] = dis[u] + w; if(vis[v] || SPFA(v, m)) return true; } } vis[u] = 0; return false;} 只有当到一个点 \\(x\\) 的距离小于 0 时，\\(dis(x)\\) 才会被更新。由于是 DFS，若一个点被更新了 2 次及以上，就必然有负环。这样的复杂度大概是 \\(O(n+m)\\)。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3005, M = 10005;const double eps = 1e-9;struct edges { int cnt, nxt[M], head[N], v[M]; double w[M]; void add(const int &amp;a, const int &amp;b, const double &amp;c) { nxt[++cnt] = head[a], head[a] = cnt; v[cnt] = b, w[cnt] = c; }} g;int n, m, vis[N], len[N];double dis[N];bool circle(int u, double m) { // 判负环 vis[u] = 1; for (int i = g.head[u]; i; i = g.nxt[i]) { int v = g.v[i]; double w = g.w[i] - m; if (dis[u] + w &lt; dis[v]) { dis[v] = dis[u] + w; if (vis[v] || circle(v, m)) return true; } } vis[u] = 0; return false;}bool check(double m) { // 没有负环返回 true for(int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = 0; for(int i = 1; i &lt;= n; i++) if(circle(i, m)) return false; return true;}int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; n &gt;&gt; m; int u, v; double w; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g.add(u, v, w); } double L = -1e8, R = 1e8; while(R - L &gt; eps) { double mid = (L + R) / 2; if(check(mid)) L = mid; else R = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; L &lt;&lt; '\\n'; return 0;} P4322 [JSOI2016]最佳团体 Des JSOI 信息学代表队一共有 \\(N\\) 名候选人，这些候选人从 \\(1\\) 到 \\(N\\) 编号。方便起见，JYY 的编号是 \\(0\\) 号。每个候选人都由一位编号比他小的候选人\\(R_i\\) 推荐。如果 \\(R_i = 0\\)，则说明这个候选人是 JYY 自己看上的。 为了保证团队的和谐，JYY 需要保证，如果招募了候选人 \\(i\\)，那么候选人 \\(R_i\\) 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 \\(P_i\\) ，也有一个招募费用 \\(S_i\\) 。JYY 希望招募 \\(K\\) 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 \\(K\\) 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。 Sol 树上背包，\\(f(u,k)\\) 表示以 \\(u\\) 为根选 \\(k\\) 个的最大值。转移方程是 \\[ \\begin{align} f(u,0)&amp;=0,\\\\ f(u,k)&amp;=\\max(f(u,k),f(u,k-q)+f(v,q))(q\\neq k). \\end{align} \\] 我居然忘记树上背包是 \\(O(n^2)\\) 的了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2505, M = 5005;const double eps = 1e-4;struct edges { int cnt, nxt[M], head[N], v[M]; void add(const int &amp;a, const int &amp;b) { nxt[++cnt] = head[a], head[a] = cnt; v[cnt] = b; }} g;int k, n, a[N], b[N], sz[N];double s[N][N];void dp(int u, double m) { s[u][0] = 0, s[u][1] = a[u] - b[u] * m, sz[u] = 1; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; dp(v, m); sz[u] += sz[v]; for(int j = min(sz[u], k + 1); j &gt;= 2; j--) { for(int q = min(sz[v], j - 1); q &gt;= 1; q--) { s[u][j] = max(s[u][j], s[u][j - q] + s[v][q]); } } }}bool check(double m) { for(int i = 1; i &lt;= n + 1; i++) for(int j = 0; j &lt;= k + 1; j++) s[i][j] = -1e9; dp(n + 1, m); return s[n + 1][k + 1] &gt; 0;}int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; k &gt;&gt; n; for(int i = 1, fa; i &lt;= n; i++) { cin &gt;&gt; b[i] &gt;&gt; a[i] &gt;&gt; fa; if(fa == 0) fa = n + 1; // 将 JYY 转移到 n + 1 这个点 g.add(fa, i); } double L = 0, R = 1e4; while(R - L &gt; eps) { double mid = (L + R) / 2.0; if(check(mid)) L = mid; else R = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; L; return 0;} Note 树上背包如果不限制容量上界复杂度的确是 \\(O(n^3)\\) 的，这样做过后才是 \\(O(n^2)\\)： 12int j = min(sz[u], k + 1)int q = min(sz[v], j - 1) 也就是说，每个子树会和已经合并好的兄弟子树相乘，每对节点在 LCA 处做贡献。 另外，如果把 \\(R\\) 设置为 \\(2.5\\times 10^7\\) 居然要开 O2 才能过，明显这才是正确的二分上界啊！","link":"/2021/05/20/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"title":"【笔记】各种数学定理及其证明","text":"主要记录各种在题目里遇到的，或关于算法的数学式子及其证明。不排除以后会因为内容过多分裂为几个文件的情况。 关于平方 若 \\(a_1+a_2+\\dots+a_n=m\\) , 那么 \\(a_1^2+a_2^2+\\dots+a_n^2\\le m^2\\).（\\(m,a_1,a_2,\\dots\\) 是非负数，当且仅当 \\(m,a_1,a_2,\\dots&gt;0\\) 时等号成立）来源 证明 设 \\((a_1+a_2+\\dots+a_n)^2=a_1^2+a_2^2+\\dots+a_n^2+x\\)，必有 \\(x\\ge 0\\). 证毕 若有数列 \\(a_1,a_2,\\dots,a_n\\) 和 \\(b_1,b_2,\\dots,b_n\\) 那么在两数列有序时 \\(\\sum(a_i-b_i)^2\\) 最小. 来源 证明 若任意 \\(a_i\\) 不与 \\(b_i\\) 匹配，而与 \\(b_j\\) 匹配，那么有 \\((a_i-b_j)^2+(a_j-b_i)^2\\ge(a_i-b_i)^2+(a_j-b_j)^2\\). 证毕 基本不等式：\\(a^2+b^2\\ge2ab\\)，或 \\(\\cfrac {a+b} 2\\ge \\sqrt {ab}\\). 对于均值不等式中的代数平均值＞几何平均值，参见 均值不等式的四大证明. 基本不等式的代数证明较为简单，这里放一个几何证明： 如图，\\(DB=\\sqrt {ab},OD=\\frac {a+b} 2\\)，又有 \\(DB\\ge OD\\). 数论 参见 数论学习笔记 。","link":"/2021/04/16/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%84%E7%A7%8D%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E8%AF%81%E6%98%8E/"},{"title":"【笔记】听课记录 210220【分治,树分治,CDQ分治】","text":"本文为分治,树分治,CDQ分治的听课笔记 分治思想的最简单体现，将具有特征的问题分解成子问题，子问题可用同样方法（即递归）处理。对于子问题之间的联系，特殊处理。 sszx dzy 20% 分治 分而治之 归并排序 分治思想的最简单体现，将具有特征的问题分解成子问题，子问题可用同样方法（即递归）处理。对于子问题之间的联系，特殊处理。 求逆序对 与归并排序密不可分，例： 121 2 3 4 1 2 3 41 2 3 4 5 6 7 8 主定理 求递归式的时间复杂度 平面上的分治 在平面上按x坐标排序分治，再在归并排序过程中考虑y坐标。 练习题 CF480E 树分治 求树上距离不大于k的点对个数，即路径。树分治就是解决树上路径问题的高效算法。 分为点分治和边分治 练习题 SPOJ FTOUR2（求选择不超过k个黑点的路径最大权值）：点分治 BZOJ2152（求2个点之间路径权值和是3的倍数的概率）： BZOJ1758（）：分数规划+长链剖分 CDQ分治 CDQ分治需要题目支持离线算法，且修改操作互不影响 例题：陌上花开（BZOJ3262） Des：求比每个元素的三种属性都小的元素个数 Sol：CDQ分治 练习题 BZOJ1176（维护矩阵，支持单点修改和范围查询）： BZOJ3295,CQOI2011（动态逆序对:CDQ分治经典例题，删除元素的同时求逆序对个数）： BZOJ2716/2648（SJY摆棋子：在棋盘上放下黑棋和白棋，对于白棋输出这个白棋和离它最近的黑棋之间的距离，此处的近和距离指曼哈顿距离）：二维偏序||kdtree 总结 题单:https://www.luogu.com.cn/training/57283","link":"/2021/02/21/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%AC%E8%AF%BE%E8%AE%B0%E5%BD%95%20210220%E3%80%90%E5%88%86%E6%B2%BB,%E6%A0%91%E5%88%86%E6%B2%BB,CDQ%E5%88%86%E6%B2%BB%E3%80%91/"},{"title":"【研究】对欧几里得算法求最大公因数的分析与优化","text":"介,是一段醉朴素的辗转相除法求最大公约数的程序 1234int gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b);} 但是在纸上推导的时候,我们是假设了 \\(a&gt;b&gt;0\\) 的.但当你尝试了它之后,你就会发现它是可以计算 \\(a&lt;b\\) 和负数的情况的.只不过负数算出来的不对. 如果 \\(a&lt;b\\) ,那么会执行 gcd(b,a%b) ,也就是 gcd(b,a). 如果是负数,在最后 b==0 的时候 a 将会是负的,这是因为 C++ 取模的特性,允许取模的结果为负数. 所以,你应当调用 gcd(abs(a),abs(b)), 但不用管 a 和 b 的大小关系. 下面我们来尝试优化它. 首先,这个函数是一个尾递归函数. 就是说递归语句在尾部执行,可以直接丢弃掉每层递归过程中产生的栈空间.如果你在 return 的后面加上一句 int qqq=a+b ,那么执行效率将会和经过优化的尾递归函数大不相同. 尾递归是尾调用的一种特殊类型,通过将函数内部决定递归下限的条件语句更改为循环条件,过程中产生的变量移到循环内部,我们就可以将尾递归函数优化成迭代版本.就像介样: 12345678int gcd(int a,int b) { while(b) { int t=b; b=a%b; a=t; } return a;}","link":"/2021/04/03/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%AF%B9%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"title":"【笔记】无旋 Treap","text":"前言 在 lxl 论平衡树 中，他提到无旋 treap 虽然有点吗，但支持可持久化和分裂操作，不可不谓全能。虽然有点慢，但没有 splay 慢（待定），还能干 splay 能干的事，还好写！ 板子 来自 lmk 推荐 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104namespace treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], sz[N], val[N], rnd[N], tot, rt; void maintain(int p) {sz[p] = sz[lc(p)] + sz[rc(p)] + 1;} void newNode(int &amp;k, int x) { val[++tot] = x, sz[tot] = 1, rnd[tot] = rand(); lc(tot) = rc(tot) = 0; k = tot; } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { rc(x) = merge(rc(x), y); maintain(x); return x; } else { lc(y) = merge(x, lc(y)); maintain(y); return y; } } void split(int p, int v, int &amp;x,int &amp;y) { // split by value if(!p) { x = y = 0; return; } if(val[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); maintain(x); } else { y = p; split(lc(y), v, x, lc(y)); maintain(y); } }// void split(int p, int v, int &amp;x,int &amp;y) { // split by size// if(!p) {// x = y = 0;// return;// }// pushDown(p);// if(sz[lc(p)] &lt; v) {// x = p;// split(rc(x), v - sz[lc(p)] - 1, rc(x), y);// maintain(x);// } else {// y = p;// split(lc(y), v, x, lc(y));// maintain(y);// }// } void del(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, z); split(x, v - 1, x, y); y = merge(lc(y), rc(y)); rt = merge(merge(x, y), z); } void ins(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); newNode(z, v); rt = merge(merge(x, z), y); } int kth(int u, int v) { if(v == sz[lc(u)] + 1) return val[u]; else if(v &lt;= sz[lc(u)]) return kth(lc(u), v); else return kth(rc(u), v - sz[lc(u)] - 1); } int rk(int &amp;rt, int v) { int x, y; split(rt, v-1, x, y); int ret = sz[x] + 1; rt = merge(x, y); return ret; } int pre(int &amp;rt, int v) { int x, y, ret; split(rt, v - 1, x, y); if(!x) return -INF; ret = kth(x, sz[x]); rt = merge(x, y); return ret; } int nxt(int &amp;rt, int v) { int x, y, ret; split(rt, v, x, y); if(!y) return INF; ret = kth(y, 1); rt = merge(x, y); return ret; } int find(int &amp;rt, int v) { int x = 0, y = 0, z = 0, ret = 0; split(rt, v, x, y); split(x, v-1, x, z); if(z) ret = 1; rt = merge(merge(x, z), y); return ret; }} 关于时间复杂度 无旋 treap 最妙的地方在于它用 merge 和 split 两个函数规避了后面所有的向下遍历操作。比如说 splay 和旋式 treap 的 nxt、pre、del 和 ins函数都需要重新写一遍手动向下遍历的逻辑，十分繁琐。 例题 【题解】P2234 [HNOI2002]营业额统计 【题解】P2286 [HNOI2004]宠物收养场","link":"/2021/05/05/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%97%A0%E6%97%8B-Treap/"},{"title":"【笔记】树套树","text":"引入 在维护更改单点信息时，同时维护区间答案。这种做法其实是对我们我全都要思想的一种妥协。 在做区间查询的题的时候，你或许有过这种想法：更新一个数的时候，我直接把涉及到它的 n 个区间全部更新了！这样可以实现 \\(O(1)\\) 的查询！ 但在大多数情况下，我们会更平衡一点，查询和更新的次数差不多。这个时候就需要在更新的区间个数与单次询问的复杂度间做出妥协了。 基于这个思想，最朴素的方法其实是分块，它利用数学方法算出了一个合理的区间个数与大小。 线段树则利用空间换时间，利用了较多的区间量换取了 \\(\\log\\) 的复杂度。 树状数组则有点投机取巧，实际上只能查询整个 \\([1,x]\\) 的信息，需要利用前缀和辅助才能查询区间信息，这也导致了它的局限性。 平衡树每个节点所代表的区间是不固定的，随时可以拆散重组，这也是它可以支持插入删除操作的原因。但我如果想要区间是固定的，就emm了（后面会有）。 现在来看看我们有哪些数据结构利器吧！ 1. 线段树 2. 树状数组 3. 平衡树（主要是无旋转操作的） 4. 分块 5. STL vector, map, set 下面通过题目来具体学习树套树。 树状数组套线段树 问题描述 P2617 Dynamic Rankings P3380 【模板】二逼平衡树（树套树） 给定有 \\(n\\) 个数的区间，\\(m\\) 个操作：1. 求区间 \\([l,r]\\) 内的第 \\(k\\) 小 2. 单点修改数值 \\(\\texttt{Data Range:}n,m \\le 10^5\\) 解法 求整体某数排名、第 k 小、前驱或后继这几个操作，均可以使用权值线段树或平衡树。 加上询问某一区间，势必需要在外层结构使用平衡树、线段树或是树状数组（注意上面的操作本质上都满足加和性质，所以才能用树状数组）。 如果使用外层结构使用平衡树，可以支持插入操作，完成著名题目 P4278 带插入区间K小值。但是由于平衡树一个节点代表的区间不固定，需要重构内层结构，增加了代码复杂度。作为一个蒟蒻肯定是先来写简单的，下面讨论在外层结构使用线段树或树状数组时内层结构的选择： 如果内层结构使用平衡树，其他几个操作都好说，可以 \\(O(log ^n)\\) 搞定。 但是求第 k 小普遍做法是套上一个二分，总复杂度 \\(O(n \\log^3 n)\\)，不是很好。 这时我想到能不能用乱序 treap 合并的方法呢？翻了下 DZY 的讲义，对于若干个大小分别为 \\(A_1,A_2,\\dots,A_k\\) 的乱序 treap，可以做到 \\(O(\\log \\cfrac {(\\sum_{i=1}^k a_i)!} {\\prod_{i=1}^k A_i!})\\) 合并。 由于我太蒟了，不知道这玩意是什么（？），就只好写了一个程序暴力计算了几个点的复杂度（设 treap 个数为 \\(\\log n\\)，大小为 \\(n\\)），然后在 Geogebra 上拟合了一下复杂度与 \\(n\\) 的关系）： 可以看出，\\(f(x)\\) 比 \\(n \\log^2 (n)\\) 都大，\\(xf(x)\\) 更不用说了，直接 T 飞。虽然实际上不一定每颗 treap 的大小都有那么大，但肯定还是 T 飞。 现在只剩下动态开点线段树可以选了，详细过程其他题解都有，不再赘述。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//P2617 AC 100 with C++11 Count: 2 #include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 1e6 + 5;int n, m, cnt, a[N], x[N], orig[N];char op[N];struct ask { char op; int l, r, k, x, y;} q[N];set&lt;int&gt; uni;map&lt;int, int&gt; mp;vector&lt;int&gt; ql, qr;namespace st { int cnt, rt[N &lt;&lt; 2], sum[N * 60], lc[N * 60], rc[N * 60]; void update(int &amp;o, int l, int r, int x, int k) { if(!o) o = ++cnt; sum[o] += k; if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) update(lc[o], l, mid, x, k); else update(rc[o], mid + 1, r, x, k); }}namespace BIT { inline int lowbit(int x) { return x &amp; (-x); } void update(int o, int x, int v) { for(; o &lt;= n; o += lowbit(o)) st::update(st::rt[o], 1, n + m, x, v); // 注意值域 } void getv(int o, vector&lt;int&gt; &amp;A) { // 获取将要用到的版本 for(; o; o -= lowbit(o)) A.push_back(st::rt[o]); } int query(int l, int r, int k) { if(l == r) return orig[l]; int cnt = 0, mid = (l + r) &gt;&gt; 1; for(int &amp;i : ql) cnt -= st::sum[st::lc[i]]; for(int &amp;i : qr) cnt += st::sum[st::lc[i]]; if(cnt &gt;= k) { for(int &amp;i : ql) i = st::lc[i]; for(int &amp;i : qr) i = st::lc[i]; return query(l, mid, k); } else { for(int &amp;i : ql) i = st::rc[i]; for(int &amp;i : qr) i = st::rc[i]; return query(mid + 1, r, k - cnt); } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; uni.insert(a[i]); } for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].op; if(q[i].op == 'Q') cin &gt;&gt; q[i].l &gt;&gt; q[i].r &gt;&gt; q[i].k; else cin &gt;&gt; q[i].x &gt;&gt; q[i].y, uni.insert(q[i].y); } for(auto it = uni.begin(); it != uni.end(); ++it) mp[*it] = ++cnt, orig[cnt] = *it; for(int i = 1; i &lt;= n; i++) a[i] = mp[a[i]]; for(int i = 1; i &lt;= m; i++) if(q[i].op == 'C') q[i].y = mp[q[i].y]; for(int i = 1; i &lt;= n; i++) BIT::update(i, a[i], 1); for(int i = 1; i &lt;= m; i++) { if(q[i].op == 'C') { BIT::update(q[i].x, a[q[i].x], -1); BIT::update(q[i].x, q[i].y, 1); a[q[i].x] = q[i].y; } else { ql.clear(), qr.clear(); BIT::getv(q[i].l - 1, ql); BIT::getv(q[i].r, qr); cout &lt;&lt; BIT::query(1, n + m, q[i].k) &lt;&lt; endl; // 注意值域 } } return 0;}","link":"/2021/05/07/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E5%A5%97%E6%A0%91/"},{"title":"【笔记】欧拉函数","text":"定义 欧拉函数 \\(\\varphi(n)\\) 表示小于等于 \\(n\\) 并与 \\(n\\) 互质的数的个数。 性质 特例：当 \\(n\\) 是质数时，有 \\(\\varphi(n)=n-1\\)；当 \\(n=1\\) 时，有 \\(\\varphi(n)=1\\)（\\(1\\) 与自己互质）。 当 \\(n\\) 为奇数时，有 \\(\\varphi(2n)=\\varphi(n)\\)（\\(2n\\) 与 \\((n,2n]\\) 间的整数均不互质）。 欧拉函数是积性函数。 积性函数指对于所有互质的整数 \\(a\\) 和 \\(b\\) 都有性质 \\(f(ab)=f(a)\\times f(b)\\) 的数论函数。 数论函数指定义域为正整数，陪域为复数的函数。 关于陪域的介绍请看 数学乐，简单来讲，陪域是一个函数所有可能输出的集合。 若 \\(n=p^k\\)，其中 \\(p\\) 是质数，有 \\(\\varphi(n)=p^k-p^{k-1}=(p-1)p^{k-1}\\)。 证明：设正整数 \\(a\\le n\\)，则当且仅当 \\(p\\nmid a\\) 时 \\(a\\) 与 \\(n\\) 互质。所以 \\(\\varphi(n)=n-\\dfrac np=p^k-p^{k-1}\\)。 由唯一分解定理，设 \\(n=\\prod_{i=1}^s p_i^{k_i}\\)，其中 \\(p_i\\) 是质数，有 \\(\\varphi(n)=n\\prod_{i=1}^s \\dfrac {p_i-1}{p_i}\\)。 证明： \\[ \\begin{align} n&amp;=\\prod_{i=1}^s (p_i-1) p_i^{k_i-1}\\\\ &amp;=\\prod_{i=1}^s p_i^{k_i}\\dfrac {p_i-1}{p_i}\\\\ &amp;=n\\prod_{i=1}^s\\dfrac {p_i-1} {p_i}&amp;\\square \\end{align} \\] 设 \\(n\\ge 1\\)，有 \\(n=\\sum_{p\\mid n} \\varphi(p)\\) 线性筛求欧拉函数 设合数 \\(n\\) 最小的质因子为 \\(p\\)，则 \\(n\\) 会被 \\(\\dfrac np\\) 筛掉。设 \\(n'=\\dfrac np\\)，分情况讨论： 若 \\(p\\mid n'\\)，则 \\(n'\\) 包含 \\(n\\) 所有的质因子。由唯一分解定理，设 \\(n=\\prod_{i=1}^s p_i^{k_i}\\)，则有 \\[ \\varphi(n)=n\\prod_{i=1}^s p_i^{k_i}=n'\\times p\\times \\prod_{i=1}^s p_i^{k_i}=p\\times \\varphi(n')。 \\] 若 \\(p\\nmid n'\\)，则 \\((p,n')=1\\)，有 \\(\\varphi(n)=\\varphi(n')\\times \\varphi(p)=(p-1)\\times \\varphi(n')\\)。 由是可以给出具体实现： 123456789101112131415void sieve() { phi[1] = 1, flag[1] = true; for(int i = 2, to; i &lt;= N; i++) { if(!flag[i]) phi[i] = i - 1, prime[++cnt] = i; for(int j = 1; j &lt;= cnt; j++) { to = i * prime[j]; if(to &gt; N) break; flag[to] = true; if(i % prime[j] == 0) { phi[to] = prime[j] * phi[i]; break; } else phi[to] = (prime[j] - 1) * phi[i]; } }} 事实证明，32 位整数的取模因为有指令集，速度是很快的。我尝试用标记每个数最小的质因子的方法来优化，反而变慢了。","link":"/2021/05/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"title":"【笔记】欧拉定理","text":"费马小定理 对于任意整数 \\(a\\)，若 \\(p\\) 为质数，有 \\(a^p\\equiv a\\pmod p\\)。 证明 设 \\(A\\) 为 \\(p\\) 的非负最小完全剩余系，即 \\(A={1,2,3,\\dots,p-1}\\)，设整数 \\(a\\nmid p\\)，有 \\[ \\prod_{i=1}^{p-1}A_i\\equiv\\prod_{i=1}^{p-1}(A_i\\times a)\\pmod p.\\tag1 \\] 要证式 1，等价于证明 \\((A_i\\times a)\\pmod p\\) 组成 \\(p\\) 的一个完全剩余系，即证明 \\(A_i\\times a\\pmod p\\) 两两不属于 \\(p\\) 的同一剩余类： \\(A_i\\times a-A_j\\times a\\le (p-1)\\times a\\)，而 \\((p-1\\times a)\\nmid p\\)，得证。 那么由式 1 推得 \\[ \\begin{align} a^{p-1}\\prod_{i=1}^{p-1}A_i&amp;\\equiv \\prod_{i=1}^{p-1}\\pmod p,\\\\ a^{p-1}&amp;\\equiv1\\pmod p.\\qquad \\square \\end{align} \\] 欧拉定理 对于任意整数 \\(a\\)，若整数 \\(m\\) 与 \\(a\\) 互质，有 \\(a^{\\varphi(m)}\\equiv 1\\pmod m\\)。 证明 定理 1： 若 \\(x\\) 通过模数 \\(m\\) 的缩系，则 \\(ax\\) 也通过 \\(m\\) 的缩系。 证明： 由于 \\((x,m)=1,(a,m)=1\\)，则 \\((ax,m)=1\\)。若 \\(ax_1\\equiv ax_2\\pmod m\\)，则有 \\(x_1\\equiv x_2\\pmod m\\)，与 \\(x\\) 通过模数 \\(m\\) 的缩系矛盾，故 \\(ax\\) 通过模数 \\(m\\) 的缩系。 证毕 设 \\(r_1,r_2,\\dots,r_{\\varphi(m)}\\) 为模数 \\(m\\) 的一个缩系，那么 \\(ar_1,ar_2,\\dots,ar_{\\varphi(m)}\\) 也为模数 \\(m\\) 的一个缩系。那么有 \\(r_1r_2\\dots {\\varphi(m)}\\equiv ar_1ar_2\\dots ar_{\\varphi(m)}\\pmod m\\)，即 \\(r_1r_2\\dots r_{\\varphi(m)}\\equiv a^{\\varphi(m)} r_1r_2\\dots r_{\\varphi(m)}\\pmod m\\)，得证 \\(a^{\\varphi(m)}\\equiv 1\\pmod m\\)。","link":"/2021/05/17/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"【笔记】简单复杂度理论（P,NP,NP-hardness,NP-completeness）","text":"图灵机 图灵机（英语：Turing machine），又称确定型图灵机，是英国数学家艾伦·图灵于1936年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。1 图灵机分为确定型图灵机和非确定型图灵机。简单理解，日常生活中使用的电子计算机就是一种通用确定型图灵机实现，它可以接受任意一个图灵机的编码，并模拟该图灵机的运作。假设一个算法的状态是树形的，确定型图灵机每次只能计算一个状态，通过深度优先遍历或广度优先遍历来完全计算所有状态。但非确定型图灵机可以同时并发计算所有状态，当一个状态使得非确定型图灵机停机，那么整个计算过程就结束。 归约 归约是理解 NPC 问题等定义的必要前置知识。 我们先从一个古老的笑话开始： 一个物理学家和一个数学家正坐在教师休息室里。突然间，休息室里的咖啡机着火了。物理学家就拿了一个垃圾桶，把里面的垃圾清空，跑到水池前，给垃圾桶灌满水，随后扑灭了火。由于这个咖啡机着过一次火了，大家都同意把垃圾桶装满水放在这个咖啡机旁边。 第二天，同样的两个人又坐在同样的休息室里，咖啡机又一次着火了。这一次，数学家站了起来，把装满水的垃圾桶拿了起来，把里面的水倒掉，又放了一些垃圾在里面，交给了物理学家。这样就把问题归约到了一个之前已经解决过的问题上。 虽然这个笑话是讽刺数学家的，但确实很好地解释了归约这个概念。其想法很简单：我们现在遇到了个问题，可以把它转化到一个某个已解决的问题上，而不是一定要直接解决这个问题。从这个意义上来说，归约其实是一种比较懒的解决问题的方式。但在计算复杂度理论中，其意义并不止于此。我们目前说的归约多指“多一归约”（Many-one reduction，下文统一采用此英文名，因为中文名不太常用也不太常见），这是数学家 Emil Post 在1944年提出来的概念。其是以函数形式2 P 问题 在计算复杂度理论中，P（polynomial time class）是在复杂度类问题中可于确定型图灵机以多项式量级（或称多项式时间）求解的决定性问题。3 确定型图灵机多项式时间求解 + 判定。 NP 问题 非确定型图灵机在多项式时间内可以解决 + 判定。 确定型图灵机在多项式时间内可以判定。 NP-hard 问题 若所有 NP 问题都可以归约到某个问题，则称该问题为 NP困难。 那么，NP 困难问题不一定可以被确定型图灵机在多项式时间内判定（所谓判定是指判断一个解的正确性）。 NP-complete 问题 若所有 NP 问题可以归约到问题 P，且问题 P 是 NP 问题，则称问题 P 是 NPC 问题。 P=NP? 4 维基百科:图灵机↩︎ 浅谈复杂度理论中的归约(Reduction) - 知乎 (zhihu.com)↩︎ P (复杂度) - 维基百科，自由的百科全书 (wikipedia.org)↩︎ NP (复杂度) - 维基百科，自由的百科全书 (wikipedia.org)↩︎","link":"/2021/04/22/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%80%E5%8D%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%EF%BC%88P,NP,NP-hardness,NP-completeness%EF%BC%89/"},{"title":"【笔记】OI知识树","text":"前言 几经周折,终于决定了本文的形式. 本文基于洛谷 - 能力全面提升综合题单 Part 2 基础算法 Part 2.1 模拟 Part 2.2 排序算法 冒泡排序 解释 挨个比较并交换 时间复杂度 \\(O(n^2)\\) 归并排序 解释 分成两半比较,并重新在新空间排列 时间复杂度 \\(O(n\\log n)\\) 快速排序 解释 每次选定一个基准数,把比基准数大的数排在右边,剩下的排在左边 时间复杂度 \\(O(n\\log n)\\) Part 4 动态规划 Part 4.4 树形动态规划 可卡数据 1. 只有根 RT Part 5 字符串 Part 5.2 KMP 解释 12A B C D A C A B C D A B 1 2 3 4 5 6 7 8 9 10 11 12 1234a[12]!=a[6]j=fail[5]=1a[2]=a[12]fail[12]=j+1=2 模版 12345678910111213void getFail(){ int j=0; for(int i=2;i&lt;=lenB;i++) { while(j!=0 &amp;&amp; b[i]!=b[j+1]) { j=fail[j]; } if(b[j+1]==b[i]) j++; fail[i]=j; }} 1234567891011121314151617void kmp(){ void j=0; for(int i=1;i&lt;=lenA;i++) { while(j!=0 &amp;&amp; b[j+1]!=a[i]) { j=fail[j]; } if(b[j+1]==a[i]) j++; if(j==lenB) { cout&lt;&lt;i-lenB+1&lt;&lt;endl; j=fail[j]; } }} 时间复杂度 \\(O(n+m)\\) Part 5.5 AC自动机 解释 用于多模式串匹配 模版1(每个模式串只匹配一次) 12345678910111213141516171819202122232425262728293031323334353637383940414243namespace AC{ int size; queue&lt;int&gt; q; int val[N],fail[N]; int trie[N][26]; void insert(char* s) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { int v=s[i]-'a'; if(!trie[u][v]) trie[u][v]=++size; u=trie[u][v]; } val[u]++; } void getFail() { for(int i=0;i&lt;26;i++) if(trie[0][i]) q.push(trie[0][i]); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0;i&lt;26;i++) { int v=trie[u][i]; if(v) fail[v]=trie[fail[u]][i],q.push(v); else trie[u][i]=trie[fail[u]][i]; } } } int query(char* s) { int len=strlen(s),u=0,ans=0; for(int i=0;i&lt;len;i++) { u=trie[u][s[i]-'a']; for(int t=u;t &amp;&amp; ~val[t];t=fail[t]) ans+=val[t],val[t]=-1; } return ans; }} 模版2(每个模式串匹配多次,使用fail树优化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct ahoCorasick{ int size; int val[S],fail[S],id[S],tot[S],pto[S],match[S]; int trie[S][26]; vector&lt;int&gt; gf[S]; queue&lt;int&gt; q; void clear() { size=0; memset(trie[0],0,sizeof trie[0]); memset(val,0,sizeof val); memset(fail,0,sizeof fail); memset(id,0,sizeof id); } void insert(char *s,int idx) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { int c=s[i]-'a'; if(!trie[u][c]) { size++; memset(trie[size],0,sizeof trie[size]); trie[u][c]=size; } u=trie[u][c]; } id[idx]=u; } void getFail() { for(int i=0;i&lt;26;i++) { if(trie[0][i]) q.push(trie[0][i]); } while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0;i&lt;26;i++) { int v=trie[u][i]; if(v) fail[v]=trie[fail[u]][i],q.push(v); else trie[u][i]=trie[fail[u]][i]; } } for(int i=1;i&lt;=size;i++) { gf[fail[i]].push_back(i); } } void count(char *s) { for(int u=0,i=0;s[i];i++) { u=trie[u][s[i]-'a']; val[u]++; } } void dfs(int u) { int len=gf[u].size(); for(int i=0;i&lt;len;i++) { dfs(gf[u][i]); val[u]+=val[gf[u][i]]; } }}AC; 时间复杂度 getFail,insert复杂度:\\(O(\\sum T(i))\\),\\(T(i)\\)表示模式串长度 query复杂度:\\(O(\\sum S(i))\\),\\(S(i)\\)表示目标串长度 Part 8 图论 Part 8.7 图的连通性相关 可卡数据 1. 井图 有多个割点 kosaraju 算法 解释 kosaraju 时间复杂度 \\(O(n+m)\\) 比 Tarjan 慢大约 30%. Tarjan 算法 解释 Tarjan 时间复杂度 \\(O(n+m)\\)","link":"/2021/03/16/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"【笔记】线性代数","text":"本文为huaruoji蒟蒻的线性代数笔记，没有价值 向量 向量:既有大小又有方向的量 向量的三种表示方式: 1.空间中的箭头 2.\\(\\vec{v}\\) 3.\\(\\begin{bmatrix}2\\\\3\\end{bmatrix}\\) 向量的模 有向线段\\(\\overrightarrow{AB}\\)的长度叫做\\(AB\\)的模,记作|\\(\\overrightarrow{AB}\\)|或\\(|a|\\) # 矩阵 例: \\[\\begin{bmatrix}2&amp;3\\\\4&amp;7\\end{bmatrix}\\] 矩阵乘法 例： \\[ 设A=\\begin{bmatrix}2&amp;3\\\\4&amp;7\\end{bmatrix},B=\\begin{bmatrix}1&amp;5\\\\6&amp;8\\end{bmatrix},C=A*B\\\\ 则C=\\begin{bmatrix}2*1+3*6&amp;2*5+3*8\\\\4*1+7*6&amp;4*5+7*8\\end{bmatrix} =\\begin{bmatrix}20&amp;34\\\\46&amp;76\\end{bmatrix} \\] 感性理解：如果把A和B像下面这样标号 \\[ A=\\begin{bmatrix}第一行\\\\第二行\\end{bmatrix},B=\\begin{bmatrix}第&amp;第\\\\一&amp;二\\\\列&amp;列\\end{bmatrix}， \\] 那么\\(C=\\begin{bmatrix}第一行*第一列&amp;第一行*第二列\\\\第二行*第一列&amp;第二行*第二列\\end{bmatrix}\\). 此处的行与列相乘理解为行与列每个对应数乘积之和,既然要\"对应\",那么我们的行宽度与列长度显然要相同. 特殊矩阵 零矩阵 记作\\(O\\),即元素全为0的矩阵 单位矩阵 主对角线全为1的矩阵,例: \\[ \\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1 \\end{bmatrix} \\]","link":"/2021/01/31/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"【笔记】轻重链剖分","text":"前言 个人学习笔记，参考树链剖分 - OI Wiki (oi-wiki.org)。 轻重链剖分 定义 定义 重子节点 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。 定义 轻子节点 表示剩余的所有子结点。 从这个结点到重子节点的边为 重边。 到其他轻子节点的边为 轻边。 若干条首尾衔接的重边构成 重链。 把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。 如图： 实现 伪代码： \\[ \\begin{array}{l} \\text{TREE-BUILD }(u,dep) \\\\ \\begin{array}{ll} 1 &amp; u.hson\\gets 0 \\\\ 2 &amp; u.hson.size\\gets 0 \\\\ 3 &amp; u.deep\\gets dep \\\\ 4 &amp; u.size\\gets 1 \\\\ 5 &amp; \\textbf{for }\\text{each }u\\text{'s son }v \\\\ 6 &amp; \\qquad u.size\\gets u.size + \\text{TREE-BUILD }(v,dep+1) \\\\ 7 &amp; \\qquad v.father\\gets u \\\\ 8 &amp; \\qquad \\textbf{if }v.size&gt; u.hson.size \\\\ 9 &amp; \\qquad \\qquad u.hson\\gets v \\\\ 10 &amp; \\textbf{return } u.size \\end{array} \\end{array} \\] 第二个 DFS 记录所在链的链顶（top，应初始化为结点本身）、重边优先遍历时的 DFS 序（dfn）、DFS 序对应的节点编号（rank）。 \\[ \\begin{array}{l} \\text{TREE-DECOMPOSITION }(u,top) \\\\ \\begin{array}{ll} 1 &amp; u.top\\gets top \\\\ 2 &amp; tot\\gets tot+1\\\\ 3 &amp; u.dfn\\gets tot \\\\ 4 &amp; rank(tot)\\gets u \\\\ 5 &amp; \\textbf{if }u.hson\\text{ is not }0 \\\\ 6 &amp; \\qquad \\text{TREE-DECOMPOSITION }(u.hson,top) \\\\ 7 &amp; \\qquad \\textbf{for }\\text{each }u\\text{'s son }v \\\\ 8 &amp; \\qquad \\qquad \\textbf{if }v\\text{ is not }u.hson \\\\ 9 &amp; \\qquad \\qquad \\qquad \\text{TREE-DECOMPOSITION }(v,v) \\end{array} \\end{array} \\] 使用邻接表存图的 C++ 代码： 1234567891011121314151617int build(int u, int dep) { dep[u] = dep, sz[u] = 1, hson[u] = 0; for(int i = g.head[u]; i; i = g.nxt[i]) { const int &amp;v = g.v[i]; sz[u] += build(v, dep + 1); fa[v] = u; if(sz[v] &gt; sz[hson[u]]) hson[u] = v; } return sz[u];}void decom(int u, int t) { dfn[u] = ++tot, rank[tot] = u, top[u] = t; if(hson[u]) decom(hson[u], t); for(int i = g.head[u]; i; i = g.nxt[i]) if(g.v[i] != hson[u]) decom(g.v[i], g.v[i]);} 性质 树上的每个节点属于且仅属于一条重链。 证明：根据定义，若一个节点是它父亲的重儿子，则它与自己的父亲在同一重链上。若不是，则它是一条重链的起点。由于一个节点只有一个父亲，是重儿子的节点仅属于一条重链。不是重儿子的节点不能与轻儿子组成重链，也仅属于一条重链。 所有的重链将整棵树完全剖分（由性质 1 可得）。 重链内的 DFN 序是连续的。 一颗子树内的 DFN 序是连续的 向下经过一条轻边时，子树大小至少会除以二（若不是，则轻边就不是轻边了） 那么，若从任意节点向根走。若当前是重链的非起始节点，跳到重链的起始节点；若是，向上跨越轻边。 一次跳重链对应一次跨越轻边。由性质 5 可得，跨越轻边的次数不超过 \\(\\log n\\)，所以按上述方法从任意节点访问到根节点的复杂度为 \\(O(\\log n)\\)。（性质 6） 树上的每条路径都可拆分成不超过 \\(2\\log n\\) 条重链。（由性质 6 可得） 常见应用 求最近公共祖先 C++ 代码： 1234567int lca(int u, int v) { while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) v = fa[top[v]]; else u = fa[top[u]]; } return top[u] &lt; top[v] ? u : v;} 解释一下： 存在三种情况 top[u] = top[v]，直接执行 return 语句。 dep[top[u]] &lt; dep[top[v]]，说明 \\(v\\) 跳到 fa[top[v]] 不会跳过。 dep[top[u]] &gt; dep[top[v]]，说明 \\(u\\) 跳到 fa[top[u]] 不会跳过。 求路径权值和 伪代码： \\[ \\begin{array}{l} \\text{TREE-PATH-SUM }(u,v) \\\\ \\begin{array}{ll} 1 &amp; tot\\gets 0 \\\\ 2 &amp; \\textbf{while }u.top\\text{ is not }v.top \\\\ 3 &amp; \\qquad \\textbf{if }u.top.deep&lt; v.top.deep \\\\ 4 &amp; \\qquad \\qquad \\text{SWAP}(u, v) \\\\ 5 &amp; \\qquad tot\\gets tot + \\text{sum of values between }u\\text{ and }u.top \\\\ 6 &amp; \\qquad u\\gets u.top.father \\\\ 7 &amp; tot\\gets tot + \\text{sum of values between }u\\text{ and }v \\\\ 8 &amp; \\textbf{return } tot \\end{array} \\end{array} \\] C++ 代码： 12345678910int getsum(int u, int v) { int tot = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); tot += BIT::query(top[u], u); u = fa[top[u]]; } tot += dep[u] &lt; dep[v] ? BIT::query(u, v) : BIT::query(v, u); return tot;} 其中 BIT:: 也可以换成线段树。 给整颗子树进行操作 用 bottom[x] 记录以 x 为根节点的子树内最大的 dfn 值。然后用线段树区间操作即可。 或者用 dfn[x] + sz[x] - 1 得到。 例题 P2590 [ZJOI2008]树的统计 Des 支持操作： 树上路径求和 树上路径取最大值 树上单点修改 \\(\\texttt{Data Range:}\\) 对于 \\(100 \\%\\) 的数据，保证 \\(1\\le n \\le 3\\times 10^4\\)，\\(0\\le q\\le 2\\times 10^5\\)。 中途操作中保证每个节点的权值 \\(w\\) 在 \\(-3\\times 10^4\\) 到 \\(3\\times 10^4\\) 之间。 Sol 除了树剖，还可以树分块。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5, INF = 1e9; int cnt, dep[N], sz[N], hson[N], dfn[N], fa[N], rk[N], top[N];int n, q, val[N];struct edge { int cnt, nxt[N], head[N], v[N]; void add(const int &amp;a, const int &amp;b) { nxt[++cnt] = head[a], head[a] = cnt, v[cnt] = b; }}g;namespace st { #define lc(x) (x &lt;&lt; 1) #define rc(x) (x &lt;&lt; 1 | 1) int mx[N &lt;&lt; 4], sum[N &lt;&lt; 4], tag[N &lt;&lt; 4]; void pushDown(int l, int r, int p) { int mid = (l + r) &gt;&gt; 1; tag[lc(p)] += tag[p], tag[rc(p)] += tag[p]; sum[lc(p)] += (mid - l + 1) * tag[p]; sum[rc(p)] += (r - mid) * tag[p]; tag[p] = 0; } void pushUp(int p) { sum[p] = sum[lc(p)] + sum[rc(p)]; mx[p] = max(mx[lc(p)], mx[rc(p)]); } void build(int l, int r, int p) { if(l == r) { sum[p] = mx[p] = val[rk[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, lc(p)), build(mid + 1, r, rc(p)); pushUp(p); } int getmax(int l, int r, int p, int x, int y) { if(l &gt;=x &amp;&amp; r &lt;= y) return mx[p]; int mid = (l + r) &gt;&gt; 1, ret = -INF; pushDown(l, r, p); if(x &lt;= mid) ret = getmax(l, mid, lc(p), x, y); if(y &gt; mid) ret = max(ret, getmax(mid + 1, r, rc(p), x, y)); return ret; } int getsum(int l, int r, int p, int x, int y) { if(l &gt;=x &amp;&amp; r &lt;= y) return sum[p]; int mid = (l + r) &gt;&gt; 1, ret = 0; pushDown(l, r, p); if(x &lt;= mid) ret += getsum(l, mid, lc(p), x, y); if(y &gt; mid) ret += getsum(mid + 1, r, rc(p), x, y); return ret; } void add(int l, int r, int p, int x, int y, int k) { if(l &gt;= x &amp;&amp; r &lt;= y) { tag[p] = k, sum[p] += (r - l + 1) * k, mx[p] += k; return; } int mid = (l + r) &gt;&gt; 1; pushDown(l, r, p); if(x &lt;= mid) add(l, mid, lc(p), x, y, k); if(y &gt; mid) add(mid + 1, r, rc(p), x, y, k); pushUp(p); }}int build(int u, int d) { dep[u] = d, sz[u] = 1, hson[u] = 0; for(int i = g.head[u]; i; i = g.nxt[i]) { const int &amp;v = g.v[i]; if(dep[v]) continue; sz[u] += build(v, d + 1); fa[v] = u; if(sz[v] &gt; sz[hson[u]]) hson[u] = v; } return sz[u];}void decom(int u, int t) { dfn[u] = ++cnt, rk[cnt] = u, top[u] = t; if(hson[u]) decom(hson[u], t); for(int i = g.head[u]; i; i = g.nxt[i]) if(g.v[i] != hson[u] &amp;&amp; !dfn[g.v[i]]) decom(g.v[i], g.v[i]);}int lca(int u, int v) { while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) v = fa[top[v]]; else u = fa[top[u]]; } return top[u] &lt; top[v] ? u : v;}int getsum(int u, int v) { int tot = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); tot += st::getsum(1, n, 1, dfn[top[u]], dfn[u]); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); tot += st::getsum(1, n, 1, dfn[u], dfn[v]); return tot;}int getmax(int u, int v) { int ret = -INF; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret = max(ret, st::getmax(1, n, 1, dfn[top[u]], dfn[u])); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); ret = max(ret, st::getmax(1, n, 1, dfn[u], dfn[v])); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; int u, v; for(int i = 1; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g.add(u, v); g.add(v, u); } for(int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; build(1, 1); decom(1, 1); st::build(1, n, 1); cin &gt;&gt; q; string op; for(int i = 1; i &lt;= q; i++) { cin &gt;&gt; op &gt;&gt; u &gt;&gt; v; if(op[1] == 'H') { st::add(1, n, 1, dfn[u], dfn[u], -val[u]); val[u] = v; st::add(1, n, 1, dfn[u], dfn[u], v); } else if(op[1] == 'M') { cout &lt;&lt; getmax(u, v) &lt;&lt; '\\n'; } else { cout &lt;&lt; getsum(u, v) &lt;&lt; '\\n'; } } return 0;} Note 其实可以只写单点修改的。 P3384 【模板】轻重链剖分 Des 支持操作： 树上路径加法 树上路径求和 子树加法 子树求和 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;#define mod(x) x %= Pusing namespace std;typedef long long ll;const int N = 1e5 + 5, INF = 1e9; int cnt, dep[N], sz[N], hson[N], dfn[N], fa[N], rk[N], top[N];int n, m, rt, P, val[N];struct edge { int cnt, nxt[N &lt;&lt; 2], head[N &lt;&lt; 2], v[N &lt;&lt; 2]; void add(const int &amp;a, const int &amp;b) { nxt[++cnt] = head[a], head[a] = cnt, v[cnt] = b; }}g;namespace st { #define lc(x) (x &lt;&lt; 1) #define rc(x) (x &lt;&lt; 1 | 1) ll sum[N &lt;&lt; 4], tag[N &lt;&lt; 4]; void pushDown(int l, int r, int p) { if(tag[p]) { int mid = (l + r) &gt;&gt; 1; tag[lc(p)] += tag[p], tag[rc(p)] += tag[p]; mod(tag[lc(p)]), mod(tag[rc(p)]); sum[lc(p)] += (mid - l + 1) * tag[p]; sum[rc(p)] += (r - mid) * tag[p]; mod(sum[lc(p)]), mod(sum[rc(p)]); tag[p] = 0; } } inline void pushUp(int p) { sum[p] = sum[lc(p)] + sum[rc(p)]; mod(sum[p]); } void build(int l, int r, int p) { if(l == r) { sum[p] = val[rk[l]]; mod(sum[p]); return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, lc(p)), build(mid + 1, r, rc(p)); pushUp(p); } ll getsum(int l, int r, int p, int x, int y) { if(l &gt;=x &amp;&amp; r &lt;= y) return sum[p]; int mid = (l + r) &gt;&gt; 1; ll ret = 0; pushDown(l, r, p); if(x &lt;= mid) ret += getsum(l, mid, lc(p), x, y); if(y &gt; mid) ret += getsum(mid + 1, r, rc(p), x, y); mod(ret); return ret; } void add(int l, int r, int p, int x, int y, int k) { if(l &gt;= x &amp;&amp; r &lt;= y) { tag[p] += k, sum[p] += (r - l + 1) * k; mod(tag[p]), mod(sum[p]); return; } int mid = (l + r) &gt;&gt; 1; pushDown(l, r, p); if(x &lt;= mid) add(l, mid, lc(p), x, y, k); if(y &gt; mid) add(mid + 1, r, rc(p), x, y, k); pushUp(p); }}int build(int u, int d, int f) { dep[u] = d, sz[u] = 1, hson[u] = 0, fa[u] = f; for(int i = g.head[u]; i; i = g.nxt[i]) { const int &amp;v = g.v[i]; if(fa[u] != v) { sz[u] += build(v, d + 1, u); if(sz[v] &gt; sz[hson[u]]) hson[u] = v; } } return sz[u];}int decom(int u, int t) { dfn[u] = ++cnt, rk[cnt] = u, top[u] = t; if(hson[u]) decom(hson[u], t); for(int i = g.head[u]; i; i = g.nxt[i]) if(g.v[i] != hson[u] &amp;&amp; !dfn[g.v[i]]) decom(g.v[i], g.v[i]); return dfn[u];}void out(int u, int fa) { cout &lt;&lt; u &lt;&lt; &quot; top: &quot; &lt;&lt; top[u] &lt;&lt; &quot; sz: &quot; &lt;&lt; sz[u] &lt;&lt; &quot; dfn: &quot; &lt;&lt; dfn[u] &lt;&lt; endl; for(int i = g.head[u]; i; i = g.nxt[i]) if(g.v[i] != fa) { out(g.v[i], u); }}int getsum(int u, int v) { ll tot = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); tot += st::getsum(1, n, 1, dfn[top[u]], dfn[u]); mod(tot); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); tot += st::getsum(1, n, 1, dfn[u], dfn[v]); return mod(tot);}void add(int u, int v, int k) { while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); st::add(1, n, 1, dfn[top[u]], dfn[u], k); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); st::add(1, n, 1, dfn[u], dfn[v], k);}int main() { #ifndef ONLINE_JUDGE freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); #endif ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; P; int op, x, y, z; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; for(int i = 1; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; g.add(x, y); g.add(y, x); } build(rt, 1, 0); decom(rt, rt); st::build(1, n, 1); for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; op; if(op == 1) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z); } else if(op == 2) { cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; getsum(x, y) &lt;&lt; '\\n'; } else if(op == 3){ cin &gt;&gt; x &gt;&gt; z; st::add(1, n, 1, dfn[x], dfn[x] + sz[x] - 1, z); } else { cin &gt;&gt; x; cout &lt;&lt; st::getsum(1, n, 1, dfn[x], dfn[x] + sz[x] - 1) &lt;&lt; '\\n'; } } return 0;}","link":"/2021/05/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%BD%BB%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"},{"title":"【笔记】连通性问题总结","text":"前言 求解连通性问题的 Tarjan 算法学的和那啥一样，重构一下知识体系！ 根基 - Tarjan 算法 设想图中的一个割点或割边： 5 为割点 上图的割点为 5，如果从节点 1 开始 DFS，经过 5 后显然不能回到 1,2,3,4 中的任意一个节点。Tarjan 算法用“时间戳”的概念来记录节点访问顺序。并且设置了“追溯值” low 标记来进行辅助。 无向图 无向图中 \\(low(x)\\) 表示以下任意节点的 \\(dfn\\) 的最小值： subtree(x) 中的节点。 subtree(x) 中的节点通过一条不在搜索树上的边能够到达的节点。 割边 无向边 \\((x,y)\\) 是桥，当且仅当搜索树存在一个 \\(x\\) 的子节点 \\(y\\) 满足 \\(dfn(x) &lt; low(y)\\)。 割点 点 \\(x\\) 是割点，当且仅当： 若 \\(x\\) 是搜索树的根，存在 2 个及以上的 \\(x\\) 的子节点 \\(y\\) 满足 \\(dfn(x)\\le low(y)\\)； 若 \\(x\\) 不是搜索树的根，存在 1 个及以上的 \\(x\\) 的子节点 \\(y\\) 满足 \\(dfn(x)\\le low(y)\\)。 经典的 low[u]=min(low[u],dfn[v]) 不能改成 low[u]=min(low[u],low[v]) 的解释： 如果 \\(subtree(x)\\) 中的节点可以回溯到 \\(dfn\\) 值比 \\(dfn(x)\\) 小的节点，那么显然 \\(x\\) 不是割点。但若已经访问到了 \\(dfn\\) 更小的节点 \\(u\\)，通过节点 \\(u\\) 不一定能访问到 \\(low(u)\\) 所在的节点，因为节点 \\(u\\) 可能就是 \\(x\\)！ 如上图，\\(low(3)=1\\)，通过 5 可以访问到 3。但若将 \\(low(5)\\) 更新为 \\(low(3)\\)，显然是不对的。 边双连通分量 没有割边的无向连通图称作边双连通图，一张无向连通图是边双连通图当且仅当其不存在割点。无向图的极大边双连通子图称作边双连通分量（e-dcc）。 设一张无向连通图的割边数量为 \\(k\\)，则在去掉这些割边后新出现的 \\(k-1\\) 个无向连通图均为原图的边双联通分量。 将所有原来图上节点的边转移到对应的 e-dcc 上，即可完成对 e-dcc 的缩点。 点双连通分量 没有割点的无向连通图称作点双连通图，一张无向连通图是点双连通图当且仅当其不存在割点。无向图的极大点双连通子图称作点双连通分量（v-dcc）。 由于 v-dcc 定义中的”极大“性，一个割点可能属于多个 v-dcc。 设一张无向连通图在去掉所有割点后分割为若干个子图 \\(G_1,G_2,\\dots,G_n\\)，则子图 \\(G_i\\) 与和 \\(G_i\\) 相连的割点 \\(u\\) 共同形成一个 v-dcc。另外，所有直接相连的两个割点也共同构成一个 v-dcc。 v-dcc 的缩点需要将点双连通分量和割点共同作为新图的节点。 在程序实现时，只要触发了割点判定法则，就需要执行存储 v-dcc 的操作。 有向图 用于有向图的 Tarjan 算法对 \\(low(x)\\) 的定义不一样，\\(low(x)\\) 定义为以下任意节点的 \\(dfn\\) 的最小值： 栈中的节点。 subtree(x) 中的节点通过一条边能到达的存在于当前栈中的节点。 这里的栈中的节点是还未被标记为强联通分量的所有存在于搜索树中的节点。 强连通分量 当任意节点 \\(x\\) 在回溯前满足 \\(dfn(x)=low(x)\\)，则栈中在 \\(x\\) 之上的节点与 \\(x\\) 共同构成一个 SCC（强连通分量）。 在标记完毕后，需要弹出栈中 \\(x\\) 节点以上的所有节点以及 \\(x\\) 节点。","link":"/2021/05/14/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"【笔记】高斯消元","text":"资料 《线性代数及其应用》 (美) David C. Lay 概念 \"元\" 与 消元 线性方程与线性方程组 增广矩阵 矩阵的阶梯型 矩阵的最简阶梯型 高斯消元法 对于一个线性方程组的增广矩阵,如果将其化为简化阶梯型,就可以得出该线性方程组解集的表示方法.简化阶梯型意味着:在每一列中,如果只有一个位置不为 0,那么这一列所对应的未知数是基本变量,且该值一定是 1.如果全为 0 或有多个位置不为 0,那么这一列所对应的未知数是自由变量. 基本的高斯消元法需要先将增广矩阵化为阶梯型,再化为简化阶梯型.如果出现某一行形如 \\(0=b\\) ,那么方程无解.如果形如 \\(0=0\\) ,那么有无穷个解,其他情况有唯一解. 来解释一下高斯消元的本质是什么. 假设我们已知 \\(a=3\\) ,那么就可以解出 \\(a+b=m\\) 中 \\(b\\) 的值.然后就可以解除 \\(a+b+c=m_2\\) 中 \\(c\\) 的值.依次类推,每次能解出的线性方程含有且仅含有一个未确定值的未知数. 由于我们更多的时候连一个变量的值都不知道,所以就有了高斯消元来逆向求解 1 个未知数的值.在得到阶梯型矩阵后,如果使用行变换使得每一行的前导元素变为 1,我们也已经得到了关于每个变量的表达式.但显然,这个表达式需要从下往上求值.于是就有了简化阶梯型. 高斯消元是基于行变换的.所以只要简化阶梯型的每一行满足解的判定的条件,那么原本的增广矩阵也满足. 算法顺序 求出线性方程组的增广矩阵 利用初等行变换将增广矩阵化为阶梯型 利用初等行变换将阶梯型化为简化阶梯型 判断解的情况或输出解 优化 高斯-约旦消元法,即不选择主元,直接按照未知数排列的顺序进行消元.只用执行一次三层循环,且没有那么多 double 运算,精度更好,效率更高. 能用这个就不要用朴素高斯消元啊啊啊啊,WA 的最久的一次经历,在 3 个 OJ 交了都没过,关键是还没有数据. 这里就不得不提到数据生成器真好用, 发现是因为 double 溢出了变成了 inf , 然后 inf/inf 就得到了 nan. 另外, -nan 其实只是符号位是负数的 nan , 具体是怎么造成的我也没弄懂. 高斯-约旦消元法的具体步骤： 外层循环枚举 \\(i\\)，表示当前处理第 \\(i\\) 行。 找到使得 \\(abs(a(j,i))\\) 最大的 \\(j\\)，然后将第 \\(j\\) 行与第 \\(i\\) 行交换。 将第 \\(i\\) 行所有数同除 \\(a(i,i)\\)，即使得第 \\(i\\) 行的主元为 1. 对除第 \\(i\\) 行外的所有行 \\(k\\) 执行初等行变换，使得 \\(a(k,i)=0\\)。 判断无解或无数解的方法： 消元完成后，若某行所代表的线性方程左边无参数，右边有参数，则无解；若左边无参数，右边无参数，则有无数解。无解的优先级高于无数解。 12345678910111213141516171819202122232425262728293031323334353637void solve() { for(int i=1;i&lt;=n;i++) { int flag=i; for(int j=i;j&lt;=n;j++) { if(fabs(a[j][i])&gt;=fabs(a[flag][i])) flag=j; } for(int j=1;j&lt;=n+1;j++) swap(a[flag][j],a[i][j]); if(flo0(a[i][i])) continue; for(int j=n+1;j&gt;=1;j--) a[i][j]/=a[i][i]; for(int j=1;j&lt;=n;j++) { if(j==i) continue; if(flo0(a[j][i])==false) { double t=-a[j][i]; for(int k=1;k&lt;=n+1;k++) a[j][k]+=t*a[i][k]; } } } bool no=false,many=false; for(int i=1;i&lt;=n;i++) { int t=0; for(int j=1;j&lt;=n;j++) { if(flo0(a[i][j])==false) ++t; } if(!t) { if(flo0(a[i][n+1])) many=true; else no=true; } } if(no) printf(&quot;-1&quot;); else if(many) printf(&quot;0&quot;); else { for(int i=1;i&lt;=n;i++) { if(flo0(a[i][n+1])) printf(&quot;x%d=0\\n&quot;,i); else printf(&quot;x%d=%.2lf\\n&quot;,i,a[i][n+1]); } }}","link":"/2021/04/08/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"title":"【资源】NOI ONLINE 提高组第三次测试题目存档","text":"NOI ONLINE 提高组第三次测试题目存档 水壶（kettle） image-20200524083532909 魔法值（magic） image-20200524083605363 优秀子序列（sequence） image-20200524083429958","link":"/2020/05/24/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91NOI%20ONLINE%20%E6%8F%90%E9%AB%98%E7%BB%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E5%AD%98%E6%A1%A3/"},{"title":"【资源】SC CSP-J2019初赛成绩","text":"链接: https://pan.baidu.com/s/1UK2pL7UW0n0vYpnzMbJm9A 提取码: uwav 复制这段内容后打开百度网盘手机App，操作更方便哦 Me?87! I am a large!!! 还有几个100分的QAQ","link":"/2019/10/24/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91SC%20CSP-J2019%E5%88%9D%E8%B5%9B%E6%88%90%E7%BB%A9/"},{"title":"【资源】noip初赛试题","text":"链接: https://pan.baidu.com/s/1yoOMIUqMRBnBUPprC3o6HQ&amp;shfl=shareset 提取码: m8ns 复制这段内容后打开百度网盘手机App，操作更方便哦 2006-2016 给个赞呗","link":"/2019/10/18/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91noip%E5%88%9D%E8%B5%9B%E8%AF%95%E9%A2%98/"},{"title":"【转载文章】各种排序方法思想与时间复杂度与稳定性","text":"注意！此处没有打广告！ ps：计数排序就是桶排序，不是基数排序 补充两种排序：希尔排序和基数排序 基数排序：桶排序plus，把每个数分个，十，百位来桶排，复杂度O (nlog(r)m)，其中r为所采取的基数，而m为堆数 希尔排序：插入排序plus，以空间换时间，把每个数间隔加大，插入时便无需向后移动所有元素，时间复杂度介于对数线性阶与平方阶之间 时间复杂度其实很好理解。 直接插入，直接选择，冒泡排序都是n方，因为都是双重循环。 快排和归并都是1生2，2生4，4生8，子子孙孙无穷匮，所以类似于二分，时间复杂度是nlogn 附上快排代码，完善程序有可能考 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int maxn=1e5+5; int n; int a[maxn]; int read() //快速读入 { int x=0,f=1;char ch=getchar(); for(;ch&lt;'0'||ch&gt;'9';ch=getchar())if(ch=='-')f=-1; for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())x=x*10+ch-'0'; return x*f; } void Qsort(int l,int r) { int i=l,j=r,mid=a[(l+r)&gt;&gt;1];//mid作为键值 注意 n&gt;&gt;1表示n/2，位运算基本操作 while(i&lt;=j) { while(a[i]&lt;mid)i++;//小于mid的值放在左半部分不用管 while(a[j]&gt;mid)j--;//大于mid的值放在右半部分不用管 if(i&lt;=j)swap(a[i++],a[j--]);//维护序列 }//[l,i]始终小于等于mid，区间[j,r]始终大于等于mid if(l&lt;j)Qsort(l,j);//递归处理 if(i&lt;r)Qsort(i,r);//递归处理 } int main() { n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); Qsort(1,n); for(int i=1;i&lt;=n;i++) printf(\"%d \",a[i]); return 0; } 由于各种神奇的数据，快排其实是可以优化一下的。 最简单的就是mid=(l+r)/2 再者是随机化，用rand（）函数随机mid（基准数）的值。 代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int n,a[10005]; void quicksort(int l,int r) { int i=l,j=r,mid=a[rand()%(r-l)+l]; while(i&lt;=j) { while(a[i]&lt;mid) i++; while(a[j]&gt;mid) j--; if(i&lt;=j) swap(a[i++],a[j--]); } if(l&lt;j) quicksort(l,j); if(i&lt;r) quicksort(i,r); } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quicksort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; } 用随机化和不用时间比较 左用，右不用 少了一点点吧。。。","link":"/2019/10/18/%E3%80%90%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0%E3%80%91%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%9D%E6%83%B3%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A8%B3%E5%AE%9A%E6%80%A7/"},{"title":"【题解】XCSYOJ 有序表的最小和","text":"一次奇怪的AC经历。。。上周被这道题卡了3天。。。 传送门：http://oj.gdsyzx.edu.cn/problem.php?id=1475 题目描述 给出两个长度为n的有序表A和B，在A和B中各任取一个元素，可以得到n2个和，求这些和中最小的n个。（不要去重） 输入 第一行包含一个整数n（n&lt;=400000）; 第二行与第三行分别有n个整数，分别代表有序表A和B。整数之间由一个空格隔开，大小在长整型范围内，保证有序表的数据单调递增。 输出 输出共n行，每行一个整数，第i行为第i小的和。数据保证在长整型范围内。 样例输入 3 1 2 5 2 4 7 样例输出 3 4 5 先是在学校做了这道题，被归到了“队列”标签里，然后因为是求前n个最小值，那么肯定就是用优先队列啦。 我们先来看一个叫做k路归并问题的神奇玩意（抄的百度文库） 好的，看懂了上面我们进行下一步！把A和B数组所有元素的和看作n个有序表（如下） 如果直接按照k路归并的算法，“把每个表的当前元素放入二叉堆中”需要log n的时间，删除最小值，加入下一个元素（所有表的）又需要log n的时间，总共就需要 n^2 log n 的时间，400000的数据规模铁定爆了！！！ 既然会爆，我们就来优化一下。先思考一下把一个元素放入二叉堆的条件是什么，是它在有序表中的前一个元素被弹出（不是被放入）！所以我们从a1+b1开始扫，每次入堆的时候都打上标记，如果这个元素出堆了，那么就把它所在的有序表的下一个元素入堆！ 综上，O(n log n)！ 代码： #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int n,a[400005],b[400005],t[400005]; struct sb { int h,bj; friend bool operator&lt; (sb a1,sb b1)//带结构体的优先队列用法 { return a1.h&gt;b1.h; } }; priority_queue&lt;sb&gt; q; inline void write(int x)//快速写入 { if(x&gt;9) write(x/10); putchar(x%10+'0'); } int main() { ios::sync_with_stdio(0); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) cin&gt;&gt;a\\[i\\]; for\\(int i=1;i\\&lt;=n;i++\\) cin&gt;&gt;b\\[i\\]; for\\(int i=1;i\\&lt;=n;i++\\) \\{ sb temp; temp.h=a\\[i\\]+b\\[++t\\[i\\]\\]; temp.bj=i; q.push\\(temp\\); write\\(q.top\\(\\).h\\); putchar\\('\\\\n'\\); int bjt=q.top\\(\\).bj; if\\(t\\[bjt\\]\\&lt;n\\) \\{ temp.h=a\\[bjt\\]+b\\[++t\\[bjt\\]\\]; temp.bj=bjt; \\} q.push\\(temp\\); q.pop\\(\\); \\} }","link":"/2019/12/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91HUSTOJ%20%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C/"},{"title":"【题解】P1005 [NOIP2007 提高组] 矩阵取数游戏","text":"Des 帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 \\(n \\times m\\) 的矩阵，矩阵中的每个元素 \\(a_{i,j}\\) 均为非负整数。游戏规则如下： 每次取数时须从每行各取走一个元素，共 \\(n\\) 个。经过 \\(m\\) 次后取完矩阵内所有元素； 每次取走的各个元素只能是该元素所在行的行首或行尾； 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 \\(\\times 2^i\\)，其中 \\(i\\) 表示第 \\(i\\) 次取数（从 \\(1\\) 开始编号）； 游戏结束总得分为 \\(m\\) 次取数得分之和。 帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。 \\(\\texttt{Data Range:}\\) \\(60\\%\\) 的数据满足：\\(1\\le n,m\\le 30\\)，答案不超过 \\(10^{16}\\)。 \\(100\\%\\) 的数据满足：\\(1\\le n,m\\le 80\\)，\\(0\\le a_{i,j}\\le1000\\)。 Sol 脑抽了想来写个高精度。 看错题了，以为是随便取元素，不就是排序然后裸高精度嘛！ 不过加上只能取行首或行尾这个条件后也不难，取过的元素可以“合并”到一起，变成一个得分和，然后就是区间 DP 那一套了。 不过发现我的做法和大多数题解不一样。单独考虑每行，设 \\(f(i,j)\\) 表示已经从左边取了 \\(i\\) 个数，从右边取了 \\(j\\) 个数时得分的最大值。转移方程为 \\(f(i,j)=\\max (f(i-1,j)+2^{i+j}\\times a[i],f(i,j-1)+2^{i+j}\\times a[m-j+1])\\)。 普通的区间 DP 都是内部区间变化，但这个是双端变化，所以理论上这样会好做一些。 高精度写的很烂，其实应该按照正常 int 逻辑重载乘号和加号。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 85;int n, m;int a[N][N];const int S = 45;struct bigInt { int num[S], len; void mul(const bigInt &amp;b) { int tmp[S], x = 0; memset(tmp, 0, sizeof tmp); for(int i = 1; i &lt;= len; i++) { for(int j = 1; j &lt;= b.len; j++) { int cur = i + j - 1; tmp[cur] += num[i] * b.num[j] + x; x = tmp[cur] / 10; tmp[cur] %= 10; } tmp[i + b.len] = x, x = 0; } len = 0; for(int i = S - 1; i &gt;= 0; i--) { if(tmp[i] &amp;&amp; !len) len = i; num[i] = tmp[i]; } } void add(const bigInt &amp;b) { int tmp[S], x = 0; memset(tmp, 0, sizeof tmp); int width = max(len, b.len); for(int i = 1; i &lt;= width; i++) { tmp[i] = num[i] + b.num[i] + x; x = tmp[i] / 10; tmp[i] %= 10; } tmp[width + 1] = x, x = 0; len = 0; for(int i = S - 1; i &gt;= 0; i--) { if(tmp[i] &amp;&amp; !len) len = i; num[i] = tmp[i]; } } bool operator &lt; (bigInt &amp;b) { if(len == b.len) { int t = len; while(num[t] == b.num[t]) --t; return num[t] &lt; b.num[t]; } else return len &lt; b.len; } void out() { if(len == 0) cout &lt;&lt; 0; else for(int i = len; i &gt;= 1; i--) cout &lt;&lt; num[i]; } bigInt() { len = 0; memset(num, 0, sizeof num); } bigInt(int t) { len = 0; memset(num, 0, sizeof num); while(t) { num[++len] = t % 10; t /= 10; } }};int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; } } bigInt pw2[N]; pw2[1] = bigInt(2); for(int i = 2; i &lt;= m; i++) { pw2[i] = bigInt(2); pw2[i].mul(pw2[i - 1]); } bigInt ans(0); for(int i = 1; i &lt;= n; i++) { bigInt f[N][N]; for(int j = 1; j &lt;= m; j++) { bigInt t = pw2[j]; t.mul(bigInt(a[i][j])); f[j][0] = f[j - 1][0]; f[j][0].add(t); } for(int j = m; j &gt;= 1; j--) { bigInt t = pw2[m - j + 1]; t.mul(bigInt(a[i][j])); f[0][m - j + 1] = f[0][m - j]; f[0][m - j + 1].add(t); } for(int j = 1; j &lt; m; j++) { for(int k = 1; k &lt;= m - j; k++) { bigInt x = pw2[j + k]; x.mul(bigInt(a[i][m - k + 1])); x.add(f[j][k - 1]); bigInt y = pw2[j + k]; y.mul(bigInt(a[i][j])); y.add(f[j - 1][k]); if(x &lt; y) f[j][k].add(y); else f[j][k].add(x); } } bigInt mx; for(int j = 0; j &lt;= m; j++) if(mx &lt; f[j][m - j]) mx = f[j][m - j]; ans.add(mx); } ans.out(); cout &lt;&lt; '\\n'; return 0;}","link":"/2021/05/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1005-%5BNOIP2007-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/"},{"title":"【题解】P1007 独木桥","text":"Des 战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳\\(1\\)个人通过。假如有\\(2\\)个人相向而行在桥上相遇，那么他们\\(2\\)个人将无法绕过对方，只能有\\(1\\)个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。 突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为\\(L\\)，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为\\(1\\)，但一个士兵某一时刻来到了坐标为\\(0\\)或\\(L+1\\)的位置，他就离开了独木桥。 每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。 由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。 \\(\\texttt{Data Range:}\\) \\(N\\le L\\le 5000\\) Sol lmk 推荐橙题，你值得拥有！ 这思路确实是太妙了，如果 2 个物体发生碰撞并反弹，如果不要求记录每个物体的数据的话，与 2 个物体径直穿过对方是等效的！ My code 123456789101112131415161718#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int l,n,mn=0,mx;int main() { cin&gt;&gt;l&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int t; cin&gt;&gt;t; mn=max(mn,min(l-t+1,t)); mx=max(mx,max(l-t+1,t)); } cout&lt;&lt;mn&lt;&lt;' '&lt;&lt;mx; return 0;}","link":"/2021/04/29/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1007-%E7%8B%AC%E6%9C%A8%E6%A1%A5/"},{"title":"【题解】P1020 [NOIP1999 普及组] 导弹拦截","text":"使用STL中的upper_bound和lower_bound代替二分操作 对于问一求最长不上升子序列，问二求最长上升子序列（为什么问二是这样是我也不知道） 巨坑的点，对于问一，f数组中的数据是下降（从大到小排序）的，必须添加greater()，二分的原则是排好序啊！！！ 终于AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100005],p,f[100005],k=0;int main(){ while(cin&gt;&gt;a[p]) { p++; } f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&lt;=f[k]) { f[++k]=a[i]; } else { int x=upper_bound(f,f+k,a[i],greater&lt;int&gt;())-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; k=0; memset(f,0,sizeof(f)); f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&gt;f[k]) { f[++k]=a[i]; } else { int x=lower_bound(f,f+k,a[i])-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; return 0; }","link":"/2020/05/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1020%20%5BNOIP1999%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/"},{"title":"【题解】P1040 [NOIP2003 提高组] 加分二叉树","text":"Des 设一个 \\(n\\) 个节点的二叉树 \\(\\text{tree}\\) 的中序遍历为\\((1,2,3,\\ldots,n)\\)，其中数字 \\(1,2,3,\\ldots,n\\) 为节点编号。每个节点都有一个分数（均为正整数），记第 \\(i\\) 个节点的分数为 \\(d_i\\)，\\(\\text{tree}\\) 及它的每个子树都有一个加分，任一棵子树 \\(\\text{subtree}\\)（也包含 \\(\\text{tree}\\) 本身）的加分计算方法如下： \\(\\text{subtree}\\) 的左子树的加分 \\(\\times\\) \\(\\text{subtree}\\) 的右子树的加分 \\(+\\) \\(\\text{subtree}\\) 的根的分数。 若某个子树为空，规定其加分为 \\(1\\)，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为 \\((1,2,3,\\ldots,n)\\) 且加分最高的二叉树 \\(\\text{tree}\\)。要求输出 \\(\\text{tree}\\) 的最高加分。 \\(\\text{tree}\\) 的前序遍历。 Sol 开始被\"符合中序遍历为\\((1,2,3,\\ldots,n)\\)\"这个条件迷惑了很久,一直在想怎么样构造才能满足这个条件呢? 其实只有前序(或后序)与中序遍历已知,才能固定一个二叉树.换句话说,虽然已知了中序遍历是(1,2,3,...,n),这颗二叉树还是长什么样都可以.那么,我们每次选择一个\"根\",计算以这个节点为根的\\(subtree\\)的分数即可. 可以区间DP,也可以记忆化搜索. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ui unsigned intusing namespace std;const int N=35;int n;int a[N];ui f[N][N];int root[N][N];ui dp(int l,int r){ if(f[l][r]) return f[l][r]; if(l&gt;r) return 1; if(l==r) { root[l][r]=l; return a[l]; } for(int k=l;k&lt;=r;k++) { ui now=dp(l,k-1)*dp(k+1,r)+a[k]; if(now&gt;f[l][r]) { f[l][r]=now; root[l][r]=k; } } return f[l][r];}void midBT(int l,int r)//输出答案{ int k=root[l][r]; cout&lt;&lt;k&lt;&lt;' '; if(k-1&gt;=l) midBT(l,k-1); if(r&gt;=k+1) midBT(k+1,r);}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } dp(1,n); cout&lt;&lt;f[1][n]&lt;&lt;endl; midBT(1,n); return 0;}","link":"/2021/03/13/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1040-%5BNOIP2003-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"【题解】P1064 [NOIP2006 提高组] 金明的预算方案","text":"Des 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 \\(n\\) 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 \\(0\\) 个、\\(1\\) 个或 \\(2\\) 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 \\(n\\) 元。于是，他把每件物品规定了一个重要度，分为 \\(5\\) 等：用整数 \\(1 \\sim 5\\) 表示，第 \\(5\\) 等最重要。他还从因特网上查到了每件物品的价格（都是 \\(10\\) 元的整数倍）。他希望在不超过 \\(n\\) 元的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 \\(j\\) 件物品的价格为 \\(v_j\\)，重要度为\\(w_j\\)，共选中了 \\(k\\) 件物品，编号依次为 \\(j_1,j_2,\\dots,j_k\\)，则所求的总和为： \\(v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}\\)。 请你帮助金明设计一个满足要求的购物单。 Sol 有依赖的背包问题. 其实任何有依赖的背包问题都可以转移到树上去做.比如这道题其实完全可以用P2014 [CTSC1997]选课的代码写.那道题也可以看作每个课程的重量为 1. 去洛谷本来想看看有没有用背包九讲里的方法做得,结果根本没有!都是枚举5种情况.好吧Orz. 建树太麻烦,就用一堆乱七八糟的代码过了 My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int N=65;int n,m,p,p2;int w[N&lt;&lt;2],c[N&lt;&lt;2],f[32005],len[N&lt;&lt;2];struct node{ int h,l,r,hv,lv,rv,last;}a[N];int main(){ cin&gt;&gt;m&gt;&gt;n; int v,p,q; memset(a,-1,sizeof a); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;v&gt;&gt;p&gt;&gt;q; if(q==0) a[i].h=v,a[i].hv=p; else if(a[q].l==-1) a[q].l=v,a[q].lv=p; else a[q].r=v,a[q].rv=p; } for(int i=1;i&lt;=n;i++) { if(a[i].h==-1) continue; w[++p2]=a[i].h,c[p2]=w[p2]*a[i].hv; int pre=p2,last=1; if(a[i].l!=-1) w[++p2]=a[i].h+a[i].l,c[p2]=a[i].h*a[i].hv+a[i].l*a[i].lv,++last; if(a[i].r!=-1) w[++p2]=a[i].h+a[i].r,c[p2]=a[i].h*a[i].hv+a[i].r*a[i].rv,++last; if(a[i].l!=-1 &amp;&amp; a[i].r!=-1) w[++p2]=a[i].l+a[i].r+a[i].h,++last,c[p2]=a[i].l*a[i].lv+a[i].h*a[i].hv+a[i].r*a[i].rv; len[pre]=last; } for(int i=1;i&lt;=p2;i++) { if(len[i]==0) continue; for(int j=m;j&gt;=w[i];j--) { for(int k=1;k&lt;=len[i];k++) { if(j-w[i+k-1]&lt;0) continue; f[j]=max(f[j],f[j-w[i+k-1]]+c[i+k-1]); } } } printf(&quot;%d\\n&quot;,f[m]); return 0;}","link":"/2021/03/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1064-%5BNOIP2006-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/"},{"title":"【题解】P1082 [NOIP2012 提高组] 同余方程","text":"Des 求关于$ x$的同余方程 $ a x $ 的最小正整数解。 Sol 学了一天的数论,就学到了这...Orz 首先 \\(ax\\equiv1\\pmod b\\) 等价于 \\(ax+by=1\\). 也就是一个二元一次不定方程. 证明 由 \\(ax\\equiv1\\pmod b\\), 得 \\(ax-bm=1-bn\\) ,即 \\(ax+b(n-m)=1\\). 证毕 由裴蜀定理得 \\(ax+by=1\\) 有解的条件是当且仅当 \\((a,b)\\mid 1\\), 等价于 \\((a,b)=1\\) .题目保证一定有解,说明给出的 a,b 互质.用扩展欧几里得可以求出一组特定解. 然后题目要求输出最小解,使用 (x%b+b)%b 可得到 x 在 \\([0,b-1]\\) 范围内的一个解. 证明 首先,C++ 中的取模操作得到的结果与非负最小剩余不同.C++ 取模的目的是让商尽可能的大.举个例子, -12%5=-2 ,而不是 3. 但显然,假设 x%b=r ,那么 \\(-b&lt;r&lt;b\\) .那么 \\(0&lt;r+b&lt;2b\\), 对应 x%b+b . 再次取模,设得到的结果为 \\(m\\). 那么 \\(0\\le m&lt;b\\). 证毕 设这个解为 \\(x1\\),离这个解最近的两个解分别为 \\(x_0=x_1-b,x_2=x_1+b\\). 那么显然 \\(x_0&lt;0,x_2&gt;b\\). 也就是说方程 \\(ax+by=1\\) 的 x 的解在 \\([0,b-1]\\) 有且仅有一个.而这个解就是 (x%b+b)%b 你可能会奇怪,为什么会想到是在 \\([0,b-1]\\) 这个区间呢? 其实根据数论讲义 §8 (3), 设 \\(ax+by=1\\) 的一组可行解为 \\(x_0,y_0\\) ,那么 \\(x=x_0+bt,y=y_0-bt\\), 其中 t 为任意整数.也就是说每两个 x 的解间隔了 b .我们现在要找最小的非负的 x ,显然要离 0 的距离最近啦. \\(\\texttt{END}\\) My code 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int gcd(int a,int b,int &amp;m,int &amp;n) { if(b==0) {m=1,n=0;return a;} int d=gcd(b,a%b,m,n),t=n; n=m-t*(a/b),m=t; return d;}signed main() { int a,b,x,y; cin&gt;&gt;a&gt;&gt;b; gcd(a,b,x,y); cout&lt;&lt;(x%b+b)%b; return 0;}","link":"/2021/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1082%20%5BNOIP2012%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/"},{"title":"【题解】P1083 [NOIP2012 提高组] 借教室","text":"Des 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来\\(n\\)天的借教室信息，其中第\\(i\\)天学校有\\(r_i\\)个教室可供租借。共有\\(m\\)份订单，每份订单用三个正整数描述，分别为\\(d_j,s_j,t_j\\)，表示某租借者需要从第\\(s_j\\)天到第\\(t_j\\)天租借教室（包括第\\(s_j\\)天和第\\(t_j\\)天），每天需要租借\\(d_j\\)个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供\\(d_j\\)个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第\\(s_j\\)天到第\\(t_j\\)天中有至少一天剩余的教室数量不足\\(d_j\\)个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 Sol 先考虑暴力.将\\([sj,tj]\\)减1,过程中看够不够,时间复杂度\\(O(nm)\\),显然超时. 通过暴力想到可以用线段树做区间减法,理论时间复杂度\\(O(n\\ log\\ n)\\).但洛谷上不优化会被卡.手写min函数,使用register,快读可过.或者使用标记永久化线段树,zkw线段树. 但是,本题的答案有一个不太显然的特征.题目要求输出需要修改订单的申请人编号,假设编号为\\(m\\),那么前\\(m-1\\)订单都满足.也就是说,输出等价于满足前(m-1)个订单的m. \"能否取到\"这个属性随订单编号的增加具有单调性,可以使用二分答案.check函数用到差分,时间复杂度为\\(O(n\\ log\\ n)\\). 再思考深入一点,\"满足\"的本质是什么?是让每一天租借教室的总数量不超过能提供的教室总数量.\"能否取到\"既然具有单调性,就可以递增m或递减m取到最优值.如果让m从1开始递增,无法计算某一天的数量是否超了.但如果让m递减.已经满足的天数不会出现问题,永远只需要满足当前的这一天即可,我愿称之为\"按 需 供 给\".时间复杂度\\(O(n+m)\\). My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//差分 #include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1e6+5;int n,m;int a[N],d[N],st[N],ed[N];ll t;ll dif[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } for(int i=1;i&lt;=m;i++) { d[i]=read(),st[i]=read(),ed[i]=read(); dif[st[i]]+=d[i],dif[ed[i]+1]-=d[i]; } int p=m; for(int i=1;i&lt;=n;i++) { t+=dif[i]; while(t&gt;a[i]) { dif[st[p]]-=d[p],dif[ed[p]+1]+=d[p]; if(st[p]&lt;=i&amp;&amp;i&lt;=ed[p]) { t-=d[p]; } p--; } } if(p==m) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl&lt;&lt;p+1; return 0;}","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1083-%5BNOIP2012-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E5%80%9F%E6%95%99%E5%AE%A4/"},{"title":"【题解】P1119 灾后重建","text":"Des P1119 灾后重建 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 给出\\(B\\)地区的村庄数\\(N\\)，村庄编号从\\(0\\)到\\(N-1\\)，和所有\\(M\\)条公路的长度，公路是双向的。并给出第\\(i\\)个村庄重建完成的时间\\(t_i\\)，你可以认为是同时开始重建并在第\\(t_i\\)天重建完成，并且在当天即可通车。若\\(t_i\\)为\\(0\\)则说明地震未对此地区造成损坏，一开始就可以通车。之后有\\(Q\\)个询问\\((x, y, t)\\)，对于每个询问你要回答在第\\(t\\)天，从村庄\\(x\\)到村庄y的最短路径长度为多少。如果无法找到从\\(x\\)村庄到\\(y\\)村庄的路径，经过若干个已重建完成的村庄，或者村庄\\(x\\)或村庄\\(y\\)在第t天仍未重建完成 ，则需要返回\\(-1\\)。 Sol 坑的一笔. 村庄的编号和完成时间都莫名其妙的从0开始,做了才知道出题人这样干别有用心. 村庄的完成时间和询问时间都是顺序排列的,其实给了一点暗示.如果再看数据范围以及询问的是最短路,不难想出用 Floyd .Floyd 本质是 DP 思想,DP 数组d[k][i][j]代表的其实是可以经过前 k 个村庄,从 i 到 j 的最短路.那么,本题的思路就很显然了. 枚举时间 t ,如果当前时间有村庄修好,运行 Floyd 的后两层循环, k 就是村庄的编号.如果当前时间有询问,直接输出即可. 这种枚举时间,人,国籍编号的思想其实十分常见. 再说说本题为什么坑. 在算法实现中,你大概会在内层循环使用while循环来枚举当前时间修好的村庄或询问. 外层循环时间从0开始,给出数据也从0开始,数组原值还是0.含义混淆了,容易枚举超界,需要注意边界控制. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e3+5,INF=2e9,Q=5e4+5;int n,m,q;int comTime[N];int d[N][N],g[N][N];struct node{ int x,y,t;}query[Q];signed main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) d[i][j]=INF; } for(int i=0;i&lt;n;i++) cin&gt;&gt;comTime[i]; for(int i=1;i&lt;=m;i++) { int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; d[u][v]=d[v][u]=w; } cin&gt;&gt;q; for(int i=0;i&lt;q;i++) cin&gt;&gt;query[i].x&gt;&gt;query[i].y&gt;&gt;query[i].t; int pCom=0,pQ=0; for(int i=0;i&lt;=100000;i++) { while(comTime[pCom]==i &amp;&amp; pCom&lt;n) { for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) d[j][k]=min(d[j][k],d[j][pCom]+d[pCom][k]); ++pCom; } while(query[pQ].t==i &amp;&amp; pQ&lt;q) { int dis=d[query[pQ].x][query[pQ].y]; if(dis==INF || query[pQ].x&gt;pCom-1 || query[pQ].y&gt;pCom-1) printf(&quot;-1\\n&quot;); else printf(&quot;%lld\\n&quot;,dis); ++pQ; } } return 0;}","link":"/2021/03/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1119-%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/"},{"title":"【题解】P1095 [NOIP2007 普及组] 守望者的逃离","text":"Des [P1095 NOIP2007 普及组] 守望者的逃离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Sol 这道题真的挺有意思的,贪心和DP都能做,题解里还有一种神奇的做法.但是自己的才是最好的,说下我的做法吧. 本题涉及到一个''决策''的问题,即跑步还是闪现,与这个决策有关的为当前路程、魔法值和时间.可以发现.当时间还够的时候,永远是闪现更优(就算加上回蓝的时间).但当时间不够,我们就应该考虑跑步了.所以,对于这个题,我们可以设计一种通用的决策方法解题. 枚举时间,如果当前时间能够闪现就直接闪.不能闪就判断是回蓝更优还是跑步更优.判断的方法是计算速度.跑步的速度显然恒为\\(17.0\\).闪现的速度需要用\\(闪现距离(60m)/(闪现的时间(1s)+回蓝的时间(\\lceil(10-m)/4\\rceil))\\).当然这也是朴素贪心的思想. 这样做会出现一个问题.如果当前时间很够,魔法为0,用上面公式算出来的\\(v_闪=15m/s\\).比跑步慢.程序会选择一直跑步.这点是不是很反直觉?我们知道,如果存够魔法值连续闪2次,\\(v_闪=120/7\\approx17.14\\).就比跑步快了.所以还需要考虑闪2次的速度.你会问,如果闪3次更快呢?闪3次就意味着魔法值在30以上,和闪2次再闪1次等效.所以其实这里20是\\(gcd(10,4)\\).也就是说,任何魔法值的状态都可以转移为20以下魔法值的状态. 到了这里,我们已经把魔法值,时间考虑进决策了,最后加上一个当前路程的特判,即可完成解题. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int m,s,t,now,reco;double flash,run=17.0;int main(){ cin&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(int i=1;i&lt;=t;i++) { if(m&gt;=10) { m-=10; now+=60; } else { flash=0; reco=ceil((double)(10-m)/4); if(s-now&gt;=60 &amp;&amp; t-i&gt;=reco) { flash=max(flash,double(60)/(reco+1)); } reco=ceil((double)(20-m)/4); if(s-now&gt;=120 &amp;&amp; t-i&gt;=reco) { flash=max(flash,double(120)/(reco+2)); } if(flash&gt;run) m+=4; else now+=17; } if(now&gt;=s) { printf(&quot;Yes\\n%d\\n&quot;,i); return 0; } } printf(&quot;No\\n%d\\n&quot;,now); return 0;}","link":"/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1095-%5BNOIP2007-%E6%99%AE%E5%8F%8A%E7%BB%84%5D-%E5%AE%88%E6%9C%9B%E8%80%85%E7%9A%84%E9%80%83%E7%A6%BB/"},{"title":"【题解】P1129 [ZJOI2007] 矩阵游戏","text":"Des 小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 \\(n \\times n\\) 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。 对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。 Sol 从这道题可以看出二分图的题的一点特征。这道题有很多种交换方式，但进行了一些交换操作后另一些就不能进行了。比如将第二行与某一行进行交换，再将第一列与某一列进行交换，刚好把一个黑色格子（2,1）移到主对角线上去了。 那么我们就不能再使用第二行和第一列上的任何其他格子了。因为要“使用”（即把它们交换到主对角线上去）它们，就必须进行与前面的交换操作不一样的交换操作。所以就算每一行可以与多列组合来交换一个格子，每一列与多行组合来交换一个格子。任何一行或一列都只能被“使用”一次。抽象一下，这不就是二分图匹配吗！ 题目问能不能使主对角线布满黑色格子，其实就是问能不能找到 \\(n\\) 对匹配。 总结一下：这道题想要我们达到的操作可以看作是许多约束关系的实现（要想让主对角线上一个格子有黑色，就必须交换一行加一列。当然，如果本来就是黑色，相当于不交换），但约束关系的端点只能被选择一次。抽象出二分图匹配的模型就不难了。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=205;int T,n;int vis[N],mat[N];struct edge {int v,nxt;}g[N*N];int sz,head[N];void addEdge(int u,int v) {g[++sz].nxt=head[u],g[sz].v=v,head[u]=sz;}int dfs(int u) { for(int i=head[u];i;i=g[i].nxt) { int &amp;v=g[i].v; if(!vis[v]) { vis[v]=1; if(!mat[v] || dfs(mat[v])) {mat[v]=u;return 1;} } } return 0;}int main() { for(cin&gt;&gt;T;T;--T) { memset(g,0,sizeof g); memset(mat,0,sizeof mat); memset(head,0,sizeof head); cin&gt;&gt;n; int t; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;t; if(t) addEdge(i,j); } } int tot=0; for(int i=1;i&lt;=n;i++) { memset(vis,0,sizeof vis); tot+=dfs(i); } if(tot==n) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;}","link":"/2021/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1129-%5BZJOI2007%5D-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/"},{"title":"【题解】P1273 有线电视网","text":"Des 收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 Sol 树上 DP +分组背包. 用f[i][j]表示第i个节点提供j个用户的费用最小值.时间复杂度\\(O(n^3)\\). 转移方程为\\(f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w)\\). My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N=3005,INF=1e9;int n,m;int w[N],size[N],vis[N][N];int f[N][N];struct node{ int v,w;};vector&lt;node&gt; g[N];void dp(int u){ if(u&gt;n-m) { f[u][1]=w[u]; size[u]=1; return; } int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i].v,w=g[u][i].w; dp(v); size[u]+=size[v]; for(int j=size[u];j&gt;=1;j--) { for(int k=1;k&lt;=size[v];k++) { f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); } } }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int k,v,c; for(int i=1;i&lt;=n-m;i++) { scanf(&quot;%d&quot;,&amp;k); for(int j=1;j&lt;=k;j++) { scanf(&quot;%d%d&quot;,&amp;v,&amp;c); g[i].push_back((node){v,c}); } } for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;w[n-m+i]); } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) f[i][j]=-INF; } dp(1); for(int i=m;i&gt;=0;i--) { if(f[1][i]&gt;=0) { printf(&quot;%d\\n&quot;,i); break; } } return 0;}","link":"/2021/03/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91/"},{"title":"【题解】P1280 尼克的任务","text":"Des P1280 尼克的任务 Sol #1 最开始是想的是一种不像DP的方法,将任务分成很多个序列,每一个序列有一个结束时间t,如果当前枚举的任务可以接在这个序列的后面,就更新时间和答案数组(空闲时间).如果有多个任务都可以接上,就开辟新的序列.但这样代码实现复杂度极高,而且有很多细节需要调整,最坏时间复杂度为\\(O(n^2).\\) My code #1 WA+TLE 40 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e7+5,INF=1e9;int n,k,f[N],t=1,l[N],s=1,empty[N],ans,start=1;struct task{ int p,t; bool operator &lt; (const task &amp;b) const { if(p==b.p) return t&lt;b.t; else return p&lt;b.p; }}a[N];int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;a[i].p&gt;&gt;a[i].t; } sort(a+1,a+k+1); for(int i=1;i&lt;=n;i++) { int empty_size=0; while(a[t].p==i) { for(int j=start;j&lt;=s;j++) { if(l[j]!=INF&amp;&amp;a[t].p&gt;l[j]) { int pos=a[t].p+a[t].t-1,now=f[l[j]]+a[t].p-l[j]-1; if(now&gt;=f[pos]) { f[pos]=now; l[++s]=pos; } empty[++empty_size]=j; } } t++; } for(int j=1;j&lt;=empty_size;j++) { l[empty[j]]=INF; } for(int j=start;j&lt;=s;j++) { if(l[j]==INF) start++; else break; } } for(int i=2;i&lt;=s;i++) { if(l[i]!=INF) { ans=max(ans,f[l[i]]+n-l[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Sol #2 题解中的办法.将时间戳作为状态,但当前状态的最大值可能会由后面的选择决定(同一时间开始的任务做哪一个),不满足无后效性.所以考虑从后往前DP.方程为\\(f[i]=\\begin{cases}f[i+1]+1 \\\\ max\\ f[i+sum[i]] \\end{cases}\\).分别对应当前有任务和无任务时的状态.其中sum[i]表示任务的持续时间.时间复杂度为\\(O(n+k).\\) My code #2 AC 100 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e7+5,INF=1e9;int n,k,f[N],t=1,l[N],s=1,empty[N],ans,start=1;struct task{ int p,t; bool operator &lt; (const task &amp;b) const { if(p==b.p) return t&lt;b.t; else return p&gt;b.p; }}a[N];int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;a[i].p&gt;&gt;a[i].t; } sort(a+1,a+k+1); for(int i=n;i&gt;=1;i--) { if(a[t].p!=i) f[i]=max(f[i],f[i+1]+1); while(a[t].p==i) { f[i]=max(f[i],f[a[t].p+a[t].t]); t++; } } cout&lt;&lt;f[1]&lt;&lt;endl; return 0;} Note 本题中\"任务\"在开始时间和结束时间的状态都是未知的.让人无从下手,如果能确定一个便能轻松解题.但我显然没想到这一步.","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/"},{"title":"【题解】P1308 [NOIP2011 普及组] 统计单词数","text":"Des P1308 [NOIP2011 普及组] 统计单词数 Sol 我还能被普及-的题卡住,真的是没想到. 终于理解C++ Primer Plus上面的话\"C语言对字符串处理很不友好\"是什么意思了.C++不仅增加了不用指定长度的string类型,也为string打造了许多函数.使得对string的处理简便而高效,这道题就是很好的体现.具体请看代码. My code 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;string a,s,now;int cnt,fir=-2,p=0,k=0;bool ok;int main(){ cin&gt;&gt;a; getchar(); getline(cin,s); int len=a.length(); for(int i=0;i&lt;len;i++) a[i]=tolower(a[i]); transform(s.begin(),s.end(),s.begin(),::tolower);//transform函数的定义可以去cplusplus.com查看 a+=' ';//题目要求全字匹配,在单词前后添加空格即可. a.insert(0,&quot; &quot;); s+=' '; s.insert(0,&quot; &quot;); while(p=s.find(a,p)+1)//find函数返回匹配到字符串的首位置. { cnt++; if(cnt==1) k=p-1; } if(cnt) cout&lt;&lt;cnt&lt;&lt;' '&lt;&lt;k&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return 0;}","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1308%20%5BNOIP2011%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0/"},{"title":"【题解】P1311 [NOIP2011 提高组] 选择客栈","text":"Des 丽江河边有 \\(n\\) 家很有特色的客栈，客栈按照其位置顺序从 \\(1\\) 到 \\(n\\) 编号。每家客栈都按照某一种色调进行装饰（总共 \\(k\\) 种，用整数 \\(0 \\sim k-1\\) 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。 两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 \\(p\\) 。 他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 \\(p\\) 元的咖啡店小聚。 Sol 这道题的做法非常多啊... 写了个 \\(O(KN)\\) 的, 和 ST 表的思想一样, 但没用 ST 表. 简单来讲就是用总情况数减去不合法的情况数. 如果选择的两个客栈组成的区间内的咖啡店最低消费都超过能承受值, 显然是不合法的. 其实 \\(O(N)\\) 的算法倒是正向思维, 直接判断当前客栈能与前面的多少客栈组成合法配对. 根据本题的特点, 只用保存每种颜色合法或不合法的数量, 而不用保存每个客栈的详细信息. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e5+5,K=55;int n,k,p;int a[N],b[N],st;ll add[K][N],ans;inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { n=read(),k=read(),p=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(),b[i]=read(); } for(int i=0;i&lt;k;i++) { for(int j=1;j&lt;=n;j++) { if(a[j]==i) add[i][j]=1; add[i][j]+=add[i][j-1]; } } for(int i=0;i&lt;k;i++) { ans+=(add[i][n]*(add[i][n]-1))/2; } for(int i=1;i&lt;=n+1;i++) { if(b[i]&lt;=p) { for(int j=0;j&lt;k;j++) { ll t=add[j][i-1]-add[j][st]; if(t&gt;=0) ans-=(t*(t-1))/2; } st=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/04/15/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1311%20%5BNOIP2011%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88/"},{"title":"【题解】P1349 广义斐波那契数列","text":"Des 广义的斐波那契数列是指形如 \\(a_n=p\\times a_{n-1}+q\\times a_{n-2}\\) 的数列。 今给定数列的两系数 \\(p\\) 和 \\(q\\)，以及数列的最前两项 \\(a_1\\) 和$ a_2$，另给出两个整数 \\(n\\) 和 \\(m\\)，试求数列的第 \\(n\\) 项 \\(a_n \\bmod m\\)。 Sol 先构造矩阵 \\[ \\begin{bmatrix} f_n\\\\ f_{n+1} \\end{bmatrix} \\times \\begin{bmatrix} 0&amp;1\\\\ q&amp;p \\end{bmatrix} = \\begin{bmatrix} f_{n+1}\\\\ f_{n+2} \\end{bmatrix}, \\] 然后用矩阵快速幂加速求解即可. 这里使用了一个重载二维数组的技巧: 1ll* operator [] (int i) {return p[i];} 与重载一维数组的函数相比,只是多了一个星号. 实际上,这个函数返回的是指向二维数组某个第二维开始位置的指针.然后调用 p[i][j] 的时候会重载第一个 [] ,但不会重载第二个. 接受到 &amp;p[i] ,然后就是 C++ 默认的数组下标访问机制了. 另外,这里没有用到单位矩阵,而是利用了矩阵乘法的结合律. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5;ll p,q,a1,a2,P;int n;struct mat { int l,c; ll p[N][N]; ll* operator [] (int i) {return p[i];} void out() { for(int i=0;i&lt;l;i++) { for(int j=0;j&lt;c;j++) { cout&lt;&lt;p[i][j]&lt;&lt;' '; } cout&lt;&lt;endl; } }};mat operator * (mat &amp;a,mat &amp;b) { mat c; c.c=a.c,c.l=b.l; for(int i=0;i&lt;c.l;i++) { for(int j=0;j&lt;c.c;j++) { c[i][j]=0; for(int k=0;k&lt;a.l;k++) { c[i][j]=(c[i][j]+a[k][j]*b[i][k])%P; } } } return c;}int main() { cin&gt;&gt;p&gt;&gt;q&gt;&gt;a1&gt;&gt;a2&gt;&gt;n&gt;&gt;P; if(n==1) cout&lt;&lt;a1; else if(n==2) cout&lt;&lt;a2; else { mat ans,cge; cge[0][0]=0,cge[0][1]=1,cge[1][0]=q,cge[1][1]=p,cge.l=2,cge.c=2; ans[0][0]=a1,ans[1][0]=a2,ans.l=2,ans.c=1; n-=2; while(n) { if(n&amp;1) ans=ans*cge; n&gt;&gt;=1; cge=cge*cge; } cout&lt;&lt;ans[1][0]%P&lt;&lt;endl; } return 0;} Note 一定要记得把矩阵用到的地方初始化. 题目里面的公式看错了.","link":"/2021/04/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1349-%E5%B9%BF%E4%B9%89%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"title":"【题解】P1262 间谍网络","text":"Des 由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果A间谍手中掌握着关于B间谍的犯罪证据，则称A可以揭发B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。 我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有n个间谍(n不超过3000)，每个间谍分别用1到3000的整数来标识。 请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。 Sol 考虑一个 DAG.入度为0的节点必须要能被贿赂且必须贿赂.答案就是入度为0的节点的贿金和.如果有一个不能贿,就输出 NO.其实就是P2746 [USACO5.3]校园网Network of Schools的Subtask 1. 整个图本不是 DAG,使用缩点即可.对强联通分量的贿金比较复杂,注意一下即可. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int N=3005;int n,p,m,ansCost,ansIdx=1e9;int cost[N],in[N],pri[N],priCost[N];vector&lt;int&gt; g[N];int idx,sccCnt;int dfn[N],low[N],ins[N],scc[N];stack&lt;int&gt; s;void tarjan(int u,int fa){ dfn[u]=low[u]=++idx; s.push(u),ins[u]=true; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!dfn[v]) { if(v!=fa) tarjan(v,u); low[u]=min(low[u],low[v]); } else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { ++sccCnt; int top; do { top=s.top(); s.pop(),ins[top]=false; scc[top]=sccCnt; }while(top!=u); }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;p); int idx,num; for(int i=1;i&lt;=p;i++) { scanf(&quot;%d%d&quot;,&amp;idx,&amp;num); cost[idx]=num; } scanf(&quot;%d&quot;,&amp;m); int u,v; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(u==v) continue; g[u].push_back(v); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i,0); } for(int i=1;i&lt;=sccCnt;i++) priCost[i]=1e9,pri[i]=1e9; for(int i=1;i&lt;=n;i++) { if(cost[i] &amp;&amp; cost[i]&lt;priCost[scc[i]]) { priCost[scc[i]]=cost[i]; } pri[scc[i]]=min(pri[scc[i]],i); int len=g[i].size(); for(int j=0;j&lt;len;j++) { int v=g[i][j]; if(scc[v]!=scc[i]) in[scc[v]]++; } } for(int i=1;i&lt;=sccCnt;i++) { if(in[i]==0) { if(priCost[i] &amp;&amp; priCost[i]!=1e9) ansCost+=priCost[i]; else ansIdx=min(ansIdx,pri[i]); } } if(ansIdx!=1e9) printf(&quot;NO\\n%d\\n&quot;,ansIdx); else printf(&quot;YES\\n%d\\n&quot;,ansCost); return 0;} Note 缩点的代码不是if(v==fa) continue,求割点可以.两个虽然用的都是 tarjan ,方法有很大不同.","link":"/2021/03/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1262-%E9%97%B4%E8%B0%8D%E7%BD%91%E7%BB%9C/"},{"title":"【题解】P1352 没有上司的舞会","text":"Des P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 某大学有 \\(n\\) 个职员，编号为 \\(1\\ldots n\\)。 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 \\(r_i\\)，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 Sol 正确做法: 给每个节点安排f[i][0]和f[i][1].分别表示选择该节点和不选择该节点的 dp 值. \\(f[u][0]=r[u]+\\sum_{edge(u,v)}f[v][1],f[u][1]=\\sum _{edge(u,v)}max(f[v][1],f[v][0])\\). 初始调用dp(root,0)和dp(root,1).当\\(u\\)为叶子节点时抵达边界,不需要特判. 最后答案取\\(max(f[root][0],f[root][1])\\). 我的错误做法: 给每个节点安排f[i][0]和f[i][1].分别表示选择该节点和不选择该节点的 dp 值. 递归 dp 中传递 2 个值,一个是当前节点编号 u ,一个是父亲有没有选择(true 表示选择,false 表示不选择). 若父亲选择了,\\(f[u][1]=\\sum _{edge(u,v)}max(f[v][1],f[v][0])\\). 若父亲未选择,\\(f[u][0]=r[u]+\\sum_{edge(u,v)}f[v][1],f[u][1]=\\sum _{edge(u,v)}max(f[v][1],f[v][0])\\). 初始调用dp(root,0)和dp(root,1).当\\(u\\)为叶子节点时抵达边界,不需要特判. 最后答案取\\(max(f[root][0],f[root][1])\\). 错误就错误在虽然树形 DP 中父节点的状态可能影响子节点.但应该在合并答案时判断这个状态带来的影响,而不是在递归计算子节点时. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N=6e3+5;int n,root;int r[N],in[N],vis[N];int f[N][2];int ans=0;vector&lt;int&gt; g[N];void dp(int u){ f[u][1]=0; f[u][0]=r[u]; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; dp(v); f[u][0]+=f[v][1],f[u][1]+=max(f[v][1],f[v][0]); }}int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;r[i]; } for(int i=1;i&lt;n;i++) { int u,v; cin&gt;&gt;u&gt;&gt;v; g[v].push_back(u); in[u]++; } for(int i=1;i&lt;=n;i++) { if(!in[i]) { root=i; dp(root); ans=max(f[root][0],f[root][1]); break; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/03/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1352-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"},{"title":"【题解】P1407 [国家集训队]稳定婚姻","text":"Des 我们已知n对夫妻的婚姻状况，称第i对夫妻的男方为Bi，女方为Gi。若某男Bi与某女Gj曾经交往过（无论是大学，高中，亦或是幼儿园阶段，i≠j），则当某方与其配偶（即Bi与Gi或Bj与Gj）感情出现问题时，他们有私奔的可能性。不妨设Bi和其配偶Gi感情不和，于是Bi和Gj旧情复燃，进而Bj因被戴绿帽而感到不爽，联系上了他的初恋情人Gk……一串串的离婚事件像多米诺骨牌一般接踵而至。若在Bi和Gi离婚的前提下，这2n个人最终依然能够结合成n对情侣，那么我们称婚姻i为不安全的，否则婚姻i就是安全的。 给定所需信息，你的任务是判断每对婚姻是否安全。 Sol 这题目描述该详细的地方异常简洁,该简洁的地方异常详细,导致我理解题意都花了半天. 其实就是,如果Bi和Gi离婚,仍然能从m对关系中挑选出若干对,使得这2n个人能够结成n对夫妻. 这样考虑,若Bi和Gi离婚,Bi去寻找一位曾经有关系的女性\\(G_{j}\\).那么\\(G_j\\)本来的配偶\\(B_j\\)也需要寻找一名女性.假设\\(B_j\\)可以找到\\(G_i\\),这2组婚姻就是不安全的.如果把原本的婚姻关系看作一条从女方到男方的有向边.把曾经的恋爱关系看作一条从男方到女方的有向边.那么,寻找新配偶的过程可以用下图表示. 另一种情况: image-20210319100209425 可以发现,不稳定的婚姻关系都在 SCC 中.只要男方和女方在同一个 SCC ,就是不稳定的. 当然,这个规律是洛谷题解总结出来的.我的代码更朴素,是直接在 Tarjan 算法上更改的.大同小异 解题的关键在于意识到关系形成环就是不稳定的.再想到利用 Tarjan 求出最大环(强连通分量)来降低时间复杂度. 可以归纳出:二分图中的强连通分量其实就是一个纯粹,不含任何杂志的环. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int N=4005;int n,m,p,idx,tot;string s1,s2;map&lt;string,int&gt; id;stack&lt;int&gt; sta;vector&lt;int&gt; g[2*N];int dfn[N&lt;&lt;1],low[N&lt;&lt;1],ins[N&lt;&lt;1],sex[N&lt;&lt;1];bool unsafe[N&lt;&lt;1];void tarjan(int u){ dfn[u]=low[u]=++idx; sta.push(u),ins[u]=true; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { bool flag=false; if(u&lt;=n &amp;&amp; dfn[n+u]&gt;dfn[u] &amp;&amp; dfn[n+u]) flag=true; //如果是一个SCC,就打上标记.但不管是不是SCC,元素都要出栈. ++tot; int top; do { top=sta.top(); sta.pop(),ins[top]=false; unsafe[top]=flag; }while(top!=u); } if(u&lt;=n &amp;&amp; dfn[n+u]==low[u] &amp;&amp; dfn[n+u]) { //对上面第二幅图中情况的判断 ++tot; int top; do { top=sta.top(); sta.pop(),ins[top]=false; unsafe[top]=true; }while(top!=u); }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s1&gt;&gt;s2; g[n+i].push_back(i); id[s1]=i,id[s2]=i+n; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;s1&gt;&gt;s2; g[id[s1]].push_back(id[s2]); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i); } for(int i=1;i&lt;=n;i++) { if(unsafe[i]) printf(&quot;Unsafe\\n&quot;); else printf(&quot;Safe\\n&quot;); } return 0;}","link":"/2021/03/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1407-%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB/"},{"title":"【题解】P1439 【模板】最长公共子序列","text":"前言: LCS：Longest Common Subsequence，最长公共子序列. Des P1439 【模板】最长公共子序列 - 洛谷 Sol 这道题真的是LCS的模版题吗... 基础的LCS算法当然是\\(dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(仅在a[i]=b[j]情况下))\\).但\\(O(n^2)\\)的算法当然过不了洛谷\\(10^5\\)的毒瘤数据.只能考虑优化. 把对应的数字连起来(如上图),这个问题不就变成选择最多的不交叉连线了吗,和P2782 友好城市一样.那么,这个问题的核心其实是LIS.将上下数列的连接建立好后,即可套用代码. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,t,f[N],r;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct line{ int x,y;}a[N];bool cmp(const line &amp;a,const line &amp;b){ return a.x&lt;b.x;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { t=read(); a[t].x=i; } for(int i=1;i&lt;=n;i++) { t=read(); a[t].y=i; } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(a[i].y&gt;f[r]) f[++r]=a[i].y; else f[upper_bound(f+1,f+r,a[i].y)-f]=a[i].y; } printf(&quot;%d\\n&quot;,r); return 0;} Note f[upper_bound(f+1,f+r,a[i].y)-f]=a[i].y;也可这样写:*upper_bound(f+1,f+r,a[i].y)=a[i].y;","link":"/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"【题解】P1456 Monkey King","text":"Des P1456 Monkey King - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 题目描述 曾经在一个森林中居住着 \\(N\\) 只好斗的猴子。在最初他们我行我素，互不认识。但是猴子们不能避免争吵，且两只猴子只会在不认识对方时发生争吵，当争吵发生时，双方会邀请它们各自最强壮的朋友并发起决斗（决斗的为各自最强壮的朋友）。当然，在决斗之后两只猴子和他们各自的伙伴都认识对方了（成为朋友），虽然他们曾经有过冲突，但是他们之间绝不会再发生争吵了。 假设每只猴子有一个强壮值，强壮值将在一场决斗后减少为原先的一半（例如 \\(10\\) 会减少到 \\(5\\)，而 \\(5\\) 会减少到 \\(2\\)，即向下取整）。 我们也假设每只猴子都认识它自己（是自己的朋友）。即当他是他朋友中最强壮的，他自己就会去决斗。 输入格式 有多组数据，每一组数据有两部分。 第一部分：第一行包含一个整数 \\(N\\) 表示猴子的数量。后为 \\(N\\) 行，每行一个数字为第 \\(i\\) 只猴子的强壮值 \\(s_{i}\\)。 第二部分：第一行包含一个整数 \\(M\\) 表示发生了 \\(M\\) 次冲突。后为 \\(M\\) 行，每行两个整数 \\(x\\) 和 \\(y\\)，表示第 \\(x\\) 只猴子和第 \\(y\\) 只猴子之间发生了冲突。 输出格式 对于每次冲突，如果两只猴子认识对方，输出 -1，否则输出决斗后他们朋友中最强壮的猴子的强壮值。 说明/提示 \\(N,M\\leq 100000\\)，\\(s_{i}\\leq 32768\\) Sol 针对本题的操作, 有两种方法来实现程序. 一是为每个猴子记录一个所在节点的编号. 也就是删除了堆顶节点后, 就不在使用它了. 重新开一个节点来记录猴子的 val. 但是这样写比较麻烦, 而且浪费空间. 所以就需要重新利用被删除节点. 你需要执行: 将该节点的 val=val/2. 将该节点的 lchild 和 rchild 置为 0. 将该节点的 father 置为它自己. 很容易忘记重置儿子的值, 所以要多加注意. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;namespace hp { #define ls c[x].l #define rs c[x].r struct node { int val,d,l,r,f; }c[N]; int find(int x) { if(c[x].f!=x) c[x].f=find(c[x].f); return c[x].f; } int merge(int x,int y) { if(!x||!y) return x+y; if(c[x].val&lt;c[y].val) swap(x,y); rs=merge(rs,y); if(c[ls].d&lt;c[rs].d) swap(ls,rs); c[ls].f=c[rs].f=x,c[x].d=c[rs].d+1; return x; } void del(int x) { int nl=ls,nr=rs; c[nl].f=nl,c[nr].f=nr; c[x].val&gt;&gt;=1,c[x].l=c[x].r=c[x].d=0,c[x].f=x; merge(nl,nr); merge(find(nl),x); }}int main() { using namespace hp; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { c[0].d=-1; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;c[i].val); c[i].f=i,c[i].l=c[i].r=c[i].d=0; } scanf(&quot;%d&quot;,&amp;m); int x,y; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x=find(x),y=find(y); if(x==y) printf(&quot;-1\\n&quot;); else { del(find(x)),del(find(y)); merge(find(x),find(y)); printf(&quot;%d\\n&quot;,c[find(x)].val); } } } return 0;} Note 提示 Too short on line xx. 其实就是没输出够. 需要看是不是有多组数据. 可以用斜堆过","link":"/2021/04/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1456-Monkey-King/"},{"title":"【题解】P1486 [NOI2004] 郁闷的出纳员","text":"Des 第一行有两个整数 \\(n\\) 和 \\(\\min\\)。\\(n\\) 表示下面有多少条命令，\\(\\min\\) 表示工资下界。 接下来的 \\(n\\) 行，每行一个字符 \\(x\\) 和一个整数 \\(k\\)，表示一条命令。命令可以是以下四种之一： I k 新建一个工资档案，初始工资为 \\(k\\)。如果某员工的初始工资低于工资下界，他将立刻离开公司。 A k 把每位员工的工资加上 \\(k\\) 。 S k 把每位员工的工资扣除 \\(k\\)。 F k 查询第 \\(k\\) 多的工资。 在初始时，可以认为公司里一个员工也没有。 \\(\\texttt{Data Range:}\\) 对于全部的测试点，保证： I 命令的条数不超过 \\(10^5\\)； A 和 S 命令的总条数不超过 \\(100\\)； F 命令的条数不超过 \\(10^5\\)； 每次工资调整的调整量不超过 \\(10^3\\)； 新员工的工资不超过 \\(10^5\\)。 \\(0 \\leq n \\leq 3 \\times 10^5\\)，\\(0 \\leq \\text{min} \\leq 10^9\\)，输入的所有数字均在 \\(32\\) 位带符号整形范围内。 Sol 在 fhq-treap 模版上改进： 重写 kth 函数使其变为从大到小第 k 个。 增加 tag 数组用于延迟下传标记。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//AC100 Count:1#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 1e5+5, INF = 2147483647;int n, minPay, leaveCnt;namespace treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], sz[N], val[N], rnd[N], tag[N], tot, rt; inline void maintain(int p) {sz[p] = sz[lc(p)] + sz[rc(p)] + 1;} void preWork() {srand(time(0));} void newNode(int &amp;k, int x) { val[++tot] = x, sz[tot] = 1, rnd[tot] = rand(); lc(tot) = rc(tot) = tag[tot] = 0; k = tot; } void pushDown(int x) { if(x &amp;&amp; tag[x]) { val[x] += tag[x]; if(lc(x)) tag[lc(x)] += tag[x]; if(rc(x)) tag[rc(x)] += tag[x]; tag[x] = 0; } } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { pushDown(x); rc(x) = merge(rc(x), y); maintain(x); return x; } else { pushDown(y); lc(y) = merge(x, lc(y)); maintain(y); return y; } } void split(int p, int v, int &amp;x, int &amp;y) { pushDown(p); if(!p) { x = y = 0; return; } else if(val[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); maintain(x); } else { y = p; split(lc(y), v, x, lc(y)); maintain(y); } } void ins(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); newNode(z, v); rt = merge(merge(x, z), y); } int kth(int u, int v) { pushDown(u); if(v == sz[rc(u)] + 1) return val[u]; else if(v &lt;= sz[rc(u)]) return kth(rc(u), v); else return kth(lc(u), v - sz[rc(u)] - 1); }}using namespace treap;int main() { ios::sync_with_stdio(false); cin.tie(0); preWork(); cin &gt;&gt; n &gt;&gt; minPay; char op; int x; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; op &gt;&gt; x; int a = 0; if(op == 'I') { if(x &gt;= minPay) ins(rt, x); split(rt, minPay-1, a, rt); leaveCnt += sz[a]; } else if(op == 'A') { if(rt) tag[rt] += x; split(rt, minPay-1 , a, rt); leaveCnt += sz[a]; } else if(op == 'S') { if(rt) tag[rt] -= x; split(rt, minPay-1 , a, rt); leaveCnt += sz[a]; } else { if(x &gt; sz[rt]) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; kth(rt, x) &lt;&lt;endl; } } cout &lt;&lt; leaveCnt &lt;&lt; endl; return 0;}","link":"/2021/05/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1486-%5BNOI2004%5D-%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/"},{"title":"【题解】P1494 [国家集训队]小Z的袜子","text":"Des 作为一个生活散漫的人，小 Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小 Z 再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小 Z 把这 \\(N\\) 只袜子从 \\(1\\) 到 \\(N\\) 编号，然后从编号 \\(L\\) 到 \\(R\\) (\\(L\\) 尽管小 Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小 Z，他有多大的概率抽到两只颜色相同的袜子。当然，小 Z 希望这个概率尽量高，所以他可能会询问多个 \\((L,R)\\) 以方便自己选择。 然而数据中有 \\(L=R\\) 的情况，请特判这种情况，输出0/1。 Sol 这道题居然是莫队的模版题（可惜我眼瞎没看到进阶指南上加粗的字），于是我把它用分块 A 了。 这道题是一道ex的题，它每个数据点的时限只有 200ms。 这道题是滑蒻稽蒟蒻提交次数最多的题（38次）。 先想一想暴力，可以从 \\(L\\) 到 \\(R\\) 暴力枚举（\\(O(N^2)\\)），也可以枚举袜子颜色再二分区间查找数量（\\(O(N^2\\log N)\\)）。 接下来，我们就来探讨一下本题的分块做法以及卡常技巧。 对于整块，我们并不需要知道究竟选择了哪些袜子，只需要知道可选择数量。于是考虑求解整块区间内可选择袜子数量。每遇见一只新袜子，它与之前所有相同颜色袜子都可以组合，于是记录每只袜子出现次数（即之前提到的求解过程中的“区间可加性”）。这样，每次枚举 \\(l\\) 时为了方便，可以清空记录袜子数量的数组（时间复杂度 \\(O(n)\\)），然后枚举 \\(r\\)。 对于散块，我们需要知道每种袜子颜色出现次数，可以像我一样 sb 地多开点统计，也可以沿用之前蒲公英的做法，开 vector 记录下标（其实用 vector 并没有方便多少）。区间总数量减去整块数量就是散块袜子数量。散块的袜子可以与自己组合，也可以与整块组合（忘了说，还要记录整块区间每种颜色袜子数量。空间应该是 \\(T\\cdot T \\cdot N\\)，用前缀和可以省下一维，变成 \\(T\\cdot N\\)）。 这样就做完了，时间复杂度是 \\(O(2\\cdot \\frac {N^2} T)+O(MT)\\)，那么块的大小 \\(T=\\sqrt {\\frac {2N^2} M}\\)。 接下来是喜闻乐见的卡常环节： 我的代码中有 1if(i!=0) for(int j=1;j&lt;=n;j++) preAdd[i][j]+=preAdd[i-1][j]; 很明显，把 i 放在第一维，对 preAdd 数组的访问才是连续的，但是之前写的是把它放在了第二维，就导致了无数次所谓的 cache miss，TLE 70。这和矩阵乘法中循环变量的顺序应设置为 i,k,j 类似。 总之，请用莫队过这道题，不要和我一样认为“理论上分块时间复杂度没问题！”和它硬杠。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=50005,M=50005,MXT=500;int n,m,cnt,T,sameCnt[MXT][MXT];int a[N],preAdd[MXT][N],bl[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void preWork() { for(int i=0;i&lt;cnt;i++) { int st=i*T+1,ed=min(n,(i+1)*T); for(int j=st;j&lt;=ed;j++) { ++preAdd[i][a[j]]; } if(i!=0) for(int j=1;j&lt;=n;j++) preAdd[i][j]+=preAdd[i-1][j]; } int t[N]; for(int i=0;i&lt;cnt;i++) { memset(t,0,sizeof t); for(int j=i;j&lt;cnt;j++) { if(j!=0) sameCnt[i][j]=sameCnt[i][j-1]; int st=j*T+1,ed=min(n,(j+1)*T); for(int k=st;k&lt;=ed;k++) { sameCnt[i][j]+=t[a[k]]; t[a[k]]++; } } }}int tmpTot[N],vis[N],v[N],p;int query(int l,int r,int idx) { int ans=0; p=0; for(;l%T!=1;l++) { if(vis[a[l]]!=idx) { vis[a[l]]=idx; tmpTot[a[l]]=1; v[++p]=a[l]; } else ++tmpTot[a[l]]; if(l==r) { for(int i=1;i&lt;=p;i++) { int tot=tmpTot[v[i]]; ans+=(tot*(tot-1))/2; } return ans; } } for(;r%T!=0;r--) { if(vis[a[r]]!=idx) { vis[a[r]]=idx; tmpTot[a[r]]=1; v[++p]=a[r]; } else ++tmpTot[a[r]]; if(l==r) { for(int i=1;i&lt;=p;i++) { int tot=tmpTot[v[i]]; ans+=(tot*(tot-1))/2; } return ans; } } for(int i=1;i&lt;=p;i++) { int num=v[i],tot=tmpTot[v[i]]; ans+=(tot*(tot-1))/2; if(bl[l]==0) ans+=tot*preAdd[bl[r]][num]; else ans+=tot*(preAdd[bl[r]][num]-preAdd[max(0,bl[l]-1)][num]); } ans+=sameCnt[bl[l]][bl[r]]; return ans;}ll gcd(ll a,ll b) { if(b==0) return a; return gcd(b,a%b);}inline void reduce(ll &amp;a,ll &amp;b) { if(a==0) {b=1;return;} ll q=gcd(a,b); a/=q,b/=q;}int main() { n=read(),m=read(); cnt=n/(T=max(1,(int)sqrt((double)(2*n*n)/double(m)))); if(n%T!=0) ++cnt; for(int i=1;i&lt;=n;i++) { a[i]=read(); bl[i]=(i-1)/T; } preWork(); int l,r; for(int i=1;i&lt;=m;i++) { l=read(),r=read(); ll pro=query(l,r,i),total=((ll)(r-l+1)*(ll)(r-l))/2; reduce(pro,total); printf(&quot;%lld/%lld\\n&quot;,pro,total); } return 0;} Note 交换了数组两维的顺序后，一个点快了 100 ms。 如果你设置 \\(T={\\sqrt N \\over 2}\\) 会更快！","link":"/2021/04/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1494-%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/"},{"title":"【题解】P1516 青蛙的约会","text":"Des 两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 Sol 相当于解同余方程 \\(x+am\\equiv y+an \\pmod L\\), 其中 a 为整数. 也就是 \\(a(m-n)+b(-L)=y-x\\). a,b 都为整数. 需要注意, \\(m-n\\) 和 \\(y-x\\) 可能小于零. 之前论证的扩展欧几里德算法适用的方程是 \\(ax+by=c\\) ,其中 \\(a,b\\neq 0,(a,b)\\mid c\\). 根据裴蜀定理,判断有没有解只需要看 \\((a,b)\\) 能否整除 c. 所以直接先跑一遍扩欧,然后正常输出解即可. 是这样吗? 同余方程的定义没有问题,但之前用辗转相除法求出来的最大公因数有问题! 我们之前在讨论多个数的最大公因数时,提到了 \\((a_1,a_2,\\dots,a_n)=(|a_1|,|a_2|,\\dots,|a_n|)\\), 也就是说,当时讨论出来的辗转相除法只适用于正数! 所以,传参进扩欧时要先取绝对值. 到了这里,我们已经解决了本题中的 \\[ ax+by=(a,b),\\tag1 \\] 然后如何求出 \\(ax+by=c\\) 的解呢? 设存在整数 \\(x_1,y_1\\) 使得 \\(ax+by=c\\). 设 \\((a,b)=d\\). 由 (1) 得 \\[ (ax+by)\\cdot \\frac cd=d\\cdot \\frac cd,\\\\ a\\cdot \\frac {xc}{d}+b\\cdot \\frac {yc}{d}=c, \\] 那么 \\(x_1=\\cfrac {xc} d\\). 在求出 \\(x_1\\) 的一个特解后,就可以用公式 \\(x_n=x_1+\\cfrac {bt} d\\) 求出任意解了.根据数论讲义第一章习题2,得到在连续的 \\(\\cfrac bd\\) 个整数中,只有一个能被 \\(\\cfrac bd\\) 除尽.也就是说在 \\([0-x_1,\\cfrac bd-x_1-1]\\) 这个区间,只有一个是 \\(\\cfrac bd\\) 的整数倍.那么在区间 \\([0,\\cfrac bd-1]\\), 有且仅有一个 x 的解. My code 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll x,y,sm,sn,l;ll a,b,c,m,n;ll gcd(ll a,ll b,ll &amp;m,ll &amp;n) { if(b==0) {m=1,n=0;return a;} ll d=gcd(b,a%b,m,n),t=n; n=m-t*(a/b),m=t; return d;}int main() { cin&gt;&gt;x&gt;&gt;y&gt;&gt;sm&gt;&gt;sn&gt;&gt;l; a=sm-sn,b=-l,c=y-x; ll d=gcd(abs(a),abs(b),m,n); if(a&lt;0) m=-m; if(b&lt;0) n=-n; if(c&lt;0) m=-m,n=-n; if(c%d!=0) cout&lt;&lt;&quot;Impossible\\n&quot;; else { b=abs(b),c=abs(c); ll r=b/d; m=m*c/d; cout&lt;&lt;(m%r+r)%r; } return 0;}","link":"/2021/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1516-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/"},{"title":"【题解】P1525 [NOIP2010 提高组] 关押罪犯","text":"Des S 城现有两座监狱，一共关押着 \\(N\\) 名罪犯，编号分别为 \\(1-N\\)。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 \\(c\\) 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 \\(c\\) 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了\\(N\\) 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ Sol 一个奇怪的特征：局长只会看冲突最大的事件。 换言之，满足条件的答案大小具有单调性，且首先要满足冲突最大的犯人。 2种做法就出来了，一是贪心+并查集，二是二分答案+二分图匹配。 之前一直没理解透二分答案，其实就是：答案就在那里，我要去找到它。 My code Sol 1 并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e4+5,M=1e5+5;;int n,m;int at[N];struct edges { int u,v,w; bool operator &lt; (const edges &amp;b) const {return w&gt;b.w;}}g[M];int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace ds { int f[N],s[N]; void pre() {for(int i=1;i&lt;=n;i++) f[i]=i,s[i]=1;} int find(int u) {return (f[u]==u)?(f[u]):(find(f[u]));} bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return false; if(s[x]&gt;s[y]) swap(x,y); s[y]+=s[x],f[x]=y; return true; }}int main() { n=read(),m=read(); for(int i=1;i&lt;=m;i++) { g[i].u=read(),g[i].v=read(),g[i].w=read(); } sort(g+1,g+m+1); ds::pre(); for(int i=1;i&lt;=m;i++) { int u=g[i].u,v=g[i].v,w=g[i].w; u=ds::find(u),v=ds::find(v); if(u==v) {cout&lt;&lt;w&lt;&lt;endl;return 0;} if(at[u]!=0) { if(ds::merge(v,at[u])==false) {cout&lt;&lt;w&lt;&lt;endl;return 0;} } at[u]=ds::find(v); if(at[v]!=0) { if(ds::merge(u,at[v])==false) {cout&lt;&lt;w&lt;&lt;endl;return 0;} } at[v]=ds::find(u); } cout&lt;&lt;0&lt;&lt;endl; return 0;} Sol 2 二分答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e4+5,M=1e5+5;;int n,m;int color[N];vector&lt;int&gt; e[N];struct edges { int u,v,w; bool operator &lt; (const edges &amp;b) const {return w&lt;b.w;}}g[M];inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}bool dfs(int u,int col) { int len=e[u].size(); color[u]=col; for(int i=0;i&lt;len;i++) { int&amp; v=e[u][i]; if(color[v]==color[u]) return false; else if(color[v]==0 &amp;&amp; dfs(v,-col)==false) return false; } return true;}bool check(int pos) { for(int i=1;i&lt;=n;i++) e[i].clear(); for(int i=pos+1;i&lt;=m;i++) { e[g[i].u].push_back(g[i].v); e[g[i].v].push_back(g[i].u); } memset(color,0,sizeof color); for(int i=1;i&lt;=n;i++) { if(color[i]==0) if(dfs(i,1)==false) return false; } return true;}int main() { n=read(),m=read(); for(int i=1;i&lt;=m;i++) { g[i].u=read(),g[i].v=read(),g[i].w=read(); } sort(g+1,g+m+1); int l=0,r=m,mid=0; while(l&lt;r) { mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid; else l=mid+1; } cout&lt;&lt;g[l].w&lt;&lt;endl; return 0;}","link":"/2021/03/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1525-%5BNOIP2010-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF/"},{"title":"【题解】P1541 [NOIP2010 提高组] 乌龟棋","text":"Des P1541 [NOIP2010 提高组] 乌龟棋 Sol 又是一道\"取数\"类问题.回首二维平面上的取数问题,如P1004 [NOIP2000 提高组] 方格取数,P7074 [CSP-J2020] 方格取数.都是把当前的\"位置\"当作状态,即\\(f[i][j]\\)表示走到\\((i,j)\\)位置时的最优解.在上面的2道题中都没有额外的信息需要维护,但在本题中因为每种卡片数量是有限的,所以你需要存储当前位置的卡片数.这样的话dp数组就变成了五维,即\\(f[i][c1][c2][c3][c4]\\).i表示当前位置,c1~c4表示当前位置卡片数量.计算后发现超了空间,时间复杂度也不合理. 注意到本题\"卡片\"的特殊性质,卡片上的数代表了移动距离,也就是说我们完全可以只用卡牌数量做状态,去掉i.dp数组为\\(f[c1][c2][c3][c4]\\).这样既能保留完整的状态,状态转移也很简单.用a数组存储格子分数.状态转移方程即为\\(f[c1][c2][c3][c4]=max\\begin{cases}f[c1-1][c2][c3][c4]+a[now]\\\\ f[c1][c2-1][c3][c4]+a[now]\\\\ f[c1][c2][c3-1][c4]+a[now]\\\\ f[c1][c2][c3][c4-1]+a[now] \\end{cases}\\).代码实现中可建立一个辅助数组存储当前状态的位置,简化now值的求得. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N=355;int n,m,a[N],c[5],t,f[45][45][45][45],l[45][45][45][45]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;=m;i++) { cin&gt;&gt;t; c[t]++; } l[1][1][1][1]=1; f[1][1][1][1]=a[1]; for(int i=1;i&lt;=c[1]+1;i++) { for(int j=1;j&lt;=c[2]+1;j++) { for(int k=1;k&lt;=c[3]+1;k++) { for(int q=1;q&lt;=c[4]+1;q++) { if(i==1 &amp;&amp; j==1 &amp;&amp; k==1 &amp;&amp; q==1) continue; int &amp;t_n=f[i][j][k][q],&amp;l_n=l[i][j][k][q]; int t1=f[i-1][j][k][q],t2=f[i][j-1][k][q], t3=f[i][j][k-1][q],t4=f[i][j][k][q-1]; int l1=l[i-1][j][k][q],l2=l[i][j-1][k][q], l3=l[i][j][k-1][q],l4=l[i][j][k][q-1]; if(t1+a[l1+1]&gt;t_n &amp;&amp; i!=1) { t_n=t1+a[l1+1]; l_n=l1+1; } if(t2+a[l2+2]&gt;t_n &amp;&amp; j!=1) { t_n=t2+a[l2+2]; l_n=l2+2; } if(t3+a[l3+3]&gt;t_n &amp;&amp; k!=1) { t_n=t3+a[l3+3]; l_n=l3+3; } if(t4+a[l4+4]&gt;t_n &amp;&amp; q!=1) { t_n=t4+a[l4+4]; l_n=l4+4; } } } } } printf(&quot;%d\\n&quot;,f[c[1]+1][c[2]+1][c[3]+1][c[4]+1]); return 0;} Note 本题由于需要用到任意卡片为0时的状态,将数组的数据整体偏移.防止数组下标越界(-1).","link":"/2021/02/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1541-%5BNOIP2010-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E4%B9%8C%E9%BE%9F%E6%A3%8B/"},{"title":"【题解】P1552 [APIO2012]派遣","text":"Des P1552 [APIO2012]派遣 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 题目背景 在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。 题目描述 在这个帮派里，有一名忍者被称之为Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。 现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。 你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。 写一个程序，给定每一个忍者i的上级Bi，薪水Ci，领导力Li，以及支付给忍者们的薪水总预算M，输出在预算内满足上述要求时顾客满意度的最大值。 输入格式 第一行包含两个整数N和M，其中N表示忍者的个数，M表示薪水的总预算。 接下来N行描述忍者们的上级、薪水以及领导力。其中的第i行包含三个整数Bi,Ci,Li分别表示第i个忍者的上级，薪水以及领导力。Master满足Bi=0，并且每一个忍者的老板的编号一定小于自己的编号Bi&lt;i。 输出格式 输出一个数，表示在预算内顾客的满意度的最大值。 Sol 本题的数据满足树形关系. 询问子树的根节点的值与子树上最多能选的节点的个数的乘积的最值. 每个节点影响答案的信息只有二维(权值为 1 ,开销为 Bi), 满足贪心关系, 即每次选开销最小的节点最优. 很容易想到, 如果只能选根节点作为管理者, 那么本题可以 \\(O(n\\log n)\\) 排序做. 节点是树形结构, 答案来源具有重叠性, 所以考虑用类似树形 DP 的思想更新每个节点的答案. 考虑从下至上推出答案. 维护一个序列, 在每一层都将该层的节点加入序列. 并保证序列是不下降的. 这一步显然是一个平衡树的基础操作(但我不会写). 维护一个答案指针与一个和, 若新加入的数大于答案指针指向的数, 尝试后移指针. 如果新加入的数小于答案指针指向的数, 更新和. 如果和超过总费用, 前移指针. 由于每个数最多会造成答案指针的一次操作, 更新一次平衡树. 所以总复杂度 \\(O(n \\log n)\\). 上面的方法就是我不会平衡树但是想出来的平衡树做法, 明明是在做左偏树的题啊 Orz... 思考一下所谓\"可并堆\", 既然要合并, 那左偏树的做法应该也是从下往上更新答案的. 而不是从大的树\"裂开\". 刚刚平衡树的做法提醒了我! 既然正解的复杂度是 \\(O(n\\log n)\\) 或者 \\(O(n\\log^2 n)\\), 那就应该与每个数的操作有关系, 而不是一昧的去合并大树. 那么, 正解呼之欲出了! 卒. 仍然没想出可并堆的做法. 看完题解, 反思了一下, 主要是我总是把可并堆当作\"一整块\", 认为它只能合并. 其实, 可并堆完全支持普通堆的操作, 一个一个删除也是完全可以的! 所以, 只需要将父亲节点的堆与所有儿子节点的进行合并, 并维护堆的总费用. 如果超过了容量就弹出堆顶元素. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5;int n,m;int b[N],c[N];ll l[N],sum[N],cnt[N],ans;vector&lt;int&gt; g[N];namespace hp { #define ls c[x].l #define rs c[x].r struct node { int val,f,l,r,d; }c[N]; int find(int x) { if(c[x].f!=x) c[x].f=find(c[x].f); return c[x].f; } int merge(int x,int y) { if(!x||!y) return x+y; if(c[x].val&lt;c[y].val) swap(x,y); rs=merge(rs,y); if(c[ls].d&lt;c[rs].d) swap(ls,rs); c[ls].f=c[rs].f=x,c[x].d=c[rs].d+1; return x; } void del(int x) { c[x].val=-1,c[ls].f=ls,c[rs].f=rs,c[x].d=0; c[x].f=merge(ls,rs); }}void dfs(int u) { int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; dfs(v); hp::merge(hp::find(u),hp::find(v)); sum[u]+=sum[v]; cnt[u]+=cnt[v]; } int top=-1; while(sum[u]&gt;m &amp;&amp; top!=0) { top=hp::find(u); sum[u]-=hp::c[top].val; hp::del(top); cnt[u]--; } ans=max(ans,l[u]*cnt[u]);}int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); hp::c[0].d=-1; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%lld&quot;,&amp;b[i],&amp;c[i],&amp;l[i]); if(b[i]!=0) g[b[i]].push_back(i); hp::c[i].val=sum[i]=c[i],cnt[i]=1; hp::c[i].f=i; } for(int i=1;i&lt;=n;i++) { if(b[i]==0) { dfs(i); } } printf(&quot;%lld&quot;,ans); return 0;} Note 题解里很多做法都用了一个 id[] 数组来记录每个节点所在的堆. 每次只更新一个点当然可以这样做, find() 函数还是更通用. 可以用斜堆过","link":"/2021/04/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1552-%5BAPIO2012%5D%E6%B4%BE%E9%81%A3/"},{"title":"【题解】P1640 [SCOI2010]连续攻击游戏","text":"Des lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww遇到了终极boss，这个终极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此类推。现在lxhgww想知道他最多能连续攻击boss多少次？ Sol 每个装备只能用一次，但是有 2 个属性值，很明显的“点只选一个”的二分图匹配的特征。必须满足的是属性值连续。说明可以把属性值当作左部，装备 id 当作右部进行二分图匹配。只要有一次匹配不到就结束。 My code 之前做是用贪心乱搞的，代码就懒得写了。","link":"/2021/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1640-%5BSCOI2010%5D%E8%BF%9E%E7%BB%AD%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F/"},{"title":"【题解】P1868 饥饿的奶牛+P2439 [SDOI2005]阶梯教室设备利用","text":"Des P1868 饥饿的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P2439 SDOI2005]阶梯教室设备利用 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Sol 将草地的位置当作状态,满足无后效性,且完整记录状态.DP方程为\\(f[i]=max(f[i-1],f[a[p].x]+a[p].y-a[p].x+1)\\).其中\\(a[p]\\)表示\\(y=i\\)的所有草块. 第二道题与第一道不能说很像,只能说完全一样.只不过细节有变. My code 饥饿的奶牛 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,Y=3e4+5;int n,f[Y];struct grass{ int x,y;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; }bool cmp(const grass &amp;m,const grass &amp;q){ return m.y&lt;q.y;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i].x=read();a[i].y=read(); a[i].x++,a[i].y++; } sort(a+1,a+n+1,cmp); int p=1; for(int i=1;i&lt;=a[n].y;i++) { f[i]=f[i-1]; while(a[p].y==i) { f[i]=max(f[i],f[a[p].x]+a[p].y-a[p].x); p++; } } printf(&quot;%d\\n&quot;,f[a[n].y]); return 0;} 阶梯教室设备利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,Y=3e4+5;int n,f[Y];struct grass{ int x,y;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; }bool cmp(const grass &amp;m,const grass &amp;q){ return m.y&lt;q.y;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i].x=read();a[i].y=read(); a[i].x++,a[i].y++; } sort(a+1,a+n+1,cmp); int p=1; for(int i=1;i&lt;=a[n].y;i++) { f[i]=f[i-1]; while(a[p].y==i) { f[i]=max(f[i],f[a[p].x]+a[p].y-a[p].x);//唯一的区别 p++; } } printf(&quot;%d\\n&quot;,f[a[n].y]); return 0;}","link":"/2021/02/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1868%20%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B/"},{"title":"【题解】P1896 [SCOI2005]互不侵犯","text":"Des 在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 Sol 换写法真的很难受啊Orz......不想换写法 所以就自己调了好久,按照广场铺砖差不多的写法写出来了,具体看代码吧应该还是很好懂的 谁能想到,调了许久,竟是因为位运算操作错了. 获取某个数的第b位应该用这个:int bit(int a,int b) {return (a&gt;&gt;b)&amp;1;} My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;typedef long long ll;using namespace std;const int N=12,S=1&lt;&lt;9;int n,k,s;ll f[N][S][N];ll ans;inline int bit(int a,int b) {return (a&gt;&gt;b)&amp;1;}inline int set1(int s,int i) {return s|(1&lt;&lt;i);}void dfs(int i,int s1,int s2,int d,int q1,int q2) { if(bit(s1,d)==1 &amp;&amp; bit(s1,d+1)==1) return; //如果d,d+1都有 if(d&gt;0 &amp;&amp; (bit(s1,d-1)==1) &amp;&amp; (bit(s1,d)==1)) return; //如果d-1和d都有 if(d&gt;=n) {f[i+1][s2][q2]+=f[i][s1][q1];return;} //统计答案 //如果国王能攻击到下一排的本位置 if(bit(s1,d)==1 || (bit(s1,d+1)==1)) dfs(i,s1,s2,d+1,q1,q2); //如果国王能攻击到下一排的本位置 else if(d&gt;0 &amp;&amp; bit(s1,d-1)==1) dfs(i,s1,s2,d+1,q1,q2); else { //2种选择 dfs(i,s1,s2,d+1,q1,q2); if(q2&lt;k) dfs(i,s1,set1(s2,d),d+2,q1,q2+1); }}int main() { cin&gt;&gt;n&gt;&gt;k; f[1][0][0]=1,s=1&lt;&lt;n; dfs(1,0,0,0,0,0); for(int i=2;i&lt;=n;i++) { for(int q=0;q&lt;=k;q++) { for(int j=0;j&lt;s;j++) { if(f[i][j][q]) dfs(i,j,0,0,q,q); } } } for(int j=0;j&lt;s;j++) ans+=f[n+1][j][k]; cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note OI-wiki 的代码还没我的跑得快.","link":"/2021/03/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1896-%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"},{"title":"【题解】P1950 长方形","text":"Des P1950 长方形 Sol 做这道题的路途真是曲折... 何以见得 从3月2号下午做到现在,不过,也收获了许多. 最开始的想法是受到了P4933 大师的启发,这道题的答案与每个等差数列的长度密不可分,并且会发现一个规律:等差数列的长度每增加1,能选的方案数会增加l(等差数列当前的长度).那么套到这道题上,一个\"能选\"的矩形(全为'.'的矩形)的长度和宽度的增加也会带来能选方案数的增加. 123456示例1:. .. ... ----矩形1 3 6 ----方案数. .. .... .. ...3 9 18 上面示例的每种矩形带来的方案数是有规律的,变化量也有规律,具体是什么我就不说了.既然变化量有规律,我们能不能求出新加入一个点对原来方案的贡献呢?新加入的点可以与它左上方(只计算左上方,避免重复)的点构成矩形,那么计算每个点的贡献就行. 如果想到这一步,离正解就不远了.遗憾的是,我被上一道题的解法限制住了,我错误地只计算了每个点在左上方的2个矩形区域的贡献(错误代码在My code #2).因为我可以按照规律方便地从这2个矩形区域更新答案,就像示例1那样. 在无数次得到10分后,我开始懊恼,但也下定了决心要AC这道题,而且不看题解.因为此题不能下载数据,我的进展停滞了.但今天早上我想到了把题解的程序拿来对拍,这是我的对拍程序(.bat文件): 123456789@echo off:loopmakedata.exezhengjie.exe &lt; data.in &gt; test1.outmycode.exe &lt; data.in &gt; test2.outfc test1.out test2.outif not errorlevel 1 goto looppause:end 只用更改makedata.exe zhengjie.exe mycode.exe 的名称即可使用.在对拍的过程中,我遇到了这样的数据,发现了我算法的致命错误: 1234示例2:**.*..... 按照我的算法,我只会统计最右边一列和最下面一行的矩形,并且如果在原有基础上改进算法就会超时了. 考虑新的解题方案.仍然是计算每个点的贡献.观察示例2,计算(3,3)这个点的贡献,显然它可以与(3,1),(3,2),(3,3),(2,2),(2,3),(1,3)这几个点组成矩形(将2个点作为矩形的左上定点和右下顶点),贡献为6.那么,唯一的问题就是如何方便的计算这些点个数的总和. 1234示例3:*..**.... 在示例3中,仍然计算(3,3)的贡献,并考虑暴力算法.不难想出,先跑一遍矩阵前缀和,用于求出以(x1,y1),(x2,y2)为矩形的2个顶点的矩形内部有多少个'.',即判断该矩形能否选择.然后枚举(3,3)左上方的点看能否选择.不难发现,(1,2)这个点不能选择是因为(2,2)把它限制住了.再推广一点,(2,2)把它正上方的所有点都限制住了,使得它们不能选. 12345示例4:****......***....... 到了示例4,如果你学过单调队列,单调栈相关的内容,一定可以发现,(4,5)在每一行能选择的点的个数是单调递减的.从下往上枚举行数,便能用单调栈求出当前行能选的点数.问题要求我们求方案总和,在单调栈内维护一个sum即可,有了sum,也得有单点的权值(比如5把7更新了,那么sum=sum-2,5的权值也得变为2来代表5和7两个元素).最后写出代码即可.如果对于\"权值\"没有理解,可以纸上模拟这组数据(要求:给出可用的更新sum的方案): 14 2 2 2 1 //当前行能选的点数 My code #1 AC 100 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1005;ll n,m,sum,ans,q[N],p,w[N],l[N][N];char s[N][N];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,s[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(s[i][j]=='*') l[i][j]=0; else l[i][j]=l[i][j-1]+1; for(int i=1;i&lt;=m;i++) { p=0; sum=0; for(int j=1;j&lt;=n;j++) { int now=1; if(s[j][i]=='*') { p=sum=0; continue; } while(l[j][i]&lt;=q[p]) { sum+=(l[j][i]-q[p])*w[p]; now+=w[p--]; } q[++p]=l[j][i],w[p]=now; sum+=l[j][i]; ans+=sum; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} #2 WA 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1005;ll n,m,ans,f[N],add[N][N];ll cl2[N][N],cp2[N][N],cl1[N][N],cp1[N][N];//continue_left,continue_upchar s[N][N];int main(){ //freopen(&quot;data.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;mycode.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; f[1]=1; for(int i=2;i&lt;=1000;i++) { f[i]=f[i-1]+i; } for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s[i]+1); } for(int i=1;i&lt;=n;i++) { if(s[i][1]=='.') cp1[i][1]=cp2[i][1]=cp1[i-1][1]+1; if(s[i][1]=='.') cl1[i][1]=cl2[i][1]=1; } for(int i=1;i&lt;=m;i++) { if(s[1][i]=='.') cp1[1][i]=cp2[1][i]=1; if(s[1][i]=='.') cl1[1][i]=cl2[1][i]=cl1[1][i-1]+1; } for(int i=2;i&lt;=n;i++)//计算 &quot;每个点的2个最大可贡献矩形&quot; { for(int j=2;j&lt;=m;j++) {// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; if(s[i][j]=='*') { cl1[i][j]=cp1[i][j]=0; cl2[i][j]=cp2[i][j]=0; continue; } if(s[i-1][j]=='*' || s[i][j-1]=='*') { if(s[i-1][j]=='*' &amp;&amp; s[i][j-1]!='*') { cp1[i][j]=cp2[i][j]=1; cl1[i][j]=cl2[i][j]=cl2[i][j-1]+1; } if(s[i][j-1]=='*' &amp;&amp; s[i-1][j]!='*') { cl1[i][j]=cl2[i][j]=1; cp1[i][j]=cp2[i][j]=cp1[i-1][j]+1; } if(s[i][j-1]=='*' &amp;&amp; s[i-1][j]=='*') { cl1[i][j]=cl2[i][j]=1; cp1[i][j]=cp2[i][j]=1; } continue; } else { cp1[i][j]=cp1[i-1][j]+1; cl1[i][j]=min(cl1[i][j-1]+1,cl1[i-1][j]); cp2[i][j]=min(cp2[i-1][j]+1,cp2[i][j-1]); cl2[i][j]=cl2[i][j-1]+1; } } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) {// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;// cout&lt;&lt;cp1[i][j]&lt;&lt;' '&lt;&lt;cl1[i][j]&lt;&lt;' '&lt;&lt;cp2[i][j]&lt;&lt;' '&lt;&lt;cl2[i][j]&lt;&lt;endl; if(s[i][j]=='*') continue; add[i][j]=cp1[i][j]*cl1[i][j]+cp2[i][j]*cl2[i][j] -min(cp1[i][j],cp2[i][j])*min(cl1[i][j],cl1[i][j]); ans+=add[i][j]; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/"},{"title":"【题解】P1966 [NOIP2013 提高组] 火柴排队","text":"Des 描述 涵涵有两盒火柴，每盒装有 \\(n\\) 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：$ (a_i-b_i)^2$ 其中 \\(a_i\\) 表示第一列火柴中第 \\(i\\) 个火柴的高度，\\(b_i\\) 表示第二列火柴中第 \\(i\\) 个火柴的高度。 每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 \\(10^8-3\\) 取模的结果。 样例输入 12341 3 4 21 7 2 4 样例输出 12 Sol 对于任意一个\\(a_i\\),选择使得\\(abs(a_i-b_j)\\)最小的\\(b_j\\)才能满足答案最优. 将原来的2队火柴排序,此时\\(b_i\\)使得\\(abs(a_i-b_i)\\)最小. 那么,火柴\\(b_i\\)只需要移动到排序前火柴\\(a_i\\)的位置.这里的移动可看作是从无序到有序的过程.选用恰当的方法算出移动步数即可(树状数组求逆序对). My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define INF 1e9using namespace std;const int N=1e5+5,P=1e8-3;int n,p[N];struct match{ int h,idx; bool operator &lt; (const match &amp;b) const { return h&lt;b.h; }};match a[N],b[N];struct BIT{ int tree[N&lt;&lt;3]; int lowbit(int x) { return x&amp;(-x); } void update(int x,int k) { while(x&lt;=n) { tree[x]+=k; tree[x]%=P; x+=lowbit(x); } } int query(int x) { int ans=0; while(x&gt;0) { ans+=tree[x]; x-=lowbit(x); } return ans; }}t;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i].h=read(),a[i].idx=i; } for(int i=1;i&lt;=n;i++) { b[i].h=read(),b[i].idx=i; } sort(a+1,a+n+1); sort(b+1,b+n+1); for(int i=1;i&lt;=n;i++) { p[a[i].idx]=b[i].idx; } long long ans=0; for(int i=1;i&lt;=n;i++) { t.update(p[i],1); ans+=i-t.query(p[i]); ans%=P; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note 忘了取模!","link":"/2021/03/16/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1966-%5BNOIP2013-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/"},{"title":"【题解】P1972 [SDOI2009]HH的项链","text":"Des HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。 有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 Sol 最开始看到这个题，我其实是非常滴愉悦的。因为求不同种贝壳 = 求同种贝壳数量是否等于 1。明显具有”区间可加性“，但是看到数据范围 \\(n\\le10^6\\) 直接傻眼了。不管是分块还是莫队都没法做（我本来想做莫队板题的emm）。既然本题被某管理员无良加强了，就来看看其他做法。 分块和莫队都在强调整体的答案，以及用散块的数据更新整体的答案。但是这样做的极限显然就是 \\(O(n \\sqrt n)\\) 了。我们把眼光放回到单个数对答案产生的贡献。假设一个区间有许多相同的数，它们总共对答案的贡献总共仅为 1，不妨将这个贡献转移到第一个数上。具体来说，我们为每一个数 a[i] 求出 last[i]，存储上一个等于 a[i] 的数的位置。如果这个位置小于 l，那么这个点对答案就产生不了贡献，反之可以。也就是说，我们把问题转化为了区间求大于等于 l 的数。显然可以用主席树求解。 但是，上面的做法都太俗了，有一种机智叫做“洛谷题解”。它告诉你这道题可以用树状数组求解！ 上面用主席树求解的方法，是将贡献转移到了第一个数上。如果能找到一种转移方式，甚至是更换转移的方式（毕竟这道题是在线的），使得我们可以直接用线段树或树状数组来进行区间贡献求和，那么问题不就迎刃而解了吗！ 这个想法的难点在于询问的区间是杂乱无章的，每次询问都有可能带来 \\(O(n)\\) 的“转换转移”。又因为本题的信息仍然是可加的，考虑类似莫队做法，将询问排序。如果询问的右端点为 r，那么只需知道 r 左边第一个数的位置，也就是说，将贡献转移到 r 以内最后一个相等的数上。每次移动右端点判断此数是否与之前的数相等，如果是，就将之前的数的贡献撤销，转移到现在的树上。如果有询问，就输出 query(r)-query(l-1)。 个人认为，本题的加强并无太大意义。树状数组的做法实在是过于巧妙（至少对我来说），并且不具有较强的可拓展性。 UPD on 210512： 果然每过一段时间，对之前的东西就会有不同的看法（虽然才过 20 天而已）。 之前我说此题的做法不具有可拓展性，其实错了。在逛讨论区的时候，我看到又有人在讨论怎么用莫队艹过 HH 的项链，恰好又在看 这道题。我就想，HH 的项链不也可以用动态开点平衡树做吗？实际上我理解错了，HH 的项链求的是不同种类的个数，P3313 [SDOI2014]旅行 需要求同种类的城市的加和。 回到这道题，最直观的想法显然是用类似 蒲公英 那道题的方法求出区间内每个贝壳的个数，判断是否大于等于 1. 但是这样的冗杂信息显然很多，因为我并不需要知道每个贝壳具体的个数，只需要知道它有没有。我们给每个点记录一个上一次出现它的颜色的位置 last[i]，这样，只需要求出 \\(\\sum_{i=l}^r[last(i)&lt;l]\\) 就好了，这个东西可以用树套树求解。 但是由于本题支持离线且没有插入操作，所以可以排序询问，有了上面 BIT 的做法。 My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e6+5;int n,m,a[N],ans[N],last[N],pos[N];struct query { int l,r,idx; bool operator &lt; (const query &amp;b) const {return r&lt;b.r;};}q[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace BIT { int c[N]; int lowbit(int x) {return x&amp;(-x);} int query(int x) {int sum=0;while(x){sum+=c[x];x-=lowbit(x);}return sum;} void update(int x,int k) {if(x==0) return;while(x&lt;=n){c[x]+=k;x+=lowbit(x);}}}int main() { n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); last[i]=pos[a[i]]; pos[a[i]]=i; } m=read(); for(int i=1;i&lt;=m;i++) { q[i].l=read(),q[i].r=read(),q[i].idx=i; } sort(q+1,q+m+1); int p=0; for(int i=1;i&lt;=m;i++) { while(p&lt;q[i].r) { BIT::update(++p,1); BIT::update(last[p],-1); } ans[q[i].idx]=BIT::query(q[i].r)-BIT::query(q[i].l-1); } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;}","link":"/2021/04/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1972-%5BSDOI2009%5DHH%E7%9A%84%E9%A1%B9%E9%93%BE/"},{"title":"【题解】P2014 [CTSC1997]选课","text":"Des 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 \\(N\\) 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 \\(M\\) 门课程学习，问他能获得的最大学分是多少？ Sol 本题输入数据为森林,可以用一个虚拟节点作为所有树的根. 和二叉苹果树比较像,本题也有选择节点(边)的数量限制.那么,数量就成了必须保存的信息.用背包的思想转移数量即可. My code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N=305;int n,m,w[N],f[N][N];vector&lt;int&gt; g[N];void dp(int u){ int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; dp(v); for(int j=m+1;j&gt;=1;j--) { for(int k=1;k&lt;j;k++) { f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); } } }}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { int k; cin&gt;&gt;k&gt;&gt;f[i][1]; g[k].push_back(i); } dp(0); cout&lt;&lt;f[0][m+1]&lt;&lt;endl; return 0;}","link":"/2021/03/22/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2014-%5BCTSC1997%5D%E9%80%89%E8%AF%BE/"},{"title":"【题解】P2015 二叉苹果树","text":"Des 有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点） 这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。 我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树 123452 5 \\ / 3 4 \\ / 1 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量，求出最多能留住多少苹果。 Sol 这道题做得真的是疑惑又头疼...... 根据个人理解,本题的题面实际上是有些问题的.假设输入数据前后输入了多颗树,最后才把这几颗树连接起来,那么如果不知道父子关系,答案就不唯一. 洛谷的数据出现了这种情况,但所有数据默认第二个节点是第一个节点的父亲,才没有混淆.所以就有了下面连样例都过不了但是能AC的代码. 我认为,应该更改题面和样例,确定第二个节点是第一个节点的儿子.或者更改数据,除了输入根,让每次输入的节点至少有一个是之前输入过的. 确定了根,答案就是唯一的.只不过我使用的方法并不正确.应该使用邻接表存图,特判父亲.可惜洛谷太水,下面的代码也能过. 回到本题解法. 保留一个节点可以看作是多保留了一些树枝,那么记录树枝数量就可完整保留信息.设将边权转到了儿子上.DP方程为\\(f[u][j]=f[ls[u]][k]+f[rs[u]][j-k-1]+w[u]\\), My code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,q;int father[N],f[N][N];struct node{ int l,r,w;}a[N]; int dp(int u,int sz){ if(f[u][sz]) return f[u][sz]; if(u==0 || sz==0) return 0; if(a[u].l==0 &amp;&amp; a[u].r==0) return a[u].w; for(int i=0;i&lt;sz;i++) { f[u][sz]=max(f[u][sz],dp(a[u].l,i)+dp(a[u].r,sz-i-1)+a[u].w); } return f[u][sz];}int main(){ cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;n;i++) { int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; father[v]=u; a[v].w=w; if(a[u].l==0) a[u].l=v; else a[u].r=v; } cout&lt;&lt;dp(1,q+1)&lt;&lt;endl; return 0;}","link":"/2021/03/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2015-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/"},{"title":"【题解】P2016 战略游戏","text":"Des Bob要建立一个古城堡，城堡中的路形成一棵无根树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。 注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。 请你编一程序，给定一树，帮 Bob 计算出他需要放置最少的士兵。 Sol 普通树形DP.由子节点的状态决定父节点的状态.如果子节点选,父节点可选课不选.如果子节点不选,父节点必须选. My code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1505;int n;int f[N][2];//0表示不放 1表示放 vector&lt;int&gt; g[N];void dp(int u,int fa){ int len=g[u].size(); f[u][1]=1; for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(v==fa) continue; dp(v,u); f[u][0]+=f[v][1]; f[u][1]+=min(f[v][1],f[v][0]); }}int main(){ cin&gt;&gt;n; int k,u,v; for(int i=0;i&lt;n;i++) { cin&gt;&gt;u&gt;&gt;k; for(int j=1;j&lt;=k;j++) { cin&gt;&gt;v; g[u].push_back(v),g[v].push_back(u); } } dp(0,-1); cout&lt;&lt;min(f[0][0],f[0][1])&lt;&lt;endl; return 0;}","link":"/2021/03/22/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2016-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/"},{"title":"【题解】P2042 [NOI2005] 维护数列","text":"Des 请写一个程序，要求维护一个数列，支持以下 \\(6\\) 种操作： 编号 名称 格式 说明 1 插入 \\(\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}\\) 在当前数列的第 \\(posi\\) 个数字后插入 \\(tot\\) 个数字：\\(c_1, c_2 \\cdots c_{tot}\\)；若在数列首插入，则 \\(posi\\) 为 \\(0\\) 2 删除 \\(\\operatorname{DELETE} \\ posi \\ tot\\) 从当前数列的第 \\(posi\\) 个数字开始连续删除 \\(tot\\) 个数字 3 修改 \\(\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c\\) 从当前数列的第 \\(posi\\) 个数字开始的连续 \\(tot\\) 个数字统一修改为 \\(c\\) 4 翻转 \\(\\operatorname{REVERSE} \\ posi \\ tot\\) 取出从当前数列的第 \\(posi\\) 个数字开始的 \\(tot\\) 个数字，翻转后放入原来的位置 5 求和 \\(\\operatorname{GET-SUM} \\ posi \\ tot\\) 计算从当前数列的第 \\(posi\\) 个数字开始的 \\(tot\\) 个数字的和并输出 6 求最大子列和 \\(\\operatorname{MAX-SUM}\\) 求出当前数列中和最大的一段子列，并输出最大和 \\(\\texttt{Data Range:}\\) 你可以认为在任何时刻，数列中至少有 \\(1\\) 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 对于 \\(50\\%\\) 的数据，任何时刻数列中最多含有 \\(3 \\times 10^4\\) 个数。 对于 \\(100\\%\\) 的数据，任何时刻数列中最多含有 \\(5 \\times 10^5\\) 个数，任何时刻数列中任何一个数字均在 \\([-10^3, 10^3]\\) 内，\\(1 \\le M \\le 2 \\times 10^4\\)，插入的数字总数不超过 \\(4 \\times 10^6\\)。 Sol 前 5 种操作还好说，6 是什么鬼？ 其实我清晰的记得不带修的操作 6 的线段树做法，就是维护一个区间从右端点开始的和最大的子串（虽然子串好像是形容字符串的，但是也不能说子序列啊）、从左端点开始的和最大的子串以及和最大的子串。 这个做法在向上合并的时候感觉有些问题，为什么局部的最优解可以产生全局最优解呢？莫非这算作一个贪心做法？ 其实可以简单理解一下： 上图横着的线段代表整个序列，方框代表最长的子串。[l,r] 的 smax（整区间最优）= l,mid 的 rmax（从右端点开始最优）+ mid+1,r 的 lmax（从左端点开始最优）。也就是说，整体的最优解必然可以组合为局部最优解。或者，局部最优解就是整体最优解。 也就是说，最后的答案按照我们的分治策略还原回去，可以到达最小的区间的局部最优解。 上述方法在用线段树回答多次询问时是 \\(O(n \\log n)\\) 的，但如果只求一个区间的和最大子串，还有 \\(O(n)\\) 的方法： 1234567891011121314int n, sum, minSum, ans;int main() { cin &gt;&gt; n; for(int i = 1, t; i &lt;= n; i++) { cin &gt;&gt; t; sum += t; minSum = min(sum, minSum); ans = max(ans, sum - minSum); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 虽然扯得有点远，但无妨！ 话说，平衡树为什么能维护区间信息呢？ 用 C++ lib for Grahviz 输出了一下，发现用下标建好的平衡树是这样的 发现了吗？一颗子树代表的永远是一个连续的区间。 其实这很好理解：下标是连续的，一个节点的左子树的所有节点代表的下标比自己小，右子树则比自己大。 也就是说，我们可以在平衡树上做到线段树能做的所有 pushUp 操作。 但是还有一个关于 pushDown 的问题：为了避免两次更新同一个区间，线段树会在访问到一个整块区间时，直接更新该区间的 val，然后打上 tag。也就是说，最大的整块区间是需要我们写一些操作来更新的（我昨天发现我一直没理解清楚 pushDown 的时候简直震惊了）。 然后本题还有一些问题： 1. 内存不够 一个 \\(4\\times 10^6\\) 的数组需要 16MB 的空间，我们需要 10 多个这样的数组，空间并不够。 但是，任何时刻数列中最多含有 \\(5\\times 10^5\\) 个数，可以用内存回收机制存下已经被删除的数。即将被删除的子树分裂出来后，执行这样的操作： 12345void memDel(int u) { // 内存回收 mem.push(u); if(lc(u)) memDel(lc(u)); if(rc(u)) memDel(rc(u));} 其中 mem 是一个栈。 在 newNode 时，如果动态内存池（mem）可以分配内存，就使用动态内存，否则 ++tot。 2. 插入数字会超时？ 并不，最多 \\(4\\times 10^6 \\log 5\\times 10^5\\)，大概是 7000 万的样子。但是，考虑到 fhq-treap ins 函数极大的常数（以及实践证明），会 TLE。 一次 ins 会先执行一次 split，\\(\\log 5\\times 10^5\\) 是没跑了的。考虑优化。 题解里看到一个这样的建树方式： 123456789int add(int l, int r) { int pos = 0; if(l != r) { int mid = (l + r) &gt;&gt; 1; return merge(add(l, mid), add(mid + 1, r)); } newNode(pos, input[l]); return pos;} 我寻思这不需要执行 n 次 merge？ 但是由于很多 merge 的 2 棵树的深度很小，所以是能卡过的。 于是，我写了一个“更好”的建树函数，用时成功超过题解！ 12345678910111213int add(int l, int r) { int pos = 0; if(l &gt; r) return 0; if(l == r) newNode(pos, input[l]); else { int mid = (l + r) &gt;&gt; 1; newNode(pos, input[mid]); lc(pos) = add(l, mid - 1); rc(pos) = add(mid + 1, r); update(pos); } return pos;} 3. 关于翻转和推平 tag 推平操作可以写成一个函数，对 2 个儿子分别操作。因为推平与兄弟无关。 但翻转操作必须在父节点进行。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 5e5 + 5;int n, m, input[N];namespace treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], val[N], sum[N], rnd[N], sz[N], rt, tot; int rtag[N], ctag[N], cov[N]; // reverse tag, change tag int lx[N], rx[N], mx[N]; void update(int x) { if(!x) return; sz[x] = sz[lc(x)] + sz[rc(x)] + 1; sum[x] = sum[lc(x)] + sum[rc(x)] + val[x]; mx[x] = max(rx[lc(x)] + lx[rc(x)], 0) + val[x]; if(lc(x)) mx[x] = max(mx[x], mx[lc(x)]); if(rc(x)) mx[x] = max(mx[x], mx[rc(x)]); lx[x] = max(max(lx[lc(x)], sum[lc(x)] + val[x] + lx[rc(x)]), 0); rx[x] = max(max(rx[rc(x)], sum[rc(x)] + val[x] + rx[lc(x)]), 0); } stack &lt;int&gt; mem; void memDel(int u) { // 内存回收 mem.push(u); if(lc(u)) memDel(lc(u)); if(rc(u)) memDel(rc(u)); } void newNode(int &amp;t, int x, int pos = 0) { if(mem.empty()) pos = ++tot; else pos = mem.top(), mem.pop(); val[pos] = sum[pos] = mx[pos] = x, sz[pos] = 1, rnd[pos] = rand(); rtag[pos] = ctag[pos] = lc(pos) = rc(pos) = 0; lx[pos] = rx[pos] = max(x, 0); t = pos; } inline void reverse(int x) { if(!x) return; swap(lx[x], rx[x]); } void change(int x, int c) { if(!x) return; val[x] = cov[x] = c; sum[x] = val[x] * sz[x]; lx[x] = rx[x] = max(0, sum[x]); mx[x] = max(c, sum[x]); } void pushDown(int x) { if(!x) return; if(rtag[x]) { reverse(lc(x)), reverse(rc(x)); if(lc(x)) rtag[lc(x)] ^= 1; if(rc(x)) rtag[rc(x)] ^= 1; swap(lc(x), rc(x)); rtag[x] = 0; } if(ctag[x]) { change(lc(x), cov[x]), change(rc(x), cov[x]); if(lc(x)) ctag[lc(x)] = 1; if(rc(x)) ctag[rc(x)] = 1; ctag[x] = cov[x] = 0; } } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { pushDown(x); rc(x) = merge(rc(x), y); update(x); return x; } else { pushDown(y); lc(y) = merge(x, lc(y)); update(y); return y; } } void split(int p, int v, int &amp;x, int &amp;y) { if(!p) { x = y = 0; return; } pushDown(p); if(sz[lc(p)] &lt; v) { x = p; split(rc(x), v - sz[lc(x)] - 1, rc(x), y); } else { y = p; split(lc(y), v, x, lc(y)); } update(p); } int add(int l, int r) { int pos = 0; if(l &gt; r) return 0; if(l == r) newNode(pos, input[l]); else { int mid = (l + r) &gt;&gt; 1; newNode(pos, input[mid]); lc(pos) = add(l, mid - 1); rc(pos) = add(mid + 1, r); update(pos); } return pos; }}using namespace treap;int main() { ios::sync_with_stdio(false); cin.tie(0); srand(time(0)); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; input[i]; rt = add(1, n); string op; int pos, t; for(int i = 1, x, a, b, c; i &lt;= m; i++) { cin &gt;&gt; op; if(op[2] != 'X') cin &gt;&gt; pos &gt;&gt; t; if(op[2] == 'S') { split(rt, pos, a, b); for(int i = 1; i &lt;= t; i++) cin &gt;&gt; input[i]; rt = merge(merge(a, add(1, t)), b); } else if(op[2] == 'L') { split(rt, pos - 1, a, b), split(b, t, b, c); memDel(b); rt = merge(a, c); } else if(op[2] == 'K') { cin &gt;&gt; x; split(rt, pos - 1, a, b), split(b, t, b, c); change(b, x), ctag[b] = 1; rt = merge(a, merge(b, c)); } else if(op[2] == 'V') { split(rt, pos - 1, a, b), split(b, t, b, c); swap(lx[b], rx[b]), rtag[b] ^= 1; rt = merge(a, merge(b, c)); } else if(op[2] == 'T') { split(rt, pos - 1, a, b), split(b, t, b, c); cout &lt;&lt; sum[b] &lt;&lt; endl; rt = merge(a, merge(b, c)); } else cout &lt;&lt; mx[rt] &lt;&lt; endl; } return 0;} Note 交了 77 次，用时最久的一道题（大概一天）。 中间因为 treap 的随机性无数次看脸 AC，而且因为“逻辑正确”的代码始终有问题一直纠结。 最后发现是少写了一句 swap(lx[b], rx[b])。 终于，AC 了。","link":"/2021/05/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2042-%5BNOI2005%5D-%E7%BB%B4%E6%8A%A4%E6%95%B0%E5%88%97/"},{"title":"【题解】P2058 [NOIP2016 普及组] 海港","text":"Des 描述 小K是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。 小K对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第i艘到达的船，他记录了这艘船到达的时间ti (单位：秒)，船上的乘 客数\\(k_i\\)，以及每名乘客的国籍 \\(x_{i,1}, x_{i,2},…,x_{i,k}\\)。 小K统计了\\(n\\)艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的\\(24\\)小时(\\(24\\)小时=\\(86400\\)秒）内所有乘船到达的乘客来自多少个不同的国家。 形式化地讲，你需要计算\\(n\\)条信息。对于输出的第\\(i\\)条信息，你需要统计满足$ t_i-86400&lt;t_p t_i\\(的船只\\)p\\(，在所有的\\)x_{p,j}$中，总共有多少个不同的数。 输入格式 第一行输入一个正整数\\(n\\)，表示小K统计了\\(n\\)艘船的信息。 接下来\\(n\\)行，每行描述一艘船的信息：前两个整数\\(t_i\\)和\\(k_i\\)分别表示这艘船到达海港的时间和船上的乘客数量，接下来\\(k_i\\)个整数\\(x_{i,j}\\)表示船上乘客的国籍。 保证输入的\\(t_i\\)是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第\\(t_i\\)秒到达海港。 保证 \\(1 \\le n \\le 10^5\\)，$ *10^5 $ ，\\(1\\le x(i,j) \\le 10^5\\)， \\(1 \\le t(i-1)\\le ti \\le 10^9\\)。 其中\\(\\sum{ki}\\)表示所有的\\(k_i\\)的和。 Sol 注意到数据范围,乘客的国籍是小于\\(10^5\\),给每个国籍建立一个桶,多一个人就往里装.如果当前桶里面没有人,\\(ans++\\).然后淘汰24小时前的人,如果桶里没人了,\\(ans--\\).24小时前的国籍信息用vector存. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,K=3e5+5;int n,lastT,p,cnt;int pass[N];struct ship{ int t,k; vector&lt;int&gt; per;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { int tmp; a[i].t=read(),a[i].k=read(); for(int j=1;j&lt;=a[i].k;j++) { tmp=read(); a[i].per.push_back(tmp); if(pass[tmp]==0) cnt++; pass[tmp]++; } if(i==1) lastT=a[i].t,p=1; while(a[i].t-86400&gt;=lastT) { int len=a[p].per.size(); for(int j=0;j&lt;len;j++) { int now=a[p].per[j]; pass[now]--; if(pass[now]==0) cnt--; } p++; lastT=a[p].t; } printf(&quot;%d\\n&quot;,cnt); } return 0;}","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2058-%5BNOIP2016-%E6%99%AE%E5%8F%8A%E7%BB%84%5D-%E6%B5%B7%E6%B8%AF/"},{"title":"【题解】P2234 [HNOI2002]营业额统计","text":"Des 给出一个 \\(n\\) 个数的数列 \\(\\{a_n\\}\\) ，对于第 \\(i\\) 个元素 \\(a_i\\)，定义 \\(f_i=\\min |a_i - a_j|\\)，其中 \\(1 \\le j &lt; i,f_1 = a_1\\)。求 \\(\\sum f_i\\)。 Sol 好嘛，乍一看就是求 \\(\\sum \\min(a_i-pre,nxt-a_i)\\)，但是这里的前驱与后继的定义有点不一样。如果有 \\(a_j = a_i\\)，那么 \\(a_j\\) 也算作 \\(a_i\\) 的前驱。 所以两种方案，一是写一个 find 函数特判存不存在，二是修改 nxt 与 pre 函数。 此处我选择第一种 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 1e5+5, INF = 1e9;ll ans;namespace treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], sz[N], val[N], rnd[N], tot, rt; void maintain(int p) {sz[p] = sz[lc(p)] + sz[rc(p)] + 1;} void newNode(int &amp;k, int x) { val[++tot] = x, sz[tot] = 1, rnd[tot] = rand(); lc(tot) = rc(tot) = 0; k = tot; } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { rc(x) = merge(rc(x), y); maintain(x); return x; } else { lc(y) = merge(x, lc(y)); maintain(y); return y; } } void split(int p, int v, int &amp;x,int &amp;y) { if(!p) { x = y = 0; return; } if(val[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); maintain(x); } else { y = p; split(lc(y), v, x, lc(y)); maintain(y); } } int kth(int u, int v) { if(v == sz[lc(u)] + 1) return val[u]; else if(v &lt;= sz[lc(u)]) return kth(lc(u), v); else return kth(rc(u), v - sz[lc(u)] - 1); } void ins(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); newNode(z, v); rt = merge(merge(x, z), y); } int pre(int &amp;rt, int v) { int x, y, ret; split(rt, v - 1, x, y); if(!x) return -INF; ret = kth(x, sz[x]); rt = merge(x, y); return ret; } int nxt(int &amp;rt, int v) { int x, y, ret; split(rt, v, x, y); if(!y) return INF; ret = kth(y, 1); rt = merge(x, y); return ret; } int find(int &amp;rt, int v) { int x = 0, y = 0, z = 0, ret = 0; split(rt, v, x, y); split(x, v-1, x, z); if(z) ret = 1; rt = merge(merge(x, z), y); return ret; }}using namespace treap;int main() { ios::sync_with_stdio(false); cin.tie(0); srand(time(0)); int n, x; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; if(i == 1) { ans += x; ins(rt, x); } else if(find(rt, x)) { ins(rt, x); } else { ans += min(x - pre(rt, x), nxt(rt, x) - x); ins(rt, x); } } cout &lt;&lt; ans; return 0;} Note 我恨 Splay，一堆奇怪的逻辑，莫名奇妙的死循环，不方便的拓展方式（pre 和 nxt 不完整）。 无旋 treap 一遍过赛高！","link":"/2021/05/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2234-%5BHNOI2002%5D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1/"},{"title":"【题解】P2286 [HNOI2004]宠物收养场","text":"Des 洛谷题面实在太丑了请到 loj 观赏 Sol 建立 2 颗 treap，分别对应观赏者与宠物。哪颗树非空就操作哪颗。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 8e4 + 5, P = 1e6;int ans;struct treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N][2], sz[N], val[N], rnd[N], tot, rt; void maintain(int x) {sz[x] = sz[lc(x)] + sz[rc(x)] + 1;} void newNode(int &amp;t, int x) { val[++tot] = x, sz[tot] = 1, rnd[tot] = rand(); lc(tot) = rc(tot) = 0; t = tot; } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { rc(x) = merge(rc(x), y); maintain(x); return x; } else { lc(y) = merge(x, lc(y)); maintain(y); return y; } } void split(int p, int v, int &amp;x, int &amp;y) { if(!p) x = y = 0; else if(val[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); maintain(x); } else { y = p; split(lc(y), v, x, lc(y)); maintain(y); } } void ins(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); newNode(z, v); rt = merge(merge(x, z), y); } void del(int &amp;rt, int v) { int x = 0, y = 0, z = 0; split(rt, v, x, y); split(x, v-1, x, z); z = merge(lc(z), rc(z)); rt = merge(merge(x, z), y); } int kth(int u, int k) { if(k == sz[lc(u)] + 1) return val[u]; else if(k &lt;= sz[lc(u)]) return kth(lc(u), k); else return kth(rc(u), k - sz[lc(u)] - 1); } int pre(int &amp;rt,int v) { int x = 0, y = 0, ret = 0; split(rt, v-1, x, y); if(!x) return -1; ret = kth(x, sz[x]); rt = merge(x, y); return ret; } int nxt(int &amp;rt,int v) { int x = 0, y = 0, ret = 0; split(rt, v, x, y); if(!y) return -1; ret = kth(y, 1); rt = merge(x, y); return ret; } void adopt(int v) { int a = pre(rt, v), b = nxt(rt, v); if(a == -1) del(rt, b), ans += b - v; else if(b == -1) del(rt, a), ans += v - a; else { if(v - a == b - v) del(rt, a); else if(v - a &gt; b - v) del(rt, b); else del(rt, a); ans += min(v - a, b - v); } ans %= P; }}pet, people;int main() { ios::sync_with_stdio(false); cin.tie(0); srand(time(0)); int n, op, x; cin &gt;&gt; n; while(n--) { cin &gt;&gt; op &gt;&gt; x; if(op == 0) { if(people.rt) people.adopt(x); else pet.ins(pet.rt, x); } else { if(pet.rt) pet.adopt(x); else people.ins(people.rt, x); } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2021/05/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2286-%5BHNOI2004%5D%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA/"},{"title":"【题解】P2294 [HNOI2005]狡猾的商人","text":"Des P2294 [HNOI2005]狡猾的商人 Sol 1 本题所谓的\"不合法\"其实只有一种情况:区间\\([l,r]\\)可存在多种不同的值.我这里说的值,指的是完全相同的区间,哪怕差了,或多了一个元素也不行. 一个区间的值可以由多个区间拼接得到,我们要做得就是尝试进行这个拼接. Sol 2 本题含有等量关系,即几个月的总收入等于\\(v\\).设起始月份为\\(l\\),结束月份为\\(r\\).那么前缀和\\(sum[r]-sum[l-1]=v\\),即\\(sum[r]-sum[l-1]\\le v,sum[l-1]-sum[r]\\ge -v\\).可用差分约束求解. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define INF 1e9using namespace std;const int N=105,M=1005;int n,m;int f[N][N]; int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fill(f[i]+1,f[i]+n+1,INF); for(int i=1;i&lt;=m;i++) { int l,r,w; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;w); if(f[l][r]!=INF &amp;&amp; f[l][r]!=w)//如果之前有值且与现在不等,输出false { printf(&quot;false\\n&quot;); goto end; } else f[l][r]=w; for(int j=1;j&lt;l;j++)//尝试拼接f[j][l-1]与f[l][r] { if(f[j][l-1]!=INF) { if(f[j][r]!=INF &amp;&amp; f[j][r]!=f[j][l-1]+f[l][r])//不能拼接 { printf(&quot;false\\n&quot;); goto end; } else f[j][r]=f[j][l-1]+f[l][r];//可以拼接,且与之前值相等(或之前没有值) } } for(int j=r+1;j&lt;=n;j++)//同理,尝试拼接f[l][r]与右边的区间 { if(f[r+1][j]!=INF) { if(f[l][j]!=INF &amp;&amp; f[l][j]!=f[l][r]+f[r+1][j]) { printf(&quot;false\\n&quot;); goto end; } else f[l][j]=f[l][r]+f[r+1][j]; } } } printf(&quot;true\\n&quot;); end: continue; } return 0;}","link":"/2021/03/16/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2294%20%5BHNOI2005%5D%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA/"},{"title":"【题解】P2422 良好的感觉","text":"Des kkk 做了一个人体感觉分析器。每一天，人都有一个感受值 \\(A_i\\)，\\(A_i\\) 越大，表示人感觉越舒适。在一段时间 \\(\\left[i, j\\right]\\) 内，人的舒适程度定义为 \\([i, j]\\) 中最不舒服的那一天的感受值 \\(\\times\\) \\(\\left[i, j\\right]\\)中每一天感受值的和。现在给出 kkk 在连续 \\(N\\) 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？ Sol 写这个题解主要是因为被 SP1805 HISTOGRA - Largest Rectangle in a Histogram 弄傻了。我还记得上一次做那道题的时候兴奋的说发现了新做法，其实就是单调队列里面这种题“左极限”和“右极限”的思想。单调队列说白了其实是求出满足某一特定条件的区间最大/最小值的方法。像滑动窗口那道经典题，需要满足的条件是可选的数的区间。加上最大值这个特性，就有了单调队列删除队尾或队首元素的做法。 HISTOGRA 那道题则需要求出所有 最小值为某一元素高度 的区间长度，与这道题一样。由于是区间，后面处理的元素肯定会对前面处理的元素造成影响。区别就是比前面的元素大还是小。如果是大，就说明前面元素高度对应的区间仍然可以延续。如果小，就说明不能延续了，用下标差相减就可得到区间长。但仍然由于是区间，前面处理的元素也会对后面处理的元素对应的区间长造成影响，所以需要从前往后再来一次。 HISTOGRA 的答案来源于“区间长度”，这个长度越长越好。本题其实也是区间长度越长越好，因为“感受值”全是正数。感受值的和用前缀和处理一下就行。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define mp make_pairtypedef long long ll;using namespace std;const int N=1e5+5;int n;int a[N],r[N],l[N];ll b[N];stack&lt;pair&lt;int,int&gt; &gt; s;inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void solver() { while(!s.empty()) s.pop(); s.push(mp(0,0)); for(int i=1;i&lt;=n+1;i++) { int h,idx; do { h=s.top().first,idx=s.top().second; if(a[i]&gt;=h) s.push(mp(a[i],i)); else r[idx]=i-idx-1,s.pop(); }while(a[i]&lt;h); }}void solvel() { while(!s.empty()) s.pop(); s.push(mp(0,0)); for(int i=n;i&gt;=0;i--) { int h,idx; do { h=s.top().first,idx=s.top().second; if(a[i]&gt;=h) s.push(mp(a[i],i)); else l[idx]=idx-i-1,s.pop(); }while(a[i]&lt;h); }}int main() { n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); b[i]=b[i-1]+a[i];//a[i]-&gt;int b[i-1]-&gt;ll } solvel(); solver(); ll ans=0; for(int i=1;i&lt;=n;i++) { int tor=i+r[i],tol=i-l[i]; ans=max(ans,(b[tor]-b[tol-1])*a[i]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2422-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%84%9F%E8%A7%89/"},{"title":"【题解】P2486 [SDOI2011]染色","text":"Des 给定一棵 \\(n\\) 个节点的无根树，共有 \\(m\\) 个操作，操作分为两种： 将节点 \\(a\\) 到节点 \\(b\\) 的路径上的所有点（包括 \\(a\\) 和 \\(b\\)）都染成颜色 \\(c\\)。 询问节点 \\(a\\) 到节点 \\(b\\) 的路径上的颜色段数量。 颜色段的定义是极长的连续相同颜色被认为是一段。例如 112221 由三段组成：11、222、1。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，\\(1 \\leq n, m \\leq 10^5\\)，\\(1 \\leq w_i, c \\leq 10^9\\)，\\(1 \\leq a, b, u, v \\leq n\\)，\\(op\\) 一定为 C 或 Q，保证给出的图是一棵树。 除原数据外，还存在一组不计分的 hack 数据。 Sol 首先树剖，记录 dfn[x] 和 rk[x]。 然后线段树建树。存储 lcol[x] 与 rcol[x]，记录区间左边的颜色和右边的颜色。存储 ans[x] 记录区间颜色段数量。线段树的 pushUp 函数需要注意被合并的两个区间的右、左端点的颜色，并合理更改 ans 值。 对于询问操作： 在树剖时不可交换 u,v 来达到节省代码长度的目的，因为需要记录 u,v 跳链的链端节点颜色，来处理总 ans 值。 在树剖时，判断当前长链的端点颜色 \\(col(top(x))\\) 与 \\(col(fa(top(x)))\\) 是否相等，如果相等，处理 ans。 在线段树上，使用和 pushUp 类似的逻辑合并 ans。 对于推平操作： 在树剖时，按照正常逻辑操作，无需特殊修改。 在线段树上，使用 lazytag 记录被推平的颜色，如果没有被推平，lazytag 记为 0. 对于被推平的区间，lcol[x] 和 rcol[x] 设置为 lazytag 的颜色，ans 记为 1. 由于是先输入颜色，再输入树的结构，所以要存下颜色的值。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//AC 100 Count: 1#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n, m, col[N], rk[N];struct edges { int v[N &lt;&lt; 1], nxt[N &lt;&lt; 1], head[N], cnt; void add(const int &amp;a, const int &amp;b) { nxt[++cnt] = head[a], v[cnt] = b, head[a] = cnt; }}g;namespace st { const int S = N &lt;&lt; 2; int lcol[S], rcol[S], ans[S], tag[S], lc[S], rc[S]; void getSon() { for(int i = 1; i &lt; S; i++) lc[i] = i &lt;&lt; 1, rc[i] = i &lt;&lt; 1 | 1; } void down(int p) { if(tag[p]) { tag[lc[p]] = tag[rc[p]] = tag[p]; lcol[lc[p]] = rcol[lc[p]] = lcol[rc[p]] = rcol[rc[p]] = tag[p]; ans[lc[p]] = ans[rc[p]] = 1; tag[p] = 0; } } void up(int p) { lcol[p] = lcol[lc[p]], rcol[p] = rcol[rc[p]]; ans[p] = ans[lc[p]] + ans[rc[p]]; if(rcol[lc[p]] == lcol[rc[p]]) --ans[p]; } void build(int l, int r, int p) { if(l == r) { lcol[p] = rcol[p] = col[rk[l]]; ans[p] = 1; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, lc[p]); build(mid + 1, r, rc[p]); up(p); } void change(int l, int r, int p, int x, int y, int k) { if(l &gt;= x &amp;&amp; r &lt;= y) { tag[p] = lcol[p] = rcol[p] = k; ans[p] = 1; return; } down(p); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(l, mid, lc[p], x, y, k); if(y &gt; mid) change(mid + 1, r, rc[p], x, y, k); up(p); } int query(int l, int r, int p, int x, int y) { if(l &gt;= x &amp;&amp; r &lt;= y) return ans[p]; down(p); int mid = (l + r) &gt;&gt; 1, ret = 0; if(x &lt;= mid) ret += query(l, mid, lc[p], x, y); if(y &gt; mid) ret += query(mid + 1, r, rc[p], x, y); if(x &lt;= mid &amp;&amp; y &gt; mid &amp;&amp; rcol[lc[p]] == lcol[rc[p]]) -- ret; up(p); return ret; } int getCol(int l, int r, int p, int x) { // 单点求颜色 if(l == x) return lcol[p]; int mid = (l + r) &gt;&gt; 1; down(p); if(x &lt;= mid) return getCol(l, mid, lc[p], x); else if(x &gt; mid) return getCol(mid + 1, r, rc[p], x); up(p); return -1; }} int dfn[N], dep[N], top[N], hson[N], fa[N], sz[N], cnt;int build(int u, int f) { dep[u] = dep[f] + 1, hson[u] = 0, sz[u] = 1, fa[u] = f; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v == f) continue; sz[u] += build(v, u); if(sz[v] &gt; sz[hson[u]]) hson[u] = v; } return sz[u];}void decom(int u, int t) { top[u] = t, dfn[u] = ++cnt, rk[cnt] = u; if(hson[u]) decom(hson[u], t); for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(hson[u] != v &amp;&amp; !dfn[v]) decom(v, v); } }void out(int u, int f) { cout &lt;&lt; u &lt;&lt; &quot; dfn: &quot; &lt;&lt; dfn[u] &lt;&lt; endl; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v == f) continue; out(v, u); }}void change(int u, int v, int k) { while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); st::change(1, n, 1, dfn[top[u]], dfn[u], k); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); st::change(1, n, 1, dfn[u], dfn[v], k);}int query(int u, int v) { int ans = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); ans += st::query(1, n, 1, dfn[top[u]], dfn[u]); if(st::getCol(1, n, 1, dfn[top[u]]) == st::getCol(1, n, 1, dfn[fa[top[u]]])) --ans; u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); ans += st::query(1, n, 1, dfn[u], dfn[v]); return ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; col[i]; } for(int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g.add(u, v), g.add(v, u); } build(1, 0); decom(1, 1);// out(1, 0); st::getSon(); st::build(1, n, 1); char op; int a, b, c; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if(op == 'C') { cin &gt;&gt; c; change(a, b, c); } else { cout &lt;&lt; query(a, b) &lt;&lt; '\\n'; } } return 0;} Note 本来查询操作是准备记录上次长链端点颜色值的，但是不好写，遂直接写了个单点求颜色函数。","link":"/2021/05/13/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2486-%5BSDOI2011%5D%E6%9F%93%E8%89%B2/"},{"title":"【题解】P2515 [HAOI2010]软件安装","text":"Des 现在我们的手头有\\(N\\)个软件，对于一个软件i，它要占用\\(W_i\\)的磁盘空间，它的价值为\\(V_i\\)。我们希望从中选择一些软件安装到一台磁盘容量为\\(M\\)计算机上，使得这些软件的价值尽可能大（即\\(V_i\\)的和最大）。 但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件\\(j\\)（包括软件j的直接或间接依赖）的情况下才能正确工作（软件\\(i\\)依赖软件\\(j\\))。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为\\(0\\)。 我们现在知道了软件之间的依赖关系：软件i依赖软件\\(D_i\\)。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则\\(D_i=0\\)，这时只要这个软件安装了，它就能正常工作。 Sol 来，，，先复习一下什么是有向图的强联通分量。有向图的强联通分量是指有向图的极大强联通子图。强联通图指的是图中任意 2 个点 \\(x,y\\) 存在 \\(x\\) 到 \\(y\\) 的路径,也存在 \\(y\\) 到 \\(x\\) 的路径。 那么本题中处于同一个强联通分量的点都是互相依赖的，也就是要么都装，要么都不装。运用 Tarjan 算法缩点后建立新图，注意每棵树都要连接到虚拟节点 0 上。 然后从节点 0 开始进行树上背包，就可以求出答案了。 树上背包时间复杂度 \\(O(M^2N)\\)，缩点时间复杂度 \\(O(N+M)\\)。 另外，由于这是有依赖的背包问题，在枚举当前节点的容量 \\(v\\) 时，下界是 \\(w_u\\)。 为什么呢？设当前枚举容量为 \\(j\\) 。 若当前枚举的是第一个孩子： \\(j=w_u\\)，正常更新。 \\(j&gt;w_u\\) ，那么 \\(f(u,j)=0\\)，就算加上 \\(f(v,x)\\)，也没有第一种情况大。 若当前枚举的是其他孩子，无论 \\(j\\) 为多少，\\(f(u,j)\\) 一定是由上面第一种情况更新的。值为 \\(w_u+f(v,x)\\) ，可以用到现在的状况正常更新！ 其实P2014 [CTSC1997]选课也是有依赖的背包问题，但下界是 1，就没怎么注意。导致这次做根本没考虑这件事。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=505; //N提升至M int n,m,top;int w[N],v[N],w2[N],v2[N],in[N],f[N][50005];vector&lt;int&gt; g[N],g2[N];int dfn[N],low[N],ins[N],scc[N],sccCnt,cnt;stack&lt;int&gt; s;void tarjan(int u,int fa) { dfn[u]=low[u]=++cnt,s.push(u),ins[u]=true; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!dfn[v]) { tarjan(v,u); low[u]=min(low[u],low[v]); } else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(low[u]==dfn[u]) { ++sccCnt; do { top=s.top(),s.pop(),scc[top]=sccCnt,ins[top]=false; }while(top!=u); }}void dfs(int u,int fa) { int len=g2[u].size(); f[u][w2[u]]=v2[u]; if(len==0) return; for(int i=0;i&lt;len;i++) { int v=g2[u][i]; if(v==fa) continue; dfs(v,u); for(int k=m;k&gt;=w2[u];k--) { for(int j=0;j+k&lt;=m;j++) { f[u][j+k]=max(f[u][j+k],f[u][k]+f[v][j]); } } } }int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) {int t;cin&gt;&gt;t;g[t].push_back(i);} //fa-&gt;son for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i,0); } //由于排开了0 剩下的都是森林内部的关系 只要入度为0就是根节点 for(int i=1;i&lt;=n;i++) { w2[scc[i]]+=w[i],v2[scc[i]]+=v[i]; int len=g[i].size(); for(int j=0;j&lt;len;j++) { int v=g[i][j]; if(scc[i]!=scc[v]) g2[scc[i]].push_back(scc[v]),++in[scc[v]]; } } for(int i=1;i&lt;=sccCnt;i++) if(in[i]==0) g2[0].push_back(i); dfs(0,-1); int ans=0; for(int i=0;i&lt;=m;i++) ans=max(ans,f[0][i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note 有依赖的背包问题，总要把依赖选了吧。。。","link":"/2021/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2515%20%5BHAOI2010%5D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"title":"【题解】P2596 [ZJOI2006]书架","text":"Des 第一行有两个整数，分别表示书的个数 \\(n\\) 以及命令条数 \\(m\\)。 第二行有 \\(n\\) 个整数，第 \\(i\\) 个整数表示初始时从上向下书第 \\(i\\) 本书的编号 \\(p_i\\)。 接下来 \\(m\\) 行，每行表示一个操作。每行初始时有一个字符串 \\(op\\)。 若 \\(op\\) 为 Top，则后有一个整数 \\(s\\)，表示把编号为 \\(s\\) 的书放在最上面。 若 \\(op\\) 为 Bottom，则后有一个整数 \\(s\\)，表示把编号为 \\(s\\) 的书放在最下面。 若 \\(op\\) 为 Insert，则后有两个整数 \\(s, t\\)，表示若编号为 \\(s\\) 的书上面有 \\(x\\) 本书，则放回这本书时他的上面有 \\(x + t\\) 本书。 若 \\(op\\) 为 Ask，则后面有一个整数 \\(s\\)，表示询问编号为 \\(s\\) 的书上面有几本书。 若 \\(op\\) 为 Query，则后面有一个整数 \\(s\\)，询问从上面起第 \\(s\\) 本书的编号。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，保证： - \\(3 \\leq n, m \\leq 8 \\times 10^4\\)。 - \\(p_i\\) 是一个 \\(1 \\sim n\\) 的排列。 - \\(1 \\leq s \\leq n\\)，\\(-1 \\leq t \\leq 1\\)，\\(op\\) 只可能是输入的五种字符串之一。 - 当编号为 \\(s\\) 的书上面没有书的时候，不会对它进行 Insert s -1 操作。 - 当编号为 \\(s\\) 的书下面没有书的时候，不会对它进行 Insert s 1 操作。 Sol 这道题既需要按值查排名，又需要按排名查值。看似需要树套树，其实不然。本题的书的编号为 \\(1\\sim n\\) 的一个排列，可以建立数组把书的编号对应到平衡树的节点编号上去。其次，本题的阉割版插入操作本质上是交换了一个数与它的前驱或后继。 2 种 treap 做法： 1. 按 size 分裂。将编号与平衡树节点对应，向上遍历查排名。 2. 按权值分裂。给每个节点一个权值。如果遇到排到顶部或底部的操作，就将权值置为 max + 1 或 min - 1。如果是 insert 操作，就与前驱或后继的权值交换。 第一种做法其实可以支持 insert 操作的任意 t 值，但由于向上遍历需要维护 father 值，不好写，我选择了第二种。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define endl '\\n'typedef long long ll;using namespace std;const int N = 8e4 + 5;int n, m, orig[N], to[N];namespace treap { #define lc(x) ch[x][0] #define rc(x) ch[x][1] #define getmid int mid = (l + r) &gt;&gt; 1 int ch[N][2], sz[N], val[N], rnd[N], id[N], rt, cnt; int minVal, maxVal; void update(int x) { sz[x] = sz[lc(x)] + sz[rc(x)] + 1; } void newNode(int &amp;t, int x) { val[t = ++cnt] = x, rnd[t] = rand(), sz[t] = 1; lc(t) = rc(t) = 0; } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { rc(x) = merge(rc(x), y); update(x); return x; } else { lc(y) = merge(x, lc(y)); update(y); return y; } } void split(int p, int v, int &amp;x, int &amp;y) { if(!p) { x = y = 0; return; } if(val[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); update(x); } else { y = p; split(lc(y), v, x, lc(y)); update(y); } } void szsplit(int p, int v, int &amp;x, int &amp;y) { if(!p) { x = y = 0; return; } if(sz[lc(p)] &lt; v) { x = p; szsplit(rc(x), v - sz[lc(p)] - 1, rc(x), y); update(x); } else { y = p; szsplit(lc(y), v, x, lc(y)); update(y); } } int build(int l, int r) { if(l &gt; r) return 0; getmid; int u = ++cnt; id[u] = orig[mid], val[u] = to[orig[mid]] = 80000 + mid; rnd[u] = u, sz[u] = 1; lc(u) = build(l, mid - 1), rc(u) = build(mid + 1, r); update(u); return u; } void out(int u) { if(!u) return; out(lc(u)); cout &lt;&lt; id[u] &lt;&lt; ' '; out(rc(u)); }}using namespace treap;int main() { srand(time(0)); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; orig[i]; build(1, n); rt = 1; minVal = 80001, maxVal = 80000 + n; string op; int s, t, a, b, c, d; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; op &gt;&gt; s; if(op[0] == 'T') { // Top split(rt, to[s] - 1, a, b); split(b, to[s], b, c); val[b] = to[s] = --minVal; rt = merge(merge(b, a), c); } else if(op[0] == 'B') { // Bottom split(rt, to[s] - 1, a, b); split(b, to[s], b, c); val[b] = to[s] = ++maxVal; rt = merge(a, merge(c, b)); } else if(op[0] == 'I') { // Insert cin &gt;&gt; t; if(t == 1) { // 与后继交换 split(rt, to[s] - 1, a, b); split(b, to[s], b, c); szsplit(c, 1, c, d); swap(to[id[b]], to[id[c]]), swap(val[b], val[c]); rt = merge(a, merge(merge(c, b), d)); } else if(t == -1) { split(rt, to[s], a, b); szsplit(a, sz[a] - 2, a, c); szsplit(c, 1, c, d); swap(to[id[c]], to[id[d]]), swap(val[c], val[d]); rt = merge(a, merge(merge(d, c), b)); } } else if(op[0] == 'A') { // Ask split(rt, to[s] - 1, a, b); cout &lt;&lt; sz[a] &lt;&lt; endl; rt = merge(a, b); } else { // Query szsplit(rt, s - 1, a, b); szsplit(b, 1, b, c); cout &lt;&lt; id[b] &lt;&lt; endl; rt = merge(a, merge(b, c)); }// out(rt);// cout &lt;&lt; endl; } return 0;} Note 调试的时候那个输出中序遍历的函数帮了很大忙。其实做数据结构题关注的就是“数据”与“结构”，很多时候只看数据完全没有用，输出结构更直观。","link":"/2021/05/11/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2596-%5BZJOI2006%5D%E4%B9%A6%E6%9E%B6/"},{"title":"【题解】P2634 [国家集训队]聪聪可可","text":"Des 聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 \\(n\\) 个“点”，并用 \\(n-1\\) 条“边”把这 \\(n\\) 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 \\(3\\) 的倍数，则判聪聪赢，否则可可赢。 聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，\\(n\\leq 2 \\times 10^4\\)。 Sol 这道题点分治做的话当然很板，不过我想来剖析一下题解中树形 DP 的做法，建立一下树形 DP 做树上路径问题的框架。 树上路径 \\((u,v)\\) 可以分为 2 种，一种是垂直向上的，一种是先向上再向下的。 对于垂直向上的，可以用节点+路径的方式更新。即给节点设立一个路径长为 0 的 DP 值，再和路径一起更新。和点分治的思想类似。 对于先向上再向下的，可以用路径+路径的方式更新，把已经遍历的子树上的路径加上当前节点到那颗子树的路径长度，存进数组里，然后即可与现在的子树信息合并。 另外，如果要得到 \\(0\\rightarrow 0,1\\rightarrow n-1,2\\rightarrow n-2,\\dots,n-1\\rightarrow1\\) 这样的对应关系，可以执行 \\(mod(-a)\\)（mod 操作为 (a%p+p)%p）。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e4 + 5, M = 4e4 + 5;int n, ans;struct edges { int v[M], w[M], nxt[M], head[N], cnt; void add(int a, int b, int c) { nxt[++cnt] = head[a], head[a] = cnt; v[cnt] = b, w[cnt] = c; }}g;int f[N][3];inline int mod(int x) { return (x % 3 + 3) % 3;}void dfs(int u, int fa) { f[u][0] = 1; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v == fa) continue; dfs(v, u); for(int j = 0; j &lt;= 2; j++) { ans += f[v][j] * f[u][mod(- j - g.w[i])] * 2; } for(int j = 0; j &lt;= 2; j++) { f[u][mod(j + g.w[i])] += f[v][j]; } }}int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b);}int main() { #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; n; for(int i = 1, x, y, w; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; g.add(x, y, w), g.add(y, x, w); } dfs(1, 0); ans += n; int full = n * n; cout &lt;&lt; ans / gcd(ans, full) &lt;&lt; '/' &lt;&lt; full / gcd(ans, full) &lt;&lt; '\\n'; return 0;}","link":"/2021/05/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2634-%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/"},{"title":"【题解】P2709 小B的询问","text":"Des 小B 有一个长为 \\(n\\) 的整数序列 \\(a\\)，值域为 \\([1,k]\\)。 他一共有 \\(m\\) 个询问，每个询问给定一个区间 \\([l,r]\\)，求： \\[\\sum\\limits_{i=1}^k c_i^2\\] 其中 \\(c_i\\) 表示数字 \\(i\\) 在 \\([l,r]\\) 中的出现次数。 小B请你帮助他回答询问。 Sol 莫队确实比分块好写得多。。。 将询问按照 \\(l\\) 的值分块，并在块内将询问按照右端点值排序。这样，块内每 2 个询问间更新左端点时间复杂度为 \\(\\Omega(T)\\)，更新右端点的复杂度和为 \\(\\Omega (n)\\)。跨块更新左端点时间复杂度为 \\(\\Omega(2T)\\)，跨块更新右端点时间复杂度为 \\(\\Omega (n)\\)。 总时间复杂度为 \\(\\Omega (nT) + \\Omega(n\\cdot \\frac nT) + \\Omega(\\frac nT n) + O(T\\cdot \\frac nT)=O(nT+\\frac {n^2} T)\\)，块长为 \\(\\sqrt n\\) 仍然最合适。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5e4+5;ll ans[N];int n,m,k,T;int a[N],cnt[N];struct ask { int l,r,idx,bl; bool operator &lt; (const ask &amp;b) const {// if(bl==b.bl) {// if(l==b.l) return r&lt;b.r;// else return l&lt;b.l;// } if(bl==b.bl) return r&lt;b.r; else return bl&lt;b.bl; }}q[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { n=read(),m=read(),k=read(); T=(int)sqrt(n); for(int i=1;i&lt;=n;i++) { a[i]=read(); } for(int i=1;i&lt;=m;i++) { q[i].l=read(),q[i].r=read(),q[i].idx=i; q[i].bl=(q[i].l-1)/T+1; } sort(q+1,q+m+1); int l=1,r=0,t=0; for(int i=1;i&lt;=m;i++) { while(l&lt;q[i].l) { t-=cnt[a[l]]*2-1; --cnt[a[l]]; l++; } while(l&gt;q[i].l) { --l; t+=cnt[a[l]]*2+1; ++cnt[a[l]]; } while(r&lt;q[i].r) { ++r; t+=cnt[a[r]]*2+1; ++cnt[a[r]]; } while(r&gt;q[i].r) { t-=cnt[a[r]]*2-1; --cnt[a[r]]; --r; } ans[q[i].idx]=t; } for(int i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0;}","link":"/2021/04/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2709-%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE/"},{"title":"【题解】P2746 [USACO5.3]校园网Network of Schools","text":"Des P2746 [USACO5.3]校园网Network of Schools - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 \\(B\\) 在 \\(A\\) 学校的分发列表中，\\(A\\) 也不一定在 \\(B\\) 学校的列表中。 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 Sol 对于Subtask 1,先缩点.新图中入度为0的点的数量即为答案. 对于Subtask 2,答案为 max(入度为0的点的数量,出度为0的点的数量). 为什么? 图1 对于Subtask 1,将软件传给一个入度为0的点后,它一定不会把软件传给另一个入度为0的点.所以每一个入度为0的点都需要传一次. 对于Subtask 2,考虑如下: 设出度为0的点组成的点集为\\(O\\),入度为0的点组成的点集为\\(I\\).考虑添加边使得\\(O\\cup I\\)成为一个强连通图.设\\(O\\cup I=S\\).需要注意,现在\\(S\\)中并不是没有边.并且\\(S\\)现在是一个二分图.例如上面的图构建出\\(S\\)就是下面这样: 图2 进行构造:每次从\\(O\\)中选择一个点\\(u\\).再从\\(I\\)中选择一个点\\(v\\),满足\\(v\\)可以到达\\(O\\)中除\\(u\\)外的任意一点(一定可以选择到).连边\\((u,v)\\).持续选择直到\\(O\\)(或\\(I\\))中只剩一个点可以选择.此时,已选择的点,新加入的边和原有的边构成了一个 SCC.之后的操作就比较随意了,把\\(I\\)(或\\(O\\))中剩下的点与\\(O\\)(或\\(I\\))中已选择的点随便连一连即可.但也必须要连.总连边数为\\(max(|I|,|O|)\\). 上述构造中,如果在构造 SCC 时少连任意一条边,就无法构成 SCC .如果在随意连边的过程中少连任意一条边,最后就会有一个点不满足题目要求.因此,Subtask 2 的答案就是\\(max(|I|,|O|)\\). My code 本题属于规律题,代码和其他题解没有太大差异,就不放注释了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n;vector&lt;int&gt; g[N];int idx,tot,in0,out0;int dfn[N],low[N],ins[N],scc[N],sccIn[N],sccOut[N];stack&lt;int&gt; s;void tarjan(int u){ dfn[u]=low[u]=++idx; s.push(u),ins[u]=true; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { ++tot; int top=-1; do { top=s.top(); s.pop(),ins[top]=false; scc[top]=tot; }while(top!=u); }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int v; while(cin&gt;&gt;v &amp;&amp; v) { g[i].push_back(v); } } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i); } for(int i=1;i&lt;=n;i++) { int len=g[i].size(); for(int j=0;j&lt;len;j++) { int v=g[i][j]; if(scc[v]!=scc[i]) { sccIn[scc[v]]++,sccOut[scc[i]]++; } } } for(int i=1;i&lt;=tot;i++) { if(!sccIn[i]) in0++; if(!sccOut[i]) out0++; } if(tot==1) printf(&quot;1\\n0\\n&quot;);//只有一个连通块的情况需要特判 else printf(&quot;%d\\n%d\\n&quot;,in0,max(out0,in0)); return 0;}","link":"/2021/03/18/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2746-%5BUSACO5.3%5D%E6%A0%A1%E5%9B%AD%E7%BD%91Network-of-Schools/"},{"title":"【题解】P2758 编辑距离","text":"Des P2758 编辑距离 Sol 记录这道题主要是归纳动态规划的方法. My code AC 100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e7+5,INF=1e9;int n,k,f[N],t=1,l[N],s=1,empty[N],ans,start=1;struct task{ int p,t; bool operator &lt; (const task &amp;b) const { if(p==b.p) return t&lt;b.t; else return p&lt;b.p; }}a[N];int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;a[i].p&gt;&gt;a[i].t; } sort(a+1,a+k+1); for(int i=1;i&lt;=n;i++) { int empty_size=0; while(a[t].p==i) { for(int j=start;j&lt;=s;j++) { if(l[j]!=INF&amp;&amp;a[t].p&gt;l[j]) { int pos=a[t].p+a[t].t-1,now=f[l[j]]+a[t].p-l[j]-1; if(now&gt;=f[pos]) { f[pos]=now; l[++s]=pos; } empty[++empty_size]=j; } } t++; } for(int j=1;j&lt;=empty_size;j++) { l[empty[j]]=INF; } for(int j=start;j&lt;=s;j++) { if(l[j]==INF) start++; else break; } } for(int i=2;i&lt;=s;i++) { if(l[i]!=INF) { ans=max(ans,f[l[i]]+n-l[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"title":"【题解】P2761 软件补丁问题","text":"Des T 公司发现其研制的一个软件中有 n 个错误，随即为该软件发放了一批共 m 个补丁程序。每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。 换句话说，对于每一个补丁 i，都有 2 个与之相应的错误集合 B1[i]和 B2[i]，使得仅当软件包含 B1[i]中的所有错误，而不包含 B2[i]中的任何错误时，才可以使用补丁 i。补丁 i 将修复软件中的某些错误 F1[i]，而同时加入另一些错误 F2[i]。另外，每个补丁都耗费一定的时间。 试设计一个算法，利用 T 公司提供的 m 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 n 个错误和 m 个补丁程序，找到总耗时最少的软件修复方案。 Sol 状压 DP！ 为每一个补丁计算出可转移的状态以及转移出的方式，然后跑 SPFA 最短路。 SPFA 的队列中的每一个状态都要枚举能否向任何一个补丁转移，复杂度不太明白，反正能过。 如果硬要用网络流的话，我觉得是解不出的，因为不同的流之间会有关系（某些必须同时流动）。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//AC100 Count:5#include &lt;bits/stdc++.h&gt;#define mp make_pairtypedef long long ll;using namespace std;const int N=25,M=105;int n,m; int edge[M],dis[1&lt;&lt;22],vis[1&lt;&lt;22];int getSta[M],getSta0[M];int toSta[M],toSta0[M];queue&lt;pair&lt;int,int&gt; &gt; q;int spfa() { memset(dis,0x3f,sizeof dis); int full=(1&lt;&lt;n)-1; q.push(mp(0,full)); dis[full]=0; vis[full]=true; while(!q.empty()) { int u=q.front().second; q.pop(); vis[u]=false; for(int i=1;i&lt;=m;i++) { if((u&amp;getSta0[i])==getSta[i]) { int v=(u&amp;toSta0[i])|toSta[i]; if(v==u || vis[v]) continue; if(dis[u]+edge[i]&lt;dis[v]) { dis[v]=dis[u]+edge[i]; q.push(mp(dis[v],v)); } } } } if(dis[0]==0x3f3f3f3f) return 0; else return dis[0];}int main() { cin&gt;&gt;n&gt;&gt;m; string s; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;edge[i]&gt;&gt;s; for(int j=0;j&lt;n;j++) { getSta[i]&lt;&lt;=1; if(s[j]=='+') getSta[i]|=1; getSta0[i]=getSta0[i]&lt;&lt;1; if(s[j]!='0') getSta0[i]|=1; } cin&gt;&gt;s; for(int j=0;j&lt;n;j++) { toSta[i]&lt;&lt;=1; if(s[j]=='+') toSta[i]|=1; toSta0[i]&lt;&lt;=1; if(s[j]=='0') toSta0[i]|=1; } } cout&lt;&lt;spfa(); return 0;} Note 补丁的个数为 M，不是 N.","link":"/2021/04/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2761-%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/"},{"title":"【题解】P2782 友好城市","text":"Des P2782 友好城市 - 洛谷 Sol 画出一个满足条件的方法图例,可以发现,从左到右的航线对应的端点(及城市)编号都是上升的.考虑满足这个关系. 对于河岸一边的城市,考虑排序使其编号上升.对于另一边的城市,则求最长上升序列.可以证明这样找出的答案是最大的. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,f[N],r; struct line{ int x,y;}a[N];bool cmp(const line &amp;a,const line &amp;b){ return a.x&lt;b.x;}inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i].x=read(),a[i].y=read(); } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(a[i].y&gt;f[r]) f[++r]=a[i].y; else { int pos=upper_bound(f+1,f+r,a[i].y)-f; f[pos]=a[i].y; } } printf(&quot;%d\\n&quot;,r); return 0;}","link":"/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2782-%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/"},{"title":"【题解】P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G","text":"Des P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果 \\(A\\) 喜欢 \\(B\\)，\\(B\\) 喜欢 \\(C\\)，那么 \\(A\\) 也喜欢 \\(C\\)。牛栏里共有 \\(N\\) 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。 Sol 看了题解. 归纳出 DAG 的一个性质. 一个DAG 像这样的一个 DAG ,将入度为0的点称为源点,出度为0的点称为汇点.那么,从任何一个点出发都可以到达汇点,但不一定能到达除汇点以外的点.同样,从源点出发能到达任何一个点,但从其他点出发就不行. 明了了这个事情,再做这道题就很容易了. 首先,强连通分量内的奶牛互相爱慕,因此可以运用 Tarjan 缩点.然后整张图就变成了数个 DAG,一个奶牛块(233,就是强连通分量) u 想要被奶牛块 v 爱慕,求必须存在路径 (u,v).与上方模型完全一致.那么,出度为0的强连通分量受到所有奶牛的爱慕. 如果最后整张图连通(一个 DAG),可以输出答案.但如果不连通(数个 DAG,出度为0的强连通分量不唯一),就没有答案. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*- 奶牛总是喜欢自己的 */#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1e4+5,M=5e4+5;int n,m;vector&lt;int&gt; g1[N],g2[N];int tot,ans,idx;stack&lt;int&gt; s;int dfn[N],low[N],scc[N],sccVal[N],sccOut[N];bool ins[N];void tarjan(int u){ dfn[u]=low[u]=++idx; s.push(u),ins[u]=true; int len=g1[u].size(); for(int i=0;i&lt;len;i++) { int v=g1[u][i]; if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { int top; ++tot; do { top=s.top(); s.pop(); scc[top]=tot; sccVal[tot]++; ins[top]=false; }while(top!=u); }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(u==v) continue; g1[u].push_back(v); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i); } for(int i=1;i&lt;=n;i++) { int len=g1[i].size(); for(int j=0;j&lt;len;j++) { if(scc[i]!=scc[g1[i][j]]) sccOut[scc[i]]++; } } int flag=0; for(int i=1;i&lt;=tot;i++) { if(!sccOut[i]) { if(flag) { printf(&quot;0\\n&quot;); return 0; } else flag=i; } } printf(&quot;%d\\n&quot;,sccVal[flag]); return 0;}","link":"/2021/03/18/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2863-%5BUSACO06JAN%5DThe-Cow-Prom-S/"},{"title":"【题解】P3121 [USACO15FEB]Censoring G","text":"Des FJ 把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过 \\(10^5\\) 的字符串 \\(s\\)。他有一个包含 \\(n\\) 个单词的列表，列表里的 \\(n\\) 个单词记为 \\(t_1 \\cdots t_n\\)。他希望从 \\(s\\) 中删除这些单词。 FJ 每次在 \\(s\\) 中找到最早出现的列表中的单词（最早出现指该单词的开始位置最小），然后从 \\(s\\) 中删除这个单词。他重复这个操作直到 \\(s\\) 中没有列表里的单词为止。注意删除一个单词后可能会导致 \\(s\\) 中出现另一个列表中的单词。 FJ 注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在 \\(s\\) 中出现的开始位置是互不相同的。 请帮助 FJ 完成这些操作并输出最后的 \\(s\\)。 Sol 每次在主串中找到一个匹配的子串\\(S\\) 后,把\\(u\\)(当前位置)回滚到\\(S\\)的前一个字符,并且删除\\(S\\). 但这道题真的是折磨王.....卡了好久. 从后往前删除这种操作还是用栈记录答案比较好,我之前写的强行给主串打上删除标记,不仅实现起来很复杂,时间复杂度也不对. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n;bool vis[N];char t[N],s[N];struct ahoCorasick{ int size,top; int fail[N],val[N],front[N],sta[N],ans[N]; queue&lt;int&gt; q; int trie[N][26]; void insert(char *s) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { int c=s[i]-'a'; if(!trie[u][c]) trie[u][c]=++size; u=trie[u][c]; } val[u]=len; } void getFail() { for(int i=0;i&lt;26;i++) { if(trie[0][i]) q.push(trie[0][i]); } while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0;i&lt;26;i++) { int v=trie[u][i]; if(v) fail[v]=trie[fail[u]][i],q.push(v); else trie[u][i]=trie[fail[u]][i]; } } } void query(char *s) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { sta[i]=u=trie[u][s[i]-'a']; ans[++top]=i; if(val[u]) { top-=val[u]; u=sta[ans[top]]; } } }}AC;int main(){ scanf(&quot;%s&quot;,t); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s); AC.insert(s); } AC.getFail(); AC.query(t); for(int i=1;i&lt;=AC.top;i++) { putchar(t[AC.ans[i]]); } putchar('\\n'); return 0;}","link":"/2021/03/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3121-%5BUSACO15FEB%5DCensoring-G/"},{"title":"【题解】P3168 [CQOI2015]任务查询系统","text":"Des 最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。 超级计算机中的任务用三元组 \\((s_i,e_i,p_i)\\) 描述，\\((s_i,e_i,p_i)\\) 表示任务从第 \\(s_i\\) 秒开始，在第 \\(e_i\\) 秒后结束（第 \\(s_i\\) 秒和 \\(e_i\\) 秒任务也在运行），其优先级为 \\(p_i\\)。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。 调度系统会经常向查询系统询问，第 \\(x_i\\) 秒正在运行的任务中，优先级最小的 \\(k_i\\) 个任务（即将任务按照优先级从小到大排序后取前 \\(k_i\\) 个）的优先级之和是多少。 特别的，如果 \\(k_i\\) 大于第 $x_i $秒正在运行的任务总数，则直接回答第 \\(x_i\\) 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 \\([1,n]\\) 之间。 Sol 如果不加上询问第\\(x_i\\)秒这个条件,完全就是线段树好吗. 每秒与上一秒的区别就在于多了或少了几个不起眼的任务(指小于\\(10^5\\)),主席树可过. 给每个节点记录该节点代表的区间的数的个数val和权值和sum,二分查询. 虽然\\(p_i\\)达到了\\(10^7\\),不能作下标,但是可以动态开点(我不会Orz)或者离散化.虽然每个任务都会重新开一条路径,但对于相同时间的任务记录最后一个就好了. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5;int m,n; int tim[N],fin[N],rt[N&lt;&lt;2];struct task{int pos,prt;} st[N],ed[N];bool cmp(const task &amp;a,const task &amp;b) {return a.pos&lt;b.pos;}inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace sg { struct node{int l,r,val;ll sum;} c[N*40]; int cnt; int build(int l,int r) { int id=++cnt,mid=(l+r)&gt;&gt;1; if(l==r) return id; c[id].l=build(l,mid),c[id].r=build(mid+1,r); return id; } int make(int l,int r,int id,int pos,int k) { c[++cnt]=c[id],id=cnt,c[id].val+=(k&gt;0)?(1):(-1),c[id].sum+=k; if(l==r) return id; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) c[id].l=make(l,mid,c[id].l,pos,k); else c[id].r=make(mid+1,r,c[id].r,pos,k); return id; } ll query(int l,int r,int id,int k) { if(c[id].val&lt;=k) return c[id].sum; if(l==r) return k*tim[l]; ll res=0; int mid=(l+r)&gt;&gt;1,lval=c[c[id].l].val; res+=query(l,mid,c[id].l,min(lval,k)); if(k&gt;lval) res+=query(mid+1,r,c[id].r,k-lval); return res; }}int main() { m=read(),n=read(); for(int i=1;i&lt;=m;i++) { st[i].pos=read(),ed[i].pos=read()+1; st[i].prt=ed[i].prt=tim[i]=read(); } sort(tim+1,tim+m+1); int len=unique(tim+1,tim+m+1)-tim-1; sort(st+1,st+m+1,cmp),sort(ed+1,ed+m+1,cmp); sg::build(1,n); int pSt=1,pEd=1,v=0; for(int i=1;i&lt;=n+1;i++) { fin[i]=v; while(st[pSt].pos==i) { const int&amp; prt=st[pSt].prt; int pos=lower_bound(tim+1,tim+len+1,prt)-tim; rt[v+1]=sg::make(1,len,rt[v],pos,prt); ++pSt,fin[i]=++v; } while(ed[pEd].pos==i) { const int&amp; prt=ed[pEd].prt; int pos=lower_bound(tim+1,tim+len+1,prt)-tim; rt[v+1]=sg::make(1,len,rt[v],pos,-prt); ++pEd,fin[i]=++v; } } int x; ll a,b,c,k,pre=1; for(int i=1;i&lt;=n;i++) { x=read(),a=read(),b=read(),c=read(); k=1+(a*pre+b)%c; printf(&quot;%lld\\n&quot;,pre=sg::query(1,len,rt[fin[x]],k)); } return 0;} Note 当二分到l==r时,不能直接返回sum,因为k可能小于val.所有权值线段树都要注意这一点!","link":"/2021/03/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3168-%5BCQOI2015%5D%E4%BB%BB%E5%8A%A1%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/"},{"title":"【题解】P3225 [HNOI2012]矿场搭建","text":"Des 煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。 请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 Sol 个人认为这道题真的出的很好,因为让我做出来了背景很贴近生活,也不是单纯的思维题或算法题,想到答案后简直妙不可言. 整个图设为\\(G\\),连通子图设为\\(G_i\\).连通子图的设置方案互不干扰,在求出每个连通子图的方案数后可运用乘法原理. 连通子图有2种: 1 无割点(点双连通图) 无割点 无割点的子图至少需要设立2个救援出口.方案数为\\(C_{n}^2\\),\\(n\\)为子图的点数. 2 有割点 4,5,8,9都是割点 如果任何一个割点发生事故,势必会将子图分成相互割离的几部分.那么,在相互割离的几部分中都至少要有一个救援出口.设把所有割点去除,剩下连通块的数量就是救援出口的数量.方案数为连通块中点数的乘积. 计算连通块和判断是否是点双连通图都可以用一个 DFS 实现.从所有还没有 vis 过的点 DFS ,如果遇到正常点,给pointVal++;如果遇到割点,给cutCnt++.最后如果 cutCnt = 0 ,说明是点双连通图.如果 cutCnt = 1 ,给 ans 乘上连通块点数量. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=100005;int n,idx,root;ll ansl[N],ansp,ans;int dfn[N],low[N],ins[N],cut[N];bool has[N];stack&lt;int&gt; s;vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void tarjan(int u){ dfn[u]=low[u]=++idx; int len=g[u].size(),flag=0; for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!dfn[v]) { tarjan(v); low[u]=min(low[v],low[u]); if(dfn[u]&lt;=low[v]) { if(++flag&gt;1 || u!=root) cut[u]=true; } } else low[u]=min(dfn[v],low[u]); }}int cutCnt,pointCnt;bool vis[N],visCut[N];void dfs(int u){ if(cut[u]) { if(visCut[u]==false) cutCnt++,visCut[u]=true; return; } vis[u]=true; pointCnt++; int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(!vis[v]) dfs(v); }}int main(){ int nCnt=0; while((n=read())) { nCnt++; for(int i=1;i&lt;=100000;i++) { g[i].clear(); } memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(cut,0,sizeof cut); memset(vis,0,sizeof vis); memset(has,0,sizeof has); memset(ansl,0,sizeof ansl); idx=ansp=0,ans=1; for(int i=1;i&lt;=n;i++) { int u=read(),v=read(); has[u]=has[v]=true; if(u==v) continue; g[u].push_back(v),g[v].push_back(u); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) root=i,tarjan(i); } for(int i=1;i&lt;=100000;i++) { if(!vis[i] &amp;&amp; cut[i]==false &amp;&amp; has[i]) { memset(visCut,0,sizeof visCut); cutCnt=pointCnt=0; dfs(i); if(cutCnt==1) ansl[++ansp]=pointCnt; else if(cutCnt==0) ansl[++ansp]=1,ansl[++ansp]=(pointCnt*(pointCnt-1))/2; } } for(int i=1;i&lt;=ansp;i++) ans*=ansl[i]; printf(&quot;Case %d: %lld %lld\\n&quot;,nCnt,ansp,ans); } return 0;} Note 本题性价比很高 mining your own business 是SPOJ和UVA上的重题,可以水经验.","link":"/2021/03/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3225-%5BHNOI2012%5D%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/"},{"title":"【题解】P3313 [SDOI2014]旅行","text":"Des S国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。 为了方便，我们用不同的正整数代表各种宗教， S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。 在S国的历史上常会发生以下几种事件： “CC x c“：城市x的居民全体改信了c教； “CW x w“：城市x的评级调整为w; “QS x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和； “QM x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级最大值。 由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。 \\(\\texttt{Data Range:}\\) N，Q &lt; =10^5 ， C &lt; =10^5 数据保证对所有QS和QM事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于10^4的正整数，且宗教值不大于C。 Sol 树链剖分 + 多根平衡树。由于要维护不同信仰的城市的评级最大值与总和，用线段树要动态开点。而平衡树本身就是动态开点的，我将这种平衡树称为多根平衡树。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#define max(a, b) ((a) &gt; (b) ? (a) : (b))using namespace std;const int N = 1e5 + 5;int n, q, belief[N], w[N], c[N];struct edges { int cnt, nxt[N &lt;&lt; 1], head[N &lt;&lt; 1], v[N &lt;&lt; 1]; void add(const int &amp;a, const int &amp;b) { nxt[++cnt] = head[a], head[a] = cnt, v[cnt] = b; }}g;namespace bst { #define lc(x) ch[x][0] #define rc(x) ch[x][1] int ch[N &lt;&lt; 1][2], val[N &lt;&lt; 1], rnd[N &lt;&lt; 1]; int rt[N &lt;&lt; 1], tot[N &lt;&lt; 1], id[N &lt;&lt; 1], mx[N &lt;&lt; 1], cnt; inline void update(int p) { tot[p] = tot[lc(p)] + tot[rc(p)] + val[p]; mx[p] = max(max(mx[lc(p)], val[p]), mx[rc(p)]); } void newNode(int &amp;k, int i, int v) { val[++cnt] = v, tot[cnt] = v; rnd[cnt] = rand(), id[cnt] = i, mx[cnt] = v; lc(cnt) = rc(cnt) = 0; k = cnt; } int merge(int x, int y) { if(!x || !y) return x | y; if(rnd[x] &lt; rnd[y]) { rc(x) = merge(rc(x), y); update(x); return x; } else { lc(y) = merge(x, lc(y)); update(y); return y; } } void split(int p, int v, int &amp;x, int &amp;y) { if(!p) { x = y = 0; return; } else if(id[p] &lt;= v) { x = p; split(rc(x), v, rc(x), y); update(x); } else { y = p; split(lc(y), v, x, lc(y)); update(y); } } void insert(int &amp;r, int i, int v) { if(!r) newNode(r, i, v); else { int a = 0, b = 0, c = 0; split(r, i, a, b); newNode(c, i, v); r = merge(merge(a, c), b); } } int getsum(int l, int r, int c) { int x = 0, y = 0, z = 0; split(rt[c], l - 1, x, y); split(y, r, y, z); int ret = tot[y]; rt[c] = merge(merge(x, y), z); return ret; } int getmax(int l, int r, int c) { int x = 0, y = 0, z = 0; split(rt[c], l - 1, x, y); split(y, r, y, z); int ret = mx[y]; rt[c] = merge(merge(x, y), z); return ret; } void out(int u) { if(!u) return; out(lc(u)); cout &lt;&lt; id[u] &lt;&lt; ' '; out(rc(u)); }}using bst::rt;namespace tree { int dep[N], hson[N], sz[N], top[N], fa[N], dfn[N], cnt; int build(int u, int f) { dep[u] = dep[f] + 1, hson[u] = 0, fa[u] = f, sz[u] = 1; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v != f) { sz[u] += build(v, u); if(sz[v] &gt; sz[hson[u]]) hson[u] = v; } } return sz[u]; } void decom(int u, int t) { top[u] = t, dfn[u] = ++cnt; if(hson[u]) decom(hson[u], t); for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v != hson[u] &amp;&amp; !dfn[v]) decom(v, v); } } int getsum(int u, int v) { int c = belief[u], tot = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); tot += bst::getsum(dfn[top[u]], dfn[u], c); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); tot += bst::getsum(dfn[u], dfn[v], c); return tot; } int getmax(int u, int v) { int c = belief[u], ret = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret = max(ret, bst::getmax(dfn[top[u]], dfn[u], c)); u = fa[top[u]]; } if(dep[u] &gt; dep[v]) swap(u, v); ret = max(ret, bst::getmax(dfn[u], dfn[v], c)); return ret; }}using tree::dfn;int main() { srand(time(0)); ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; w[i] &gt;&gt; c[i]; } for(int i = 1, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; g.add(x, y); g.add(y, x); } tree::build(1, 0); tree::decom(1, 1); for(int i = 1; i &lt;= n; i++) { bst::insert(rt[c[i]], dfn[i], w[i]); belief[i] = c[i]; } string op; int x, y; for(int i = 1; i &lt;= q; i++) { cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; int a = 0, b = 0, c = 0; if(op[1] == 'C') { bst::split(rt[belief[x]], dfn[x] - 1, a, b); bst::split(b, dfn[x], b, c); bst::rt[belief[x]] = bst::merge(a, c); bst::insert(rt[y], dfn[x], bst::val[b]); belief[x] = y; } else if(op[1] == 'W') { bst::split(rt[belief[x]], dfn[x] - 1, a, b); bst::split(b, dfn[x], b, c); bst::val[b] = bst::mx[b] = bst::tot[b] = y; rt[belief[x]] = bst::merge(bst::merge(a, b), c); } else if(op[1] == 'S') { cout &lt;&lt; tree::getsum(x, y) &lt;&lt; '\\n'; } else if(op[1] == 'M') { cout &lt;&lt; tree::getmax(x, y) &lt;&lt; '\\n'; } } return 0;} Note 4.25 KB...","link":"/2021/05/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3313-%5BSDOI2014%5D%E6%97%85%E8%A1%8C/"},{"title":"【题解】P3358 最长k可重区间集问题","text":"Des 给定实直线 \\(\\text{L}\\) 上 \\(n\\) 个开区间组成的集合 \\(\\mathbf{I}\\)，和一个正整数 \\(k\\)，试设计一个算法，从开区间集合 \\(\\mathbf{I}\\) 中选取出开区间集合 \\(\\mathbf{S}\\subseteq\\mathbf{I}\\)，使得在实直线 \\(\\text{L}\\) 上的任意一点 \\(x\\)，\\(\\mathbf{S}\\) 中包含 \\(x\\) 的开区间个数不超过 \\(k\\)，且 \\(\\sum_{z\\in\\mathbf{S}}\\lvert z\\rvert\\) 达到最大（\\(\\lvert z\\rvert\\) 表示开区间 \\(z\\) 的长度）。 这样的集合 \\(\\mathbf{S}\\) 称为开区间集合 \\(\\mathbf{I}\\) 的最长 \\(k\\) 可重区间集。\\(\\sum_{z\\in\\mathbf{S}}\\lvert z\\rvert\\) 称为最长 \\(k\\) 可重区间集的长度。 对于给定的开区间集合 \\(\\mathbf{I}\\) 和正整数 \\(k\\)，计算开区间集合 \\(\\mathbf{I}\\) 的最长 \\(k\\) 可重区间集的长度。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，\\(1\\le n\\le 500\\)，\\(1\\le k\\le 3\\)。 Sol 本题仍然是“一流对多流”的题型。套用 志愿者招募 的解法，你会发现方便统计的“不工作”（在本题中是不包含 \\(x\\) 的开区间）的流量限制形似 \\(f\\ge x\\)。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//AC100 Count:1#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5e3+5,M=(5e4+5)*2;int n,m,s,t,maxFlow,minCost,inf=0x7f7f7f7f;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}struct edges { int u[M],v[M],w[M],c[M]; int head[N],nxt[M],edgeCnt; void add(const int &amp;gu,const int &amp;gv,const int &amp;gw,const int &amp;gc) { u[++edgeCnt]=gu,v[edgeCnt]=gv,w[edgeCnt]=gw,c[edgeCnt]=gc; nxt[edgeCnt]=head[gu],head[gu]=edgeCnt; }}g;int dis[N],flow[N],pre[N],vis[N];queue&lt;int&gt; q;bool spfa() { memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); q.push(s); vis[s]=1; dis[s]=0; flow[s]=0x7f7f7f7f; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int i=g.head[u];i;i=g.nxt[i]) { int &amp;v=g.v[i],&amp;w=g.w[i],&amp;c=g.c[i]; if(w &amp;&amp; dis[v]&gt;dis[u]+c) { dis[v]=dis[u]+c; pre[v]=i; flow[v]=min(flow[u],w); if(!vis[v]) { vis[v]=1; q.push(v); } } } } if(dis[t]==0x7f7f7f7f) return false; else return true;}void EK() { int u=t; maxFlow+=flow[t]; minCost+=flow[t]*dis[t]; while(u!=s) { int i=pre[u]; g.w[i]-=flow[t]; g.w[i^1]+=flow[t]; u=g.v[i^1]; }}int main() { g.edgeCnt=1; n=read(),m=read(); s=0,t=n+2; int u,v,c; for(int i=1;i&lt;=n;i++) { int tmp=read(); g.add(i,i+1,inf-tmp,0); g.add(i+1,i,0,0); } for(int i=1;i&lt;=m;i++) { u=read(),v=read(),c=read(); g.add(u,v+1,inf,c); g.add(v+1,u,0,-c); } g.add(0,1,inf,0); g.add(1,0,0,0); g.add(n+1,n+2,inf,0); g.add(n+2,n+1,0,0); while(spfa()) EK(); cout&lt;&lt;minCost&lt;&lt;endl; return 0;}","link":"/2021/04/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3358-%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98/"},{"title":"【题解】P3811 【模板】乘法逆元","text":"Des 给定 \\(n,p\\) 求 \\(1\\sim n\\) 中所有整数在模 \\(p\\) 意义下的乘法逆元。 Sol 若 \\[ ax\\equiv1\\pmod p,\\tag1 \\] 其中 a,p,x 为整数,则称 x 为 \\(a\\bmod p\\) 的逆元. 由(1)得 \\[ x\\equiv\\frac 1a\\pmod p. \\] 那么在计算 \\(b\\div a\\bmod p\\) 时,可以用 \\(ax\\bmod p\\) 进行替换,也就是说 \\[ b\\div a\\equiv ax\\pmod p. \\] 可以发现,逆元就是用来帮助我们解决模意义下的除法的. 回到这道题本身,有几种不同的方法都可以来求逆元. 扩展欧几里得 将(1)转换为不定方程 \\[ ax+py=1 \\] 就可以用扩展欧几里得求解. 但是普通的扩欧是过不了这道题的. 无论你怎么卡常都不了(别问我怎么知道的) ! 但是我不甘心啊,明明看起来是 \\(n\\log n\\) 的方法却过不了 \\(3\\times 10^6\\) 的数据. 于是,我查到了中国古代数学家秦九韶发明的大衍求一术. 照着思想写出了代码,然后就 A 了这道题. 但是我暂时还解释不了这里面具体的思想,等到后面再来解决这个问题. 需要注意,左下角其实是在求解 \\(-ax\\equiv1\\pmod p\\),所以 return 的时候要取反. My code 大衍求一术 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//论中国古人的智慧 #include &lt;bits/stdc++.h&gt;using namespace std;int i,p;int a[3][3];//ax = 1 (mod p)//可以求解 p 不是质数的情况int dayan(int x,int p) { a[0][1]=x,a[1][1]=p; a[0][0]=1,a[1][0]=0; int sta=1; while(a[0][1]!=1 &amp;&amp; a[1][1]!=1 &amp;&amp; a[0][1]!=0 &amp;&amp; a[1][1]!=0) { if(sta==1) { int s=a[1][1]/a[0][1],y=a[1][1]%a[0][1]; a[1][0]+=s*a[0][0],a[1][1]=y; sta=0; } else { int s=a[0][1]/a[1][1],y=a[0][1]%a[1][1]; a[0][0]+=s*a[1][0],a[0][1]=y; sta=1; } } if(a[0][1]==1) return a[0][0]; else if(a[1][1]==1) return -a[1][0]; else if(a[1][1]==0) return a[0][0]; else return -a[1][0];}void write(int x){ if(x&lt;0) {putchar('-');x=-x;} if(x&gt;9) write(x/10); putchar(x%10+48);}inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { int n; n=read(),p=read(); for(int i=1;i&lt;=n;i++) { write((dayan(i,p)%p+p)%p); putchar('\\n'); } return 0;}","link":"/2021/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3811-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"【题解】P3980 [NOI2008] 志愿者招募","text":"Des 申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 \\(n\\) 天才能完成，其中第 \\(i\\) 天至少需要 \\(a_i\\) 个人。布布通过了解得知，一共有 \\(m\\) 类志愿者可以招募。其中第 \\(i\\) 类可以从第 \\(s_i\\) 天工作到第 \\(t_i\\) 天，招募费用是每人 \\(c_i\\) 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。 \\(\\texttt{Data Range:}\\) \\(1\\leq n\\leq 1000\\)，\\(1\\leq m\\leq 10000\\)，题目中其他所涉及的数据均不超过 \\(2^{31}-1\\)。 Sol 本题是网络流中经典的“一流对多流”问题，网络流 24 题中的 最长k可重区间集问题 也是一个类似问题。正常思维会将一个志愿者看作一点流量，并“要求”它流过对应的天数。但志愿者们并不好控制，而且每天至少要有 \\(a_i\\) 个人这个条件也无法满足。 网络中边的容量限制只能用来限制形如 \\(f\\le x\\) 的不等式，不能限制 \\(f\\ge x\\)。由于志愿者总数是无限的，我们可以将”第 \\(i\\) 天工作的大于等于 \\(a_i\\) 个人“转换为”第 \\(i\\) 天不工作的小于等于 \\(inf-a_i\\) 个人。 统计每天不工作的也十分好办，将可以工作的一类志愿者看作 \\(l\\) 到 \\(r+1\\) 的一条边。那么如果一个志愿者在当天工作，就不会流经该节点。反之如果不工作，就会使流量加 1。 这样构造出来的图不会存在负环，且“反悔机制”合理。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//AC100 Count:1#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5e3+5,M=(5e4+5)*2;int n,m,s,t,maxFlow,minCost,inf=0x7f7f7f7f;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}struct edges { int u[M],v[M],w[M],c[M]; int head[N],nxt[M],edgeCnt; void add(const int &amp;gu,const int &amp;gv,const int &amp;gw,const int &amp;gc) { u[++edgeCnt]=gu,v[edgeCnt]=gv,w[edgeCnt]=gw,c[edgeCnt]=gc; nxt[edgeCnt]=head[gu],head[gu]=edgeCnt; }}g;int dis[N],flow[N],pre[N],vis[N];queue&lt;int&gt; q;bool spfa() { memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); q.push(s); vis[s]=1; dis[s]=0; flow[s]=0x7f7f7f7f; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int i=g.head[u];i;i=g.nxt[i]) { int &amp;v=g.v[i],&amp;w=g.w[i],&amp;c=g.c[i]; if(w &amp;&amp; dis[v]&gt;dis[u]+c) { dis[v]=dis[u]+c; pre[v]=i; flow[v]=min(flow[u],w); if(!vis[v]) { vis[v]=1; q.push(v); } } } } if(dis[t]==0x7f7f7f7f) return false; else return true;}void EK() { int u=t; maxFlow+=flow[t]; minCost+=flow[t]*dis[t]; while(u!=s) { int i=pre[u]; g.w[i]-=flow[t]; g.w[i^1]+=flow[t]; u=g.v[i^1]; }}int main() { g.edgeCnt=1; n=read(),m=read(); s=0,t=n+2; int u,v,c; for(int i=1;i&lt;=n;i++) { int tmp=read(); g.add(i,i+1,inf-tmp,0); g.add(i+1,i,0,0); } for(int i=1;i&lt;=m;i++) { u=read(),v=read(),c=read(); g.add(u,v+1,inf,c); g.add(v+1,u,0,-c); } g.add(0,1,inf,0); g.add(1,0,0,0); g.add(n+1,n+2,inf,0); g.add(n+2,n+1,0,0); while(spfa()) EK(); cout&lt;&lt;minCost&lt;&lt;endl; return 0;}","link":"/2021/04/29/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P3980-%5BNOI2008%5D-%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F/"},{"title":"【题解】P4014 分配问题","text":"Des 有 \\(n\\) 件工作要分配给 \\(n\\) 个人做。第 \\(i\\) 个人做第 \\(j\\) 件工作产生的效益为 \\(c_{ij}\\) 。试设计一个将 \\(n\\) 件工作分配给 \\(n\\) 个人做的分配方案，使产生的总效益最大。 Sol 二分图带权最大匹配，不用多说。 要求最大花费，就将所有边的属性 c 取反，和利用优先队列简单实现小根堆的方法类似。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//AC100 Count:1#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5e3+5,M=(5e4+5)*2;int n,m,s,t,maxFlow,minCost,maxCost,inf=0x3f3f3f3f;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}struct edges { int u[M],v[M],w[M],c[M]; int head[N],nxt[M],edgeCnt; void add(const int &amp;gu,const int &amp;gv,const int &amp;gw,const int &amp;gc) { u[++edgeCnt]=gu,v[edgeCnt]=gv,w[edgeCnt]=gw,c[edgeCnt]=gc; nxt[edgeCnt]=head[gu],head[gu]=edgeCnt; } void clear() { memset(head,0,sizeof head); edgeCnt=1; }}g;int dis[N],flow[N],pre[N],vis[N];queue&lt;int&gt; q;bool spfa() { memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); q.push(s); vis[s]=1; dis[s]=0; flow[s]=inf; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int i=g.head[u];i;i=g.nxt[i]) { int &amp;v=g.v[i],&amp;w=g.w[i],&amp;c=g.c[i]; if(w &amp;&amp; dis[v]&gt;dis[u]+c) { dis[v]=dis[u]+c; pre[v]=i; flow[v]=min(flow[u],w); if(!vis[v]) { vis[v]=1; q.push(v); } } } } if(dis[t]==inf) return false; else return true;}void EK() { int u=t; maxFlow+=flow[t]; minCost+=flow[t]*dis[t]; while(u!=s) { int i=pre[u]; g.w[i]-=flow[t]; g.w[i^1]+=flow[t]; u=g.v[i^1]; }}int main() { g.clear(); n=read(); s=2*n+1,t=2*n+2; int c; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { c=read(); g.add(i,j+n,1,c); g.add(j+n,i,0,-c); } } for(int i=1;i&lt;=n;i++) { g.add(s,i,1,0); g.add(i,s,0,0); g.add(i+n,t,1,0); g.add(t,i+n,0,0); } while(spfa()) EK(); cout&lt;&lt;minCost&lt;&lt;endl; maxFlow=minCost=0; for(int i=2;i&lt;=g.edgeCnt;i++) { g.c[i]=-g.c[i]; if(i&amp;1) g.w[i]=0; else g.w[i]=1; } while(spfa()) EK(); cout&lt;&lt;-minCost&lt;&lt;endl; return 0;} Note 强烈建议交换一下此题和 P4016 的难度。","link":"/2021/04/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4014-%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/"},{"title":"【题解】P4016 负载平衡问题","text":"Des \\(G\\) 公司有 \\(n\\) 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 \\(n\\) 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 Sol 1 最小费用最大流 没做出来。 主要还是对网络流的认识不够清晰。每个节点本身不应存储流量，流量应该全部从源点来。解法是建立虚拟源点与汇点，然后从 S 到每个节点连容量为该节点原有货物数量的边、费用为 0，从每个节点到 T 连容量为应有货物数量的边、费用为 0。并且，每个节点向相邻节点连容量为无限的边，费用为 1. 这样，网络的最大流一定等于所有节点的货物之和。直接排除掉了一个变量的影响。 Sol 2 数学 注意到一个性质：必定有 2 个相邻的节点不需要从对方身上获取货物。 证明 想象有若干个“波”，每个波有一个起始节点，并且波内的货物传递方向为从起始节点向某一方向传。同一起始节点最多属于 2 个波。设起始节点的个数为 k，如果 k&gt;1，那么性质显然。如果 k=1，那么 2 个波不会覆盖同一个点。因为若覆盖同一个点，一个波运送 1 点体积的货物需要的费用一定高于另一个波。在环上，2 个波的结束节点就是性质需要的 2 个节点。 证毕 这样，我们可以枚举不相互传递的 2 个相邻节点，然后变环为链，解决链上的“传递纸牌”问题。 My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//AC100 Count:1#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5e3+5,M=(5e4+5)*2;int n,m,s,t,maxFlow,minCost,a[N],inf=1e9;inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}struct edges { int u[M],v[M],w[M],c[M]; int head[N],nxt[M],edgeCnt; void add(const int &amp;gu,const int &amp;gv,const int &amp;gw,const int &amp;gc) { u[++edgeCnt]=gu,v[edgeCnt]=gv,w[edgeCnt]=gw,c[edgeCnt]=gc; nxt[edgeCnt]=head[gu],head[gu]=edgeCnt; }}g;int dis[N],flow[N],pre[N],vis[N];queue&lt;int&gt; q;bool spfa() { memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); q.push(s); vis[s]=1; dis[s]=0; flow[s]=0x7f7f7f7f; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int i=g.head[u];i;i=g.nxt[i]) { int &amp;v=g.v[i],&amp;w=g.w[i],&amp;c=g.c[i]; if(w &amp;&amp; dis[v]&gt;dis[u]+c) { dis[v]=dis[u]+c; pre[v]=i; flow[v]=min(flow[u],w); if(!vis[v]) { vis[v]=1; q.push(v); } } } } if(dis[t]==0x7f7f7f7f) return false; else return true;}void EK() { int u=t; maxFlow+=flow[t]; minCost+=flow[t]*dis[t]; while(u!=s) { int i=pre[u]; g.w[i]-=flow[t]; g.w[i^1]+=flow[t]; u=g.v[i^1]; }}int main() { g.edgeCnt=1; n=read(); s=n+1,t=n+2; int sum=0; for(int i=1;i&lt;=n;i++) { a[i]=read(); sum+=a[i]; } int k=sum/n; for(int i=1;i&lt;=n;i++) { int l=i-1,r=i+1; if(l==0) l=n; if(r==n+1) r=1; g.add(i,l,inf,1); g.add(l,i,0,-1); g.add(i,r,inf,1); g.add(r,i,0,-1); g.add(s,i,a[i],0); g.add(i,s,0,0); g.add(i,t,k,0); g.add(t,i,0,0); } while(spfa()) EK(); cout&lt;&lt;minCost&lt;&lt;endl; return 0;} Note 关于“波”的论证过程可能不太完整，但它一定是对的，且具有数学美感！","link":"/2021/04/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4016-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/"},{"title":"【题解】P4135 作诗","text":"Des 由于时间紧迫，SHY 作完诗之后还要虐 OI，于是 SHY 找来一篇长度为 \\(n\\) 的文章，阅读 \\(m\\) 次，每次只阅读其中连续的一段 \\([l,r]\\)，从这一段中选出一些汉字构成诗。因为 SHY 喜欢对偶，所以 SHY 规定最后选出的每个汉字都必须在 \\([l,r]\\) 里出现了正偶数次。而且 SHY 认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是 SHY 请 LYD 安排选法。 LYD 这种傻×当然不会了，于是向你请教…… 问题简述：给定 \\(n\\) 个不大于 \\(c\\) 的正整数 \\(a_1 \\dots a_n\\) 和 \\(m\\) 组询问，每次问 \\([l,r]\\) 中有多少个数出现正偶数次。 Sol 在昨天不愉快地 AC 了小Z的袜子后，发现一道由昨天代码改改就能过的题，自然是喜出望外！ 不管是众数，同种颜色出现数量，汉字是否出现偶数次，它们的求解过程都具有区间可加性（即每个数的出现次数）。因此 \\([l,r+1]\\) 的答案可以利用 \\([l,r]\\) 的求解过程加上 \\(O(T)\\) 的时间计算得到。总共要枚举 T 个 l 的值，每次要遍历 n 个数，总的时间复杂度就是 \\(O(NT)\\)。然后求解就很简单了，只需要判断散块上的至多 \\(2T\\) 个数是否对答案造成影响即可。块长什么的都和小Z的袜子一样，不再赘述。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5,M=1e5+5,MXT=1000;int n,c,m,cnt,T,oddCnt[MXT][MXT];int a[N],preAdd[MXT][N],bl[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int t[N],vis[N],p;void preWork() { for(int i=1;i&lt;=cnt;i++) { int st=(i-1)*T+1,ed=min(n,i*T); for(int j=st;j&lt;=ed;j++) { ++preAdd[i][a[j]]; } for(int j=1;j&lt;=n;j++) preAdd[i][j]+=preAdd[i-1][j]; } int idx=0; for(int i=1;i&lt;=cnt;i++) { for(int j=i;j&lt;=cnt;j++) { ++idx; p=0; oddCnt[i][j]=oddCnt[i][j-1]; int st=(j-1)*T+1,ed=min(n,j*T); for(int k=st;k&lt;=ed;k++) { if(vis[a[k]]!=idx) { vis[a[k]]=idx; t[++p]=a[k]; } } for(int k=1;k&lt;=p;k++) { int last=preAdd[j-1][t[k]]-preAdd[i-1][t[k]]; int now=preAdd[j][t[k]]-preAdd[i-1][t[k]]; if(last==0) { if(now!=0 &amp;&amp; now%2==0) ++oddCnt[i][j]; } else { //last!=0 if(last%2==0 &amp;&amp; now%2!=0) --oddCnt[i][j]; else if(last%2!=0 &amp;&amp; now%2==0) ++oddCnt[i][j]; } } } }}int tmpTot[N],v[N];int query(int l,int r,int idx) { int ans=0; p=0; for(;l%T!=1;l++) { if(vis[a[l]]!=idx) { vis[a[l]]=idx; tmpTot[a[l]]=1; v[++p]=a[l]; } else ++tmpTot[a[l]]; if(l==r) { for(int i=1;i&lt;=p;i++) { int tot=tmpTot[v[i]]; if(tot%2==0) ++ans; } return ans; } } for(;r%T!=0;r--) { if(vis[a[r]]!=idx) { vis[a[r]]=idx; tmpTot[a[r]]=1; v[++p]=a[r]; } else ++tmpTot[a[r]]; if(l==r) { for(int i=1;i&lt;=p;i++) { int tot=tmpTot[v[i]]; if(tot%2==0) ++ans; } return ans; } } for(int i=1;i&lt;=p;i++) { int whole=preAdd[bl[r]][v[i]]-preAdd[bl[l]-1][v[i]]; int tot=tmpTot[v[i]]+whole; if(whole==0) { if(tot!=0 &amp;&amp; tot%2==0) ++ans; } else { if(whole%2==0 &amp;&amp; tot%2==1) --ans; if(whole%2==1 &amp;&amp; tot%2==0 &amp;&amp; tot!=0) ++ans; } } ans+=oddCnt[bl[l]][bl[r]]; return ans;}int main() { n=read(),c=read(),m=read(); cnt=n/(T=max(1,(int)sqrt((double)(n)/double(m)*double(n)*2))); if(n%T!=0) ++cnt; for(int i=1;i&lt;=n;i++) { a[i]=read(); bl[i]=(i-1)/T+1; } preWork(); int l,r,last=0; for(int i=1;i&lt;=m;i++) { l=read(),r=read(); l=(l+last)%n+1,r=(r+last)%n+1; if(l&gt;r) swap(l,r); printf(&quot;%d\\n&quot;,last=query(l,r,i)); } return 0;} Note 因为 query 中数组维的顺序访问错了，RE 了 2 次。 像判断对答案影响（即很多判断是奇数还是偶数那里）这种很多逻辑嵌套的，宁可多套几层 if，也要写清晰一点。","link":"/2021/04/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4135-%E4%BD%9C%E8%AF%97/"},{"title":"【题解】P4017 最大食物链计数","text":"Des P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Sol 这道题对我来说也就那么亿点点坑,成功误解题意,以为最左端的动物只有一个,最右端的动物也只有一个,真是太符合实际啦! 拓扑排序,在路上更新路径数.需要注意如果有一个入度大于1的节点,必须等它所有的前驱被操作后才能被操作.这样不仅合乎逻辑,而且方便最后答案的统计. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e3+5,P=80112002;int n,m,u,v,in[N],out[N],lef,rig,isq[N],f[N],ans;vector&lt;int&gt; a[N];queue&lt;int&gt; q;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(),m=read(); for(int i=1;i&lt;=m;i++) { u=read(),v=read(); a[u].push_back(v); in[v]++,out[u]++; } for(int i=1;i&lt;=n;i++) { if(in[i]==0) { q.push(i); f[i]=1; } } while(!q.empty()) { u=q.front(); q.pop(); int size=a[u].size(); for(int i=0;i&lt;size;i++) { v=a[u][i]; (f[v]+=f[u])%=P; in[v]--; if(in[v]==0) { if(out[v]==0) (ans+=f[v])%=P; else q.push(v); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/02/28/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/"},{"title":"【题解】P4035 [JSOI2008]球形空间产生器","text":"Des 有一个球形空间产生器能够在 \\(n\\) 维空间中产生一个坚硬的球体。现在，你被困在了这个 \\(n\\) 维球体中，你只知道球面上 \\(n+1\\) 个点的坐标，你需要以最快的速度确定这个 \\(n\\) 维球体的球心坐标，以便于摧毁这个球形空间产生器。 Sol 首先, 在高维空间中类似圆和球的东西还能叫球吗? 仿照圆或球的定义, 这个东西应该是在 n 维空间中距离某一个点的距离为定值的点的集合. 不过我们姑且也称其为球体好了.如果 N 等于 1, 那么这个球体仅仅是一条线段, 如果 N 等于 2 ,那么它是一个圆. 由于每个给出的点到球心的距离是相等的,所以由 n+1 个点可以得到 n 个线性方程, 比如 \\[ (a_1-p_1)^2+(a_2-p_2)^2+\\dots+(a_n-p_n)^2=(b_1-p_1)^2+(b_2-p_2)^2+\\dots+(b_n-p_n)^2, \\] 展开得到 \\[ a_1^2+a_2^2+\\dots+a_n^2-b_1^2-b_2^2-\\dots-b_n^2=2(a_1-b_1)p_1+2(a_2-b_2)p_2+\\dots+2(a_n-b_n)p_n. \\] 数据保证有解, 说明 n 个点的坐标互不相同. 得到方程后用高斯消元求解即可. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=20;const double eps=1e-10; int n;struct mat { int l,c; double p[N][N]; double* operator [] (int i) {return p[i];}}in,a;inline bool fe(double x,double y) {return fabs(fabs(x)-fabs(y))&lt;eps?1:0;}//注意,这里的fabs(x)与fabs(y)的执行顺序的先后是不确定的void solve() { for(int i=1;i&lt;=n;i++) { int flag=i; for(int j=i;j&lt;=n;j++) if(fabs(a[j][i])&gt;fabs(a[flag][i])) flag=j; for(int j=1;j&lt;=n+1;j++) swap(a[i][j],a[flag][j]); if(fe(a[i][i],0)) continue; for(int j=n+1;j&gt;=i;j--) a[i][j]/=a[i][i]; for(int j=1;j&lt;=n;j++) { if(j==i) continue; double t=a[j][i]; for(int k=i;k&lt;=n+1;k++) a[j][k]-=t*a[i][k]; } }}int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n+1;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;in[i][j]; } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { a[i][j]=2*(in[i][j]-in[i+1][j]); a[i][n+1]+=in[i][j]*in[i][j]-in[i+1][j]*in[i+1][j]; } } solve(); for(int i=1;i&lt;=n;i++) printf(&quot;%.3lf &quot;,a[i][n+1]); return 0;} Note 本来一直基于 \"每个点到球心的距离相等\" 在思考, 但是发现有平方项消不掉. 突然想到求圆心坐标其实是很容易的事, 遂验证了求圆心的过程, 发现需要利用 2 条初始的方程消掉未知数的平方项.","link":"/2021/04/09/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4035-%5BJSOI2008%5D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/"},{"title":"【题解】P4145 上帝造题的七分钟2","text":"P4145 上帝造题的七分钟2 / 花神游历各国 Des 第一行一个整数\\(n\\)，代表数列中数的个数。 第二行\\(n\\)个正整数，表示初始状态下数列中的数。 第三行一个整数\\(m\\)，表示有\\(m\\)次操作。 接下来\\(m\\)行每行三个整数k,l,r， - k=0表示给\\([l,r]\\)中的每个数开平方(下取整) - k=1表示询问\\([l,r]\\)中各个数的和。 数据中有可能\\(l&lt;r\\)，所以遇到这种情况请交换l和r。 Sol 小于1e12的数开平方,最多6次就会变成1. 线段树的节点记录是否全部为1. 时间复杂度O(6n+nlogn) . My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,q; long long a[N];struct segmentTree{ int x,y;//记录询问的区间 long long ans[N&lt;&lt;2]; bool flag[N&lt;&lt;2];//flag记录是否全为1 int ls[N&lt;&lt;2],rs[N&lt;&lt;2]; void getSon() { for(int i=1;i&lt;=4*n;i++) { ls[i]=i&lt;&lt;1,rs[i]=i&lt;&lt;1|1; } } void pup(int lSon,int rSon,int p) { flag[p]=flag[lSon]&amp;flag[rSon]; ans[p]=ans[lSon]+ans[rSon]; } void build(int l,int r,int p) { if(l==r) { ans[p]=a[l]; if(a[l]==1) flag[p]=true; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,ls[p]); build(mid+1,r,rs[p]); pup(ls[p],rs[p],p); } void update(int l,int r,int p) { if(flag[p]) return; if(l==r) { ans[p]=sqrt(ans[p]); if(ans[p]==1) flag[p]=true; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p]); if(y&gt;mid) update(mid+1,r,rs[p]); pup(ls[p],rs[p],p); } long long query(int l,int r,int p) { if(l&gt;=x&amp;&amp;r&lt;=y) return ans[p]; long long res=0; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) res+=query(l,mid,ls[p]); if(y&gt;mid) res+=query(mid+1,r,rs[p]); return res; }}t;inline long long read(){ long long s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } t.getSon(); t.build(1,n,1); q=read(); int k; for(int i=1;i&lt;=q;i++) { k=read(),t.x=read(),t.y=read(); if(t.x&gt;t.y) swap(t.x,t.y); if(k==0) { t.update(1,n,1); } else { printf(&quot;%lld\\n&quot;,t.query(1,n,1)); } } return 0; } Note 答案和计算过程中的数据不超过long long (但是a[i],ans[i],res要开long long) l可能大于r,记得交换","link":"/2021/03/13/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4145-%E4%B8%8A%E5%B8%9D%E9%80%A0%E9%A2%98%E7%9A%84%E4%B8%83%E5%88%86%E9%92%9F2/"},{"title":"【题解】P4149 [IOI2011]Race","text":"Des 给一棵树，每条边有权。求一条简单路径，权值和等于 \\(k\\)，且边的数量最小。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，保证 \\(1\\leq n\\leq 2\\times10^5\\)，\\(1\\leq k,w_i\\leq 10^6\\)，\\(0\\leq u_i,v_i&lt;n\\)。 Sol 做这道题的路途真是曲折。。。本以为就是模版题改两下，结果发现要用桶来标记。这样可以做到 \\(O(n\\log n)\\)。我的做法理论上是 \\(O(n^2 \\log n)\\) 的，但是过了洛谷数据。lmk 的做法也是乱搞，我成功 hack 了他，然后，就用题解的方法了， \\(O(n\\log n)\\) 实在是妙。 UPD： 神犇lmk的做法！ 他尝试将 dep 作为第二关键字排序，通过了此题。我认为这样不太靠谱，就试图 hack 他，结果 hack 失败了，反而想出了对他的算法的正确性的证明。 我认为有问题的代码是这部分： 1234else{ if(b[a[l]]!=b[a[r]])minn=min(minn,dist[a[l]]+dist[a[r]]); d[a[r]]==d[a[r-1]]?r--:l++;} 这里的 else 代表了 d[a[l]]+d[a[r]]==m 的情况。当 d[a[r]]==d[a[r-1]] 时，他直接将 r--，我怀疑这会导致下面的情况发生， 如图，l1 到 l4 的 d 值均相同，设其为 \\(d_l\\)，r1 到 r5 的 d 值也相同，设其为 \\(d_r\\)。那么当发现 \\(l_1\\) 和 \\(r_5\\) 同属一子树 \\(a\\) 时，直接将 r 指针移到 \\(r_4\\)，会导致 \\(l_2\\) 无法与 \\(r_5\\) 匹配。 但事实上，舍弃掉 \\(r_5\\) 没有问题，下面是证明： 对 \\(r_4\\) 所属的子树进行分类讨论。若 \\(r_4\\) 属于子树 \\(b\\)，则 \\(l_1\\) 可以与 \\(r_4\\) 匹配，比 \\(l_2\\) 与 \\(r_5\\) 匹配更优；若 \\(r_4\\) 不属于子树 \\(b\\)，则 \\(l_2\\) 可以与 \\(r_4\\) 匹配，比 \\(l_2\\) 与 \\(r_5\\) 匹配更优。 也就是说，他的做法是对的（至少我认为这样）。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5, K = 1e6 + 5;int n, k;struct edges { int nxt[N &lt;&lt; 1], v[N &lt;&lt; 1], w[N &lt;&lt; 1], head[N], cnt; void add(int a, int b, int c) { nxt[++cnt] = head[a], head[a] = cnt; v[cnt] = b, w[cnt] = c; }}g;int root, cnt, sz[N], hsz[N], d[N], mine[K];int dep[N], minDep = 1e9, minCnt;bool vis[N];void getRoot(int u, int fa, int tot) { sz[u] = 1, hsz[u] = 0; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v == fa || vis[v]) continue; getRoot(v, u, tot); sz[u] += sz[v]; hsz[u] = max(hsz[u], sz[v]); } hsz[u] = max(hsz[u], tot - sz[u]); if(!root || hsz[u] &lt; hsz[root]) root = u;}void getDis(int u, int fa, int dis, int depth) { if(dis &gt; k) return; d[++cnt] = dis, dep[cnt] = depth; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(v == fa || vis[v]) continue; getDis(v, u, dis + g.w[i], depth + 1); }}void calc(int u) { int subtreeCnt = 0; d[cnt = 1] = 0, dep[cnt] = 0, mine[0] = 0; for(int i = g.head[u]; i; i = g.nxt[i]) { subtreeCnt = cnt; int &amp;v = g.v[i]; if(vis[v]) continue; getDis(v, u, g.w[i], 1); for(int j = subtreeCnt + 1; j &lt;= cnt; j++) minDep = min(minDep, mine[k - d[j]] + dep[j]); for(int j = subtreeCnt + 1; j &lt;= cnt; j++) mine[d[j]] = min(mine[d[j]], dep[j]); } for(int i = 1; i &lt;= cnt; i++) mine[d[i]] = 1e9;}void solve(int u) { vis[u] = true; calc(u); for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(vis[v]) continue; root = 0; getRoot(v, u, sz[v]); solve(root); }}int main() { freopen(&quot;ioi2011-race.in&quot;, &quot;r&quot;, stdin); freopen(&quot;ioi2011-race.out&quot;, &quot;w&quot;, stdout);// srand(1); #ifdef ONLINE_JUDGE ios::sync_with_stdio(false); cin.tie(0); #endif cin &gt;&gt; n &gt;&gt; k; for(int i = 1, u, v, w; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; ++u, ++v; g.add(u, v, w), g.add(v, u, w); } root = 0; memset(mine, 0x3f, sizeof mine); hsz[0] = 1e9; getRoot(1, 0, n); solve(root); if(minDep == 1e9) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; minDep &lt;&lt; '\\n'; return 0;}","link":"/2021/05/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4149-%5BIOI2011%5DRace/"},{"title":"【题解】P4281 [AHOI2008]紧急集合","text":"Des 欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 \\(n\\) 个等待点，有 \\(n-1\\) 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。 参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 \\(n\\) 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。 小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？ Sol 3 人分别在\\(x,y,z\\)点.假设\\(LCA(x,y,z)=m\\),那么,答案点\\(u\\)必然在由\\((x,m),(y,m),(z,m)\\)组成的点集\\(V\\)上.当\\((u,x),(u,y),(u,z)\\)互不相交时,就是最优答案.而这个\\(u\\)必然是\\(LCA(x,y),LCA(y,z),LCA(x,z)\\).中的一个. 以上就是对做法的简单证明,做得时候当然不是这么想的完全靠直觉 代码太丑,忍忍算了. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt; using namespace std;const int N=5e5+5;int n,m;vector&lt;int&gt; g[N];inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace LCA { int lg[N&lt;&lt;2],dep[N],f[N][20]; void pre() { for(int i=1;i&lt;19;i++) ++lg[1&lt;&lt;i]; for(int i=3;i&lt;=n;i++) lg[i]+=lg[i-1]; } void dfs(int u,int fa) { dep[u]=dep[fa]+1,f[u][0]=fa; for(int i=1;i&lt;=lg[dep[u]];i++) f[u][i]=f[f[u][i-1]][i-1]; int len=g[u].size(); for(int i=0;i&lt;len;i++) if(g[u][i]!=fa) dfs(g[u][i],u); } int get(int x,int y) { if(dep[x]&gt;dep[y]) swap(x,y); while(dep[y]&gt;dep[x]) y=f[y][lg[dep[y]-dep[x]]]; if(x==y) return x; for(int i=lg[dep[x]];i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; }}int dist(int x,int y) { int anc=LCA::get(x,y); return LCA::dep[x]+LCA::dep[y]-2*LCA::dep[anc];}int solve(int x,int y,int z) { int anc1=LCA::get(x,y),anc2=LCA::get(x,z),anc3=LCA::get(y,z); int dep1=LCA::dep[x]+LCA::dep[y]-2*LCA::dep[anc1]; int dep2=LCA::dep[x]+LCA::dep[z]-2*LCA::dep[anc2]; int dep3=LCA::dep[y]+LCA::dep[z]-2*LCA::dep[anc3]; dep1+=dist(anc1,z),dep2+=dist(anc2,y),dep3+=dist(anc3,x); int minD=min(dep1,min(dep2,dep3)); if(minD==dep1) printf(&quot;%d &quot;,anc1); else if(minD==dep2) printf(&quot;%d &quot;,anc2); else if(minD==dep3) printf(&quot;%d &quot;,anc3); return minD;}int main() { n=read(),m=read(); int u,v; for(int i=1;i&lt;n;i++) { u=read(),v=read(); g[u].push_back(v),g[v].push_back(u); } LCA::pre(),LCA::dfs(1,0); int x,y,z; for(int i=1;i&lt;=m;i++) { x=read(),y=read(),z=read(); printf(&quot;%d\\n&quot;,solve(x,y,z)); } return 0;} Note 其实这个问题还可以拓展一下,即树上\\(n\\)个点到1一个点路径和最短.太麻烦了我也不会","link":"/2021/03/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4281-%5BAHOI2008%5D%E7%B4%A7%E6%80%A5%E9%9B%86%E5%90%88/"},{"title":"【题解】P4168 [Violet]蒲公英","text":"Des 在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。 为了简化起见，我们把所有的蒲公英看成一个长度为 \\(n\\) 的序列 \\(\\{a_1,a_2..a_n\\}\\)，其中 \\(a_i\\) 为一个正整数，表示第 \\(i\\) 棵蒲公英的种类编号。 而每次询问一个区间 \\([l, r]\\)，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。 注意，你的算法必须是在线的。 Sol 使用《算法竞赛进阶指南》上对这道题的第二种解法。 一个询问的答案只能出自长块的众数和散块的任意数，那么我们可以预处理出任意由整块构成的区间的众数和任意区间内某数的个数。 求解整块区间的众数：虽然“众数”这个处理后得到的答案不具有区间可加性，但求解过程（即每个数出现的次数）具有区间可加性。所以 \\([i,j+1]\\) 块区间的答案可以利用 \\([i,j]\\) 处理好的过程加上 \\(O(T)\\) 的时间求解得到。 求解任意区间内某数的个数：对所有数建立一个 vector，将该数出现的下标放进 vector。在 vector 中二分查找得到最接近 \\([l,r]\\) 的下标，再相减计算。 这样做的时间复杂度应该是 \\(O(\\frac NT\\cdot \\frac NT \\cdot T+MT\\log N)=O(\\frac {N^2} T M\\log N)\\)，把 M 视作 N，算出来块的大小是 \\(T=\\sqrt {\\frac {N} {2\\log N}}\\)。 书上说 \\(T=\\sqrt {N\\log N}\\)，但会超时。可能是写法的问题。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=40005,M=50005,MXT=1200;int n,m,len,T,cnt,last;int a[N],u[N],pos[N],bl[N],t[N]; //u是sort+unique后的a数组,pos存储蒲公英的品种 int mode[MXT][MXT],modeCnt[MXT][MXT];vector&lt;int&gt; line[N];inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void preWork() { for(int i=0;i&lt;cnt;i++) { memset(t,0,sizeof t); int mxp=0,mxn=0; for(int j=i;j&lt;cnt;j++) { int st=max(1,j*T+1),ed=min(n,(j+1)*T); for(int k=st;k&lt;=ed;k++) { int p=pos[k]; t[p]++; if(t[p]==mxn &amp;&amp; a[k]&lt;mxp) mxp=a[k]; else if(t[p]&gt;mxn) mxn=t[p],mxp=a[k]; } mode[i][j]=mxp; modeCnt[i][j]=mxn; } } for(int i=1;i&lt;=n;i++) { line[pos[i]].push_back(i); }}int query(int l,int r) { int st=l,ed=r,mxn=0,mxp=0; for(;st%T!=1;st++) { int x=lower_bound(line[pos[st]].begin(),line[pos[st]].end(),l)-line[pos[st]].begin(); int y=upper_bound(line[pos[st]].begin(),line[pos[st]].end(),r)-line[pos[st]].begin()-1; if(y-x+1&gt;mxn) mxn=y-x+1,mxp=a[st]; else if(y-x+1==mxn &amp;&amp; a[st]&lt;mxp) mxp=a[st]; if(st==ed) return last=mxp; } for(;ed%T!=0;ed--) { int x=lower_bound(line[pos[ed]].begin(),line[pos[ed]].end(),l)-line[pos[ed]].begin(); int y=upper_bound(line[pos[ed]].begin(),line[pos[ed]].end(),r)-line[pos[ed]].begin()-1; if(y-x+1&gt;mxn) mxn=y-x+1,mxp=a[ed]; else if(y-x+1==mxn &amp;&amp; a[ed]&lt;mxp) mxp=a[ed]; if(ed==st) return last=mxp; } st=bl[st],ed=bl[ed]; if(modeCnt[st][ed]&gt;mxn) mxn=modeCnt[st][ed],mxp=mode[st][ed]; else if(modeCnt[st][ed]==mxn &amp;&amp; mode[st][ed]&lt;mxp) mxp=mode[st][ed]; return last=mxp;}int main() { n=read(),m=read(); T=max(1,(int)sqrt(double(n)/(2.0*log2(double(n))))); cnt=n/T; if(n%T!=0) ++cnt; for(int i=1;i&lt;=n;i++) { a[i]=read(); u[i]=a[i]; bl[i]=(i-1)/T; } sort(u+1,u+n+1); len=unique(u+1,u+n+1)-u; for(int i=1;i&lt;=n;i++) pos[i]=lower_bound(u+1,u+len+1,a[i])-u; preWork(); int l,r; for(int i=1;i&lt;=m;i++) { l=read(),r=read(); l=(l+last-1)%n+1,r=(r+last-1)%n+1; if(l&gt;r) swap(l,r); printf(&quot;%d\\n&quot;,query(l,r)); } return 0;} Note 对拍大法好！","link":"/2021/04/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4168-%5BViolet%5D%E8%92%B2%E5%85%AC%E8%8B%B1/"},{"title":"【题解】P4305 【[JLOI2011]不重复数字】","text":"前言:本题解为洛谷P4305,JLOI2011,BZOJ2761不重复数字的题解.方法: 字符串哈希 排序 Des:P4305 [JLOI2011]不重复数字 Sol1:多关键字排序 输入时记录每个元素的idx和num. 首先按照大小排序,去重.再按照原先的idx排序,得到答案. My code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define INF 1e9;using namespace std;const int N=5e4+5;int t,n;struct element{ int num,idx;}a[N];bool cmp_num(const element &amp;a,const element &amp;b){ if(a.num==b.num) return a.idx&lt;b.idx; else return a.num&lt;b.num;}bool cmp_idx(const element &amp;a,const element &amp;b){ return a.idx&lt;b.idx;}inline int read(){ int s=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ t=read(); for(int i=1;i&lt;=t;i++) { n=read(); for(int j=1;j&lt;=n;j++) { a[j].num=read(); a[j].idx=j; } sort(a+1,a+n+1,cmp_num); int tmp=a[1].num; for(int j=2;j&lt;=n;j++) { if(a[j].num==tmp) { a[j].num=a[j].idx=INF; } else tmp=a[j].num; } sort(a+1,a+n+1,cmp_idx); for(int j=1;j&lt;=n;j++) { if(a[j].num==1e9) break; printf(&quot;%d &quot;,a[j].num); } putchar('\\n'); } return 0;} Sol 2:使用vector进行字符串哈希 关于hash表的部分大家可以看一看其他的题解，我就不说了 不定长数组vector的几个基本用法： 定义: vector&lt;数据类型&gt; 数组名称 访问: a[pos]//访问a数组下标为pos的元素 尾部加入元素: a.push_back(x) 判断是否为空: a.empty()//空返回true,非空返回false 代码: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n,hash_num=50021,t,temp;vector&lt;int&gt; a[50022];int main(){ ios::sync_with_stdio(false); //快速读入 cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; memset(a,0,sizeof(a));//重置hash表 for(int j=1;j&lt;=n;j++) { cin&gt;&gt;temp;//输入当前数据 int hash=temp%hash_num;//hash过程 bool pd=false; if(a[hash].empty()==false) { for(int k=0;k&lt;a[hash].size();k++) { if(a[hash][k]==temp)//判断hash表中是否有当前元素 pd=true; } } else if(pd==false) { a[hash].push_back(temp);//如果hash表中没有,加入hash表并输出 printf(&quot;%d &quot;,temp); } } printf(&quot;\\n&quot;); }}","link":"/2019/12/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4305%20%E3%80%90%5BJLOI2011%5D%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91/"},{"title":"【题解】P4933 大师","text":"Des P4933 大师 Sol 哇这道题...咳咳...想挑战一下蓝题DP,结果写得让人烦躁.明明感觉算法是对的,但怎么也过不了第2个样例,偏偏第2个样例又那么大,不好调试(侧面显示出我的能力不行).最后看了题解才写出来.我的思路和题解里\\(O(n^2)\\)算法的一样.但是细节处理上显然不够老道. \\(f[i][h]\\)表示第i个电塔为等差数列的最后一个电塔,公差为h的长度.ans需要在dp过程中累加. 为什么呢?发现规律:等差数列的长度每增加1,若原来的长度为l,总方案数增加l.所以在一个电塔可以\"接在\"一个等差数列的后面时,更新答案.为什么不能等所有的电塔处理完后,操作各个等差数列的长度呢?样例1就是一个很好的说明.如果你想要的操作最后的长度,就必须给之前没有用的长度打上标记,但是样例1中2个34都可以接在27的后面,无论打不打标记都无法满足需求. 回到正解,当\\(f[j][v]\\)可以从\\(f[j][h]\\)更新时,显然,方案数会增加\\(f[j][h]\\).这就是本题的核心思想. 在代码实现中,我们的\\(f[i][j]\\)默认初始化为0,实际上长度是1,所以将上面的方案数增加\\(f[j][h]\\)更改为方案数增加\\(f[j][h]+1\\). 对于公差为负数的等差数列,看做是逆序的公差为正数的等差数列,倒着DP一遍即可. 还有一个坑点,\\(f[j][v]\\)可能从2个不同的\\(f[j][h]\\)更新(例:1 3 5 3 5 7,7从2个5都可以更新,而答案都存在\\(f[j][v]\\)里!),所以不能简单的使用如下代码: 12f[i][a[i]-a[j]]=f[j][a[i]-a[j]]+1;ans+=f[i][a[i]-a[j]]; 应该这样做: 12f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+1;ans+=f[j][a[i]-a[j]]+1; 就是因为这个我才卡了那么久 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005,V=20005;int n,a[N],f[N][V];long long ans,P=998244353;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;i;j++) { if(a[i]-a[j]&gt;=0) { f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+1; f[i][a[i]-a[j]]%=P; ans+=f[j][a[i]-a[j]]+1; ans%=P; } } } memset(f,0,sizeof f); for(int i=n;i&gt;=1;i--) { for(int j=n;j&gt;i;j--) { if(a[i]-a[j]&gt;0) { f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+1; f[i][a[i]-a[j]]%=P; ans+=f[j][a[i]-a[j]]+1; ans%=P; } } } (ans+=n)%=P; cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note 莫等闲,没法敲代码,自伤悲","link":"/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4933-%E5%A4%A7%E5%B8%88/"},{"title":"【题解】P4995 跳跳！","text":"Des 你是一只小跳蛙，你特别擅长在各种地方跳来跳去。 这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 \\(i\\) 块的石头高度为 \\(h_i\\)，地面的高度是 \\(h_0 = 0\\)。你估计着，从第 \\(i\\) 块石头跳到第 \\(j\\) 块石头上耗费的体力值为 \\((h_i - h_j) ^ 2\\)，从地面跳到第 \\(i\\) 块石头耗费的体力值是 \\((h_i) ^ 2\\)。 为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费尽可能多的体力值。 当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。 不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。 那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！ Sol 2018年写了40分钟没过的题 假设我们站在石头 \\(u\\)，离它最远的是石头 \\(v\\)。那么现在跳到石头 \\(v\\) 一定最优，这就是本题的贪心策略。 简要证明一下：不可否认的是，在将来的某一个时刻，一定会跳到 \\(v\\)，假设路径是 \\(u,s_1,s_2,\\dots,s_n,v\\) ，而不是 \\(u,v\\)。这样的跳法对答案的贡献比 \\(u,v\\) 小，并且会对之后的决策产生负贡献（多跳了一些节点）。 My code 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=305;int n,a[N];ll sum;int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); for(int i=1;i&lt;=n/2;i++) { sum+=(a[n-i+1]-a[i-1])*(a[n-i+1]-a[i-1]); sum+=(a[n-i+1]-a[i])*(a[n-i+1]-a[i]); } if(n&amp;1) sum+=(a[n/2]-a[n/2+1])*(a[n/2]-a[n/2+1]); cout&lt;&lt;sum; return 0;}","link":"/2021/04/16/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4995-%E8%B7%B3%E8%B7%B3%EF%BC%81/"},{"title":"【题解】P5027 Barracuda","text":"Des 大三角形给小正方形讲起自己的过去：过去的它是一个挖宝工，后来被黑暗之主污染才会落到此番境地。 它也希望小正方形去战胜黑暗之主，不过限于黑暗之主的眼线密布，因此必须给小正方形设置障碍才能骗过那些“眼线”。 他给小正方形的问题是：它有 \\(n\\) 个小三角形，每个小三角形有一定的质量，它对这些三角形进行了 \\(n + 1\\) 次称量，然而由于托盘天平(?)的问题，有一次称量的结果是有误的。 现在，大三角形想要知道最重的小三角形的 编号。 一组输入是合法的，当且仅当输入满足以下条件： 不存在一组 \\(i\\),\\(j\\)，使得当我们假定第 \\(i\\) 条称量数据有误时能求出一种合法方案且我们假定第 \\(j\\) 条称量数据有误时也能求出一种合法方案。 合法方案定义如下： 1、最重的三角形只有一个。 2、不存在重量不确定的三角形。 3、所有三角形的重量均为正整数。 Sol 原来 \\(O(n^4)\\) 的极限数据是 \\(n=100\\) , 我以为只能用 \\(O(n^3)\\) 过... 好吧 , 直接口胡一个做法, 改了许久, 编程复杂度实在太高了, 遂放弃. 然后看题解, 呵呵. 正解: 暴力枚举错误的行, 然后高斯消元, 判断是否合法即可. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt; #include &lt;algorithm&gt;using namespace std;const int N=110;const double eps=1e-8;int n,m,maxf;struct mat { int l,c; double p[N][N]; double* operator [] (int i) {return p[i];}}a;inline bool fe(double x,double y) {return (fabs(fabs(x)-fabs(y))&lt;eps)?1:0;}bool ok() { int mt=0,t=0; double maxx=-1; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) if(fe(a[i][j],0)) ++t; if(t==0) return false; if(a[i][n+1]&lt;0) return false; if(fe(int(a[i][n+1]),a[i][n+1])==false) return false; if(fe(maxx,a[i][n+1])) mt++; else if(a[i][n+1]&gt;maxx) mt=1,maxx=a[i][n+1],maxf=i; } if(mt&gt;=2) return false; return true;}int solve() { for(int i=1;i&lt;=n;i++) { int flag=i; for(int j=i;j&lt;=n;j++) if(fabs(a[j][i])&gt;fabs(a[flag][i])) flag=j; for(int j=1;j&lt;=n+1;j++) swap(a[i][j],a[flag][j]); if(fe(a[i][i],0)) return 0; for(int j=n+1;j&gt;=i;j--) a[i][j]/=a[i][i]; for(int j=1;j&lt;=n;j++) { if(j==i) continue; double t=a[j][i]; for(int k=i;k&lt;=n+1;k++) a[j][k]-=t*a[i][k]; } } return 1;}int main() { cin&gt;&gt;n; for(int i=1,w;i&lt;=n+1;i++) { cin&gt;&gt;m; for(int j=1,idx;j&lt;=m;j++) cin&gt;&gt;idx,++a[i][idx]; cin&gt;&gt;w,a[i][n+1]=w; } mat pre=a; int oki=0,okc=0; for(int i=1;i&lt;=n+1;i++) { a=pre; for(int j=1;j&lt;=n+1;j++) swap(a[i][j],a[n+1][j]); if(solve()&amp;&amp;ok()) oki=maxf,okc++; } if(okc&gt;=2 || okc==0) printf(&quot;illegal&quot;); else printf(&quot;%d&quot;,oki); return 0;}","link":"/2021/04/09/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5027-Barracuda/"},{"title":"【题解】P5058 [ZJOI2004]嗅探器","text":"Des 某军搞信息对抗实战演习，红军成功地侵入了蓝军的内部网络。 蓝军共有两个信息中心，红军计划在某台中间服务器上安装一个嗅探器，从而能够侦听到两个信息中心互相交换的所有信息。 但是蓝军的网络相当的庞大，数据包从一个信息中心传到另一个信息中心可以不止有一条通路。 现在需要你尽快地解决这个问题，应该把嗅探器安装在哪个中间服务器上才能保证所有的数据包都能被捕获？ \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，\\(1\\le n\\le 2 \\times 10^5\\)，边数不超过 \\(5 \\times 10^5\\)。 Sol 定义起点为 \\(u\\)，终点为 \\(v\\) 的搜索子图是 \\(u\\rightarrow v\\) 的任何路径上的所有节点的集合。那么建出起点为 \\(u\\)，终点为 \\(v\\) 的搜索子图，然后求子图的割点即可。举个例子，如果原图长这样： 规定起点为 17，终点为 1，那么这张图的搜索子图就是： 然后在这张图上求编号最小的割点即可。 现在来讲讲详细过程。 首先建立搜索子图： 1234567891011bool dfs(int u) { vis[u] = true; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(!vis[v]) { if(v == t) tree[u] = true; // 若当前节点与 v 直接相连，将当前节点加入搜索子图 else if(dfs(v)) tree[u] = true; // 若从当前节点出发能到达 v，将当前节点加入搜索子图 } } return tree[u];} 搜索完毕后，所有使得 tree[x] = true成立的节点 \\(x\\) 就属于搜索子图。 这时，若 tree[s] == false（s 是两个中心服务器中的一个），那么显然无解。 否则，执行 tarjan 算法寻找编号最小的割点： 1234567891011121314void getCut(int u) { dfn[u] = low[u] = ++cnt; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(!tree[v]) continue; // 确保 v 在搜索子图内 if(!dfn[v]) { getCut(v); low[u] = min(low[u], low[v]); if(dfn[u] &lt;= low[v]) { if(u != s &amp;&amp; u != t) cut = min(cut, u); // 排除两个中心服务器 } } else low[u] = min(low[u], dfn[v]); }} 若找到割点，输出答案；若找不到，则无解： 12if(cut == 1e9) cout &lt;&lt; &quot;No solution\\n&quot;;else cout &lt;&lt; cut &lt;&lt; '\\n'; My code 这里的代码就不放注释了，关键的地方上面都解释过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5, M = 5e5 + 5; int n, s, t;struct edges { int v[M], nxt[M], head[N], cnt; void add(int a, int b) { nxt[++cnt] = head[a], head[a] = cnt, v[cnt] = b; }}g;int dfn[N], low[N], tree[N], cnt, cut = 1e9;void getCut(int u) { dfn[u] = low[u] = ++cnt; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(!tree[v]) continue; if(!dfn[v]) { getCut(v); low[u] = min(low[u], low[v]); if(dfn[u] &lt;= low[v]) { if(u != s &amp;&amp; u != t) cut = min(cut, u); } } else low[u] = min(low[u], dfn[v]); }}int ans = 1e9;bool vis[N];bool dfs(int u) { vis[u] = true; for(int i = g.head[u]; i; i = g.nxt[i]) { int &amp;v = g.v[i]; if(!vis[v]) { if(v == t) tree[u] = true; else if(dfs(v)) tree[u] = true; } } return tree[u];}int main() { cin &gt;&gt; n; int u, v; while(cin &gt;&gt; u &gt;&gt; v &amp;&amp; u) { g.add(u, v), g.add(v, u); } cin &gt;&gt; s &gt;&gt; t; dfs(s); if(tree[s]) { tree[t] = true; getCut(s); if(cut == 1e9) cout &lt;&lt; &quot;No solution\\n&quot;; else cout &lt;&lt; cut &lt;&lt; '\\n'; } else { cout &lt;&lt; &quot;No solution\\n&quot;; } return 0;} Note 本来以为要用到点双连通分量，结果发现我想错了，2 个双连通的点不一定在一个 v-dcc 里。","link":"/2021/05/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5058-%5BZJOI2004%5D%E5%97%85%E6%8E%A2%E5%99%A8/"},{"title":"【题解】P5231 [JSOI2012]玄武密码","text":"Des 经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 \\(n\\) 的序列 \\(s\\) 来描述，序列中的元素分别是 E，S，W，N，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 \\(m\\) 段文字。这里的四象，分别是东之青龙，西之白虎，南之朱雀，北之玄武，对东南西北四向相对应。 现在，考古工作者遇到了一个难题。对于每一段文字 \\(t\\)，求出其最长的前缀 \\(p\\)，满足 \\(p\\) 是 \\(s\\) 的子串。 Sol 假设在匹配的过程中,当前匹配到的字符串为\\(s\\),AC自动机会遍历了字典树中所有\\(s\\)的后缀.也就是说,AC自动机不会遗漏任何一个模式串的任何一个可匹配长度. 那么,跑一边正常的AC自动机,记录可以到达的位置.最后在trie树中把每个模式串都遍历一边,看最远匹配到了哪里. 注意主串长度较大,使用普通的存储方式(26个字母)可能会爆内存,于是把题目中的4个字母转换为4个数. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e7+5,M=1e5+5;int n,m;int to[26];char t[N],s[M][105];struct ahoCorasick{ int size; queue&lt;int&gt; q; int fail[N],reach[N]; int trie[N][4]; void insert(char *s) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { int c=to[s[i]-'A']; if(!trie[u][c]) trie[u][c]=++size; u=trie[u][c]; } } void getFail() { for(int i=0;i&lt;4;i++) { if(trie[0][i]) q.push(trie[0][i]); } while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0;i&lt;4;i++) { int v=trie[u][i]; if(v) fail[v]=trie[fail[u]][i],q.push(v); else trie[u][i]=trie[fail[u]][i]; } } } void count(char *s) { int len=strlen(s),u=0; for(int i=0;i&lt;len;i++) { u=trie[u][to[s[i]-'A']]; for(int t=u;t;t=fail[t]) { reach[t]=true; } } } int query(char *s) { int len=strlen(s),u=0,ans=0; for(int i=0;i&lt;len;i++) { int c=to[s[i]-'A']; u=trie[u][c]; if(reach[u]) ans=i+1; } return ans; }}AC;int main(){ to['E'-'A']=0,to['S'-'A']=1; to['W'-'A']=2,to['N'-'A']=3; cin&gt;&gt;n&gt;&gt;m; scanf(&quot;%s&quot;,t); for(int i=1;i&lt;=m;i++) { scanf(&quot;%s&quot;,s[i]); AC.insert(s[i]); } AC.getFail(); AC.count(t); for(int i=1;i&lt;=m;i++) { printf(&quot;%d\\n&quot;,AC.query(s[i])); } return 0;}","link":"/2021/03/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5231-%5BJSOI2012%5D%E7%8E%84%E6%AD%A6%E5%AF%86%E7%A0%81/"},{"title":"【题解】P5250 【深基17.例5】木材仓库","text":"Des P5250 【深基17.例5】木材仓库 Sol 本题解的思路和代码实现都比本题目下其他的题解要简单,希望能帮到您. 使用STL的容器set对木材实现数量统计和自动排序.数量统计可以解决第一问(具体请看下面的代码),自动排序是解决第二问的核心. 由于我们要找长度的木材在set中可能并不存在,所以使用s.lower_bound(l)查找第一根长度大于等于\\(l\\)的木材.找到的结果分为2种情况. 找到的木材长度与l相等. 找到的木材长度大于l(且是l后面第一个大于l的). 对于第一种情况,我们直接输出即可.对于第二种情况,我们需要考虑比l短的木材的长度离l的长度是否更近.根据设找到的木材位置为it,则第一个比l短的木材的位置为it-1.也就是说,我们只需要比较2根木材和l长度的差.于是便有下面的核心代码. 123456789101112int now=*it,pre=*(--it);if(abs(pre-l)&lt;=abs(now-l)){ cout&lt;&lt;pre&lt;&lt;endl; s.erase(it);}else{ cout&lt;&lt;now&lt;&lt;endl; s.erase(++it);} My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,l;set&lt;int&gt; s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;m&gt;&gt;l; if(m==1) { if(s.find(l)!=s.end()) cout&lt;&lt;&quot;Already Exist\\n&quot;;//如果在set中已经有了长度为l木材 else s.insert(l); } if(m==2) { if(s.empty()) { cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; continue; } set&lt;int&gt;::iterator it=s.lower_bound(l); if(it==s.end()) it--;//如果没有任何一个木材比l长度大,那么取长度最大的那根木材 //这里如果不处理会RE!因为s.end()返回的是set中最后一个元素的后一个的位置 if(it==s.begin())//如果仓库中只有一根木材 { cout&lt;&lt;*it&lt;&lt;endl; s.erase(it); continue; } int now=*it,pre=*(--it); if(abs(pre-l)&lt;=abs(now-l))//比较2根木材和l的差 { cout&lt;&lt;pre&lt;&lt;endl; s.erase(it); } else { cout&lt;&lt;now&lt;&lt;endl; s.erase(++it); } } } return 0;} Note end()这个函数,返回的的是容器最后一个元素所在位置的后一个位置的迭代器,RE了4次得出的教训. 本来想发在洛谷上的,其他题解的代码太臃肿了.结果写完才发现深基的题不能提交题解.Orz,洛谷.","link":"/2021/03/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5250%20%E3%80%90%E6%B7%B1%E5%9F%BA17.%E4%BE%8B5%E3%80%91%E6%9C%A8%E6%9D%90%E4%BB%93%E5%BA%93/"},{"title":"【题解】P5431 【模板】乘法逆元2","text":"Des 给定 \\(n\\) 个正整数 \\(a_i\\) 与正整数 \\(k\\)，求模 \\(p\\) 意义下的 \\[ \\sum\\limits_{i=1}^n\\frac{k^i}{a_i}. \\] \\(\\texttt{Data Range:}\\) 对于 \\(30\\) 分的数据：\\(1\\le n \\le 10^5\\) 对于全部数据：\\(1\\le n \\le 5\\times 10^6\\) ，\\(2\\le k &lt; p \\le 10^9\\) ，\\(1\\le a_i &lt; p\\) ，保证\\(p\\)为质数。 Sol \\(O(n\\log n)\\) 是没办法过这道题的，大衍求一术也不行（话说我怎么这么喜欢大衍求一术）。展开要求的式子： \\[ \\sum_{i=1}^n \\frac {k^i}{a_i}=\\frac {k^1}{a_i}+\\frac {k^2}{a_2}+\\dots +\\frac {k^n}{a_n}, \\] 很容易想到通分后就只用求一次逆元了，但这样必须要求每个 \\(\\frac {\\prod_{i=1}^n a_i}{a_k}(1\\le k\\le n)\\) 的值。我的思路就卡在这里了，认为这是无法 \\(O(1)\\) 求出来的。实际上预处理前缀积、后缀积就可以求出来。这方法也可以用于求任意 \\(\\prod_{i=1}^ka_i\\times \\prod_{i=q}^na_i(q&gt;k)\\) 的值。 另一种做法： 设 \\(s_i=\\prod_{k=1}^i a_k\\)，则 \\(\\dfrac 1{a_i}=s_{i-1}\\times \\dfrac 1{s_{i}}\\)。前缀积与前缀积的逆元都是可以用逆元模版 1 里的经典方法线性求出来的。 My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define mod(x) ((x) % p)using namespace std;typedef long long ll;const int N = 5e6 + 5;int n;ll p, k, ans, a[N], pre[N], suf[N];namespace io { #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) const int SIZ = 1 &lt;&lt; 21 | 1; char* iS, * iT, ibuff[SIZ], obuff[SIZ], * oS = obuff, * oT = oS + SIZ - 1, fu[110], c; int fr; inline void out() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template&lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; '9' || c &lt; '0') &amp;&amp; c != '-'; c = gc()); c == '-' ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= '0' &amp;&amp; c &lt;= '9'; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } template&lt;class Type&gt; inline void print(Type x, char text = '\\n') { if (x &lt; 0) * oS++ = '-', x *= -1; if (x == 0) * oS++ = '0'; while (x) fu[++fr] = x % 10 + '0', x /= 10; while (fr) * oS++ = fu[fr--]; * oS++ = text; out(); } inline void prints(char x[], char text = '\\n') { for (register int i = 0; x[i]; ++i) * oS++ = x[i]; * oS++ = text; out(); }} using namespace io;ll fpm(ll a, ll b, ll p) { ll ans = 1; while(b) { if(b &amp; 1) ans = mod(ans * a); b &gt;&gt;= 1; a = mod(a * a); } return ans % p;}int main() { read(n), read(p), read(k); for(int i = 1; i &lt;= n; i++) read(a[i]); pre[0] = 1, suf[n + 1] = 1; for(int i = 1; i &lt;= n; i++) { pre[i] = mod(pre[i - 1] * a[i]); suf[n - i + 1] = mod(suf[n - i + 2] * a[n - i + 1]); } ll kp = 1, invPro = fpm(pre[n], p - 2, p), ans = 0; for(int i = 1; i &lt;= n; i++) { kp = mod(kp * k); ll tmp = mod(kp * invPro); tmp = mod(tmp * pre[i - 1]); tmp = mod(tmp * suf[i + 1]); ans = mod(ans + tmp); } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;}","link":"/2021/05/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5431-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%832/"},{"title":"【题解】P5514 [MtOI2019]永夜的报应","text":"看了题解才知道这个性质: \\[ a \\oplus b \\le a+b \\] 粗略证明: 由 \\[ 0+0=0,0\\oplus 0=0\\\\ 1+0=1,1\\oplus 0=1\\\\ 0+1=1,0\\oplus 1=1\\\\ 1+1=2,1\\oplus 1=0 \\] 可以得到:\\(a \\oplus b \\le a+b\\)（进行运算的数二进制下每一位上都满足上述的规则） 回到题目,设分成了2组,得到结果为c,d,原数为\\(a_1,a_2,a_3,a_4\\),则\\(c + d =(a_1 \\oplus a_2)+(a_3 \\oplus a_4)\\ge a_1 \\oplus a_2 \\oplus a_3 \\oplus a_4\\) 代码: 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans,p;int main(){ cin&gt;&gt;n; cin&gt;&gt;ans; for(int i=2;i&lt;=n;i++) { cin&gt;&gt;p; ans=ans^p; } cout&lt;&lt;ans; return 0;}","link":"/2021/01/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5514%20%5BMtOI2019%5D%E6%B0%B8%E5%A4%9C%E7%9A%84%E6%8A%A5%E5%BA%94/"},{"title":"【题解】P5656 【模板】二元一次不定方程 (exgcd)","text":"Des 给定不定方程 \\[ax+by=c\\] 若该方程无整数解，输出 \\(-1\\)。 若该方程有整数解，且有正整数解，则输出其正整数解的数量，所有正整数解中 \\(x\\) 的最小值，所有正整数解中 \\(y\\) 的最小值，所有正整数解中 \\(x\\) 的最大值，以及所有正整数解中 \\(y\\) 的最大值。 若方程有整数解，但没有正整数解，你需要输出所有整数解中 \\(x\\) 的最小正整数值， \\(y\\) 的最小正整数值。 正整数解即为 \\(x, y\\) 均为正整数的解，\\(\\boldsymbol{0}\\) 不是正整数。 整数解即为 \\(x,y\\) 均为整数的解。 \\(x\\) 的最小正整数值即所有 \\(x\\) 为正整数的整数解中 \\(x\\) 的最小值，\\(y\\) 同理。 \\(\\texttt{Data Range:}\\) 对于 \\(100\\%\\) 的数据，\\(1 \\le T \\le 2 \\times {10}^5\\)，\\(1 \\le a, b, c \\le {10}^9\\)。 Sol 首先用 exgcd 求解出 \\(ax+by=\\gcd(a,b)\\) 的一组解 \\(x_1,x_2\\)，并设 \\(\\gcd(a,b)=d\\)。执行 \\(x_1\\gets x_1\\times \\cfrac cd,y_1\\gets y_1\\times \\cfrac cd\\) 来得到 \\(ax+by=c\\) 的解。若 \\(d\\) 不能整除 \\(c\\)，则说明方程无解。 设 \\(\\Delta a=\\cfrac ad,\\Delta b= \\cfrac bd\\)。当 \\(x&gt;0\\)时，需要满足 \\(x_1+k\\Delta b&gt;0\\)；当 \\(y&gt;0\\) 时，需要满足 \\(y_1-k\\Delta a&gt;0\\)。联立两个不等式，得到 \\(-\\cfrac{x_1}{\\Delta b}&lt; k &lt; -\\cfrac {-y} {\\Delta a}\\)。 若该不等式无解，说明方程无正整数解。 否则有解，当 \\(k\\) 取到两个边界时可得到 \\(y,x\\) 的最大值。 My code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int T;int exgcd(int a, int b, int &amp;x, int &amp;y) { if(b == 0) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, x, y), t = y; y = x - (a / b) * t, x = t; return d;}signed main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; T; int a, b, c; while(T--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int x, y; int d = exgcd(a, b, x, y); if(c % d != 0) cout &lt;&lt; -1 &lt;&lt; '\\n'; else { x *= (c / d), y *= (c / d); int da = a / d, db = b /d; int k1 = floor(double(-x) / double(db) + 1.0); int k2 = ceil(double(y) / double(da) - 1.0); if(k1 &gt; k2) { cout &lt;&lt; x + k1 * db &lt;&lt; ' ' &lt;&lt; y - k2 * da &lt;&lt; '\\n'; continue; } cout &lt;&lt; (k2 - k1 + 1) &lt;&lt; ' ' &lt;&lt; x + k1 * db &lt;&lt; ' ' &lt;&lt; y - k2 * da; cout &lt;&lt; ' ' &lt;&lt; x + k2 * db &lt;&lt; ' ' &lt;&lt; y - k1 * da &lt;&lt; '\\n'; } } return 0;} Note 如果要取到严格大于一个浮点数的整数，使用 floor(x + 1)；如果严格小于，使用 ceil(x - 1)。","link":"/2021/05/14/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5656-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B-(exgcd)/"},{"title":"【题解】P5657 [CSP-S2019] 格雷码","text":"T1 格雷码 首先看到这是一道普及-的题,我深表惊讶.于是决定认真想一想来测试一下我的智商是否达到了OIer准入水平,于是,我被自己的智慧所折服了~ 阅读题目我们可以发现生成的格雷码是一个长度为 2 n 2^n 2n的数列,既然放在第一题就一定有各种奇葩的简单做法,找规律又有何不可呢?(实际上,其他题解也有大佬是直接按照题意模拟的,这算是正向思维.根据生成的数列找到规律算是一种逆向思维啦) 题目中给出的 n = 3 n=3 n=3的情况对我来说还不便于寻找规律,我们把 n = 4 n=4 n=4的表列出来: 0000 , 0001 , 0011 , 0010 , 0110 , 0111 , 0101 , 0100 , 1100 , 1101 , 1111 , 1110 , 1010 , 1011 , 1001 , 1000 0000,0001,0011,0010,0110,0111,0101,0100,\\\\ 1100,1101,1111,1110,1010,1011,1001,1000 0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1111,1110,1010,1011,1001,1000 显然,每一位是 0 0 0或 1 1 1都是有规律的,考虑到生成算法是分成了2部分进行,我们可以画出一颗二叉树(我也不知道我怎么想到的): 从最下一层序号位置向上遍历,就可得到整个格雷码. 回到孩子的操作为 i d x ÷ 2 idx \\div 2 idx÷2,求得当前值为0或1的算法是: a n s p = { 1 i d x m o d 4 = = 1 o r 2 0 i d x m o d 4 = = 0 o r 3 ans_p=\\begin{cases}1\\qquad &amp;idx \\mod4==1\\ or \\ 2 \\\\ 0 \\ \\quad &amp; idx \\mod 4==0\\ or \\ 3 \\end{cases} ansp​={10​idxmod4==1or2idxmod4==0or3​ 代码: 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;unsigned long long k;int ans[70],n,p;int main(){ cin&gt;&gt;n&gt;&gt;k; p=n; while(p--) { int modx=k%4; if(modx==1||modx==2) ans[p]=1; else ans[p]=0; k/=2; } for(int i=0;i&lt;n;i++) { cout&lt;&lt;ans[i]; } return 0;}","link":"/2021/01/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5657%20%5BCSP-S2019%5D%20%E6%A0%BC%E9%9B%B7%E7%A0%81/"},{"title":"【题解】P7469 [NOI Online 2021 提高组] 积木小赛","text":"Des Alice 和 Bob 最近热衷于玩一个游戏——积木小赛。 Alice 和 Bob 初始时各有 \\(n\\) 块积木从左至右排成一排，每块积木都被标上了一个英文小写字母。 Alice 可以从自己的积木中丢掉任意多块（也可以不丢）；Bob 可以从自己的积木中丢掉最左边的一段连续的积木和最右边的一段连续的积木（也可以有一边不丢或者两边都不丢）。两人都不能丢掉自己所有的积木。然后 Alice 和 Bob 会分别将自己剩下的积木按原来的顺序重新排成一排。 Alice 和 Bob 都忙着去玩游戏了，于是想请你帮他们算一下，有多少种不同的情况下他们最后剩下的两排积木是相同的。 两排积木相同，当且仅当这两排积木块数相同且每一个位置上的字母都对应相同。 两种情况不同，当且仅当 Alice（或者 Bob）剩下的积木在两种情况中不同。 \\(\\texttt{Data Range:}1\\le n\\le 3000\\) Sol 打个 NOI Online 真的太淦了,这道题明显是唯一能做的题. 这道题没有说取模,就说明答案不是很大,不应该用 DP 做.考场上一直在用 LCS 的类似做法乱搞. 考虑到构成答案的字符串一定是 \\(t\\) 的子串,直接减小了可能的处理范围.遍历 \\(t\\) 的子串 \\(S\\) 的每一个字符,在 \\(s\\) 中寻找与其相等,且最靠左的字符.可以找出从 \\(t\\) 的 \\(i\\) 位置开始的 \\(S\\) 与 \\(s\\) 的最长匹配长度.这样就得到了 \\(n^2\\) 个合法的子串.然后哈希判断这些子串是否相等. 然后发现我甚至不会双哈希,写了个 \\(\\frac 1 2\\) 哈希,真的太菜了. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=3005;int n;int far[N];char sa[N],sb[N];void cal(int i) { int pb=i,pa=0; while(pa&lt;n) { if(sa[pa]==sb[pb]) ++pb; ++pa; } far[i]=pb-1;}namespace hash { const ll base1=131,base2=13331,mod=19260817; ll val[20000005],h1,h2; int cnt; inline void insert(const int&amp; x) { h1=(h1*base1+x)%mod,h2=(h2*base2+x)%mod; val[++cnt]=(h1&lt;&lt;30|h2); } int getAns() { sort(val+1,val+cnt+1); return unique(val+1,val+cnt+1)-val-1; }}int main() { scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s%s&quot;,sa,sb); for(int i=0;i&lt;n;++i) cal(i); for(int i=0;i&lt;n;++i) { hash::h1=hash::h2=0; for(int j=i;j&lt;=far[i];j++) { hash::insert(sb[j]); } } cout&lt;&lt;hash::getAns(); return 0;}","link":"/2021/03/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P7469-%5BNOI-Online-2021-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E7%A7%AF%E6%9C%A8%E5%B0%8F%E8%B5%9B/"},{"title":"【题解】P7517 [省选联考 2021 B 卷] 数对","text":"Des 给定 \\(n\\) 个正整数 \\(a_i\\)，请你求出有多少个数对 \\((i, j)\\) 满足 \\(1 \\le i \\le n\\)，\\(1 \\le j \\le n\\)，\\(i \\ne j\\) 且 \\(a_i\\) 是 \\(a_j\\) 的倍数。 $$ Sol 把一个数的倍数放在 vector 里，总和最大是 \\((1+\\frac 12+\\frac 13+\\dots +\\frac 1n)\\cdot 5\\times 10^5\\)，调和级数的和大概是 12，不会爆。注意如果一个数已经建立了 vector，需要对其打上标记，下次再遇到这个数只用添加 cnt。 My code 12345678910111213141516171819202122232425262728293031323334353637383940//AC100 Count:1#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e5+5,Ai=5e5;int n;vector&lt;int&gt; flag[Ai+1];int cnt[Ai+1],a[N];bool vis[Ai+1];ll ans,f[Ai+1];int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; int &amp;t=a[i]; if(!cnt[t]) { for(int j=t;j&lt;=Ai;j+=t) { flag[t].push_back(j); } } ++cnt[t]; } for(int i=1;i&lt;=n;i++) { if(!vis[a[i]]) { for(int j=flag[a[i]].size()-1;j&gt;=0;j--) { f[flag[a[i]][j]]+=cnt[a[i]]; } vis[a[i]]=true; } } for(int i=1;i&lt;=n;i++) { ans+=(f[a[i]]-1); } cout&lt;&lt;ans; return 0;}","link":"/2021/04/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P7517-%5B%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-B-%E5%8D%B7%5D-%E6%95%B0%E5%AF%B9/"},{"title":"【题解】P7521 [省选联考 2021 B 卷] 取模","text":"Des 给定 \\(n\\) 个正整数 \\(a_i\\)，请你在其中选出三个数 \\(i, j, k\\)（\\(i \\ne j\\)，\\(i \\ne k\\)，\\(j \\ne k\\)），使得 \\((a_i + a_j) \\bmod a_k\\) 的值最大。 \\(\\texttt{Data Range:}\\) 对于 \\(30 \\%\\) 的数据，\\(n \\le 100\\)。 对于 \\(60 \\%\\) 的数据，\\(n \\le 3000\\)。 对于 \\(100 \\%\\) 的数据，\\(3 \\le n \\le 2 \\times {10}^5\\)，\\(1 \\le a_i \\le {10}^8\\)。 Sol 与洛谷题解一致。 最开始只想出来 \\(O(n^2 \\log n)\\) 的做法，但说实话那个优化二也挺难想到。 可以得到一个有用的性质： 如果 \\(a&gt;\\lceil \\frac n2\\rceil,b&gt;\\lceil \\frac n2 \\rceil\\)，那么 \\(\\langle a+b\\rangle&lt;\\langle a\\rangle,\\langle b\\rangle\\). My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//AC100 Count:2#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt;::iterator vi;const int N=2e5+5;int n,a[N],ans=0;int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); vector&lt;int&gt; v; v.reserve(N); for(int i=n;i&gt;=1;i--) { if(a[i]&lt;=ans) continue; if(a[i]==a[i+1]) continue; v.clear(); for(int j=1;j&lt;=n;j++) { if(j==i) continue; v.push_back(a[j]%a[i]); } sort(v.begin(),v.end()); for(vi it=v.begin();it!=v.end();++it) { vi to=lower_bound(v.begin(),v.end(),2*a[i]-*it); if(to==v.begin()) continue; --to; if(to==it) { if(to==v.begin()) continue; else --to; } ans=max(ans,(*it+*to)%a[i]); to=lower_bound(v.begin(),v.end(),a[i]-*it); if(to==v.begin()) continue; --to; if(to==it) { if(to==v.begin()) continue; else --to; } ans=max(ans,*it+*to); } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2021/04/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P7521-%5B%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-B-%E5%8D%B7%5D-%E5%8F%96%E6%A8%A1/"},{"title":"【题解】SP1437 PT07Z - Longest path in a tree(树的直径)","text":"Des 题目描述 给你一个无权无向的树。编写程序以输出该树中最长路径（从一个节点到另一个节点）的长度。在这种情况下，路径的长度是我们从开始到目的地的遍历边数。 输入输出格式 输入格式： 输入文件的第一行包含一个整数N ---树中的节点数（0 &lt; N &lt;= 10000）。接下来N -1行包含该树的N -1个边---每行包含一对（u，v），表示在节点u和节点v之间存在边（1 &lt;= u，v &lt;= N）。 输出格式： 一行：输出最长路径的长度。 Sol 经典树的直径,具体解释去OI wiki看吧 My code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10005;int n,ans;int d1[N],d2[N];vector&lt;int&gt; g[N];void dp(int u,int fa){ int len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i]; if(v==fa) continue; dp(v,u); if(d1[v]+1&gt;d1[u]) d2[u]=d1[u],d1[u]=d1[v]+1; else if(d1[v]+1&gt;d2[u]) d2[u]=d1[v]+1; } ans=max(ans,d1[u]+d2[u]);}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;n;i++) { int u,v; cin&gt;&gt;u&gt;&gt;v; g[u].push_back(v),g[v].push_back(u); } dp(1,0); printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/03/22/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91SP1437-PT07Z---Longest-path-in-a-tree(%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84)/"},{"title":"【题解】SP300 CABLETV - Cable TV Network","text":"Des 电视电缆网络的继电器之间的连接是双向的。如果任意两个继电器之间都连通，那么这个网络就是连通的，否则不连通。特别地，一个空网络或只有一个继电器的网络是连通的。 定义一个有n个继电器的网络的安全指数f为 如果不管移除几个继电器，网络都连通，f=n 使网络不连通至少要移除的继电器数 给出t(\\(t \\le 20\\))个网络，求每个网络的安全指数(每个网络的继电器数\\(\\le 50\\))。 Sol 使用《算法竞赛进阶指南》网络流一节提到的“点转边”化技巧，可以求出任意网络的点割集。实际上，我们也可以求出任意无向图的点割集。由于”点转边化”将源点 Q 与汇点 P 连向 Q',P' 的流量设为 inf，意味着不可割断，那么我们必然需要 2 个不属于点割集的点来充当源点和汇点。 由于只有 1 个节点的无向图是连通的，那么对于一个点数大于 2 的无向图在题目定义中的“点割集” \\(S\\)，有 \\(|S|+2\\le |E|\\)（\\(E\\) 为无向图点集）。那么对于题目给出的无向图，我们可以枚举源点和汇点，将无向图建立为网络（每条边的流量为 1）。这样，我们就将问题归约到了求网络的点割集上。而对于一个点数小于等于 2 的网络，它一定不存在点割集。 再将问题扩展一下，我们现在来求有向图的点割集。 对于一个连通的有向图，删去一个或多个出度或入度为 0 的有向图，这个有向图仍然是连通的。也就是说，入度或出度为 0 的点一定不属于点割集。那么，我们可以将任意入度为 0 的点充当源点，任意出度为 0 的点充当汇点，建立网络求解。 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long ll;using namespace std;const int N=110,M=20010,inf=0x3fffffff;int d[N],a[M],b[M];int n,m,s,t;inline int read();struct edges { int u[M],v[M],w[M]; int nxt[M],head[N],cnt; void clear() { cnt=1; memset(head,0,sizeof head); } void addEdge(const int &amp;gu,const int &amp;gv,const int &amp;gw) { u[++cnt]=gu,v[cnt]=gv,w[cnt]=gw; nxt[cnt]=head[gu],head[gu]=cnt; }}g;queue&lt;int&gt; q;int nowHead[N];bool bfs() { memset(d,0,sizeof d); while(!q.empty()) q.pop(); q.push(s); d[s]=1; while(!q.empty()) { int u=q.front(); q.pop(); nowHead[u]=g.head[u]; for(int i=g.head[u];i;i=g.nxt[i]) { if(!d[g.v[i]] &amp;&amp; g.w[i]) { q.push(g.v[i]); d[g.v[i]]=d[u]+1; if(g.v[i]==t) return true; } } } return false;}int dinic(int u,int flow) { if(u==t) return flow; int rest=flow,k; for(int i=nowHead[u];i &amp;&amp; rest;i=g.nxt[i]) { if(d[g.v[i]]==d[u]+1 &amp;&amp; g.w[i]) { nowHead[u]=i; k=dinic(g.v[i],min(rest,g.w[i])); if(!k) d[g.v[i]]=0; rest-=k; g.w[i]-=k,g.w[i^1]+=k; } } return flow-rest;} int main() { int T; for(T=read();T;T--) { n=read(),m=read(); int ans=inf; for(int i=1;i&lt;=m;i++) { a[i]=read(),b[i]=read(); } for(s=0;s&lt;2;s++) { for(t=0;t&lt;n;t++) { if(s==t) continue; g.clear(); for(int i=0;i&lt;n;i++) if(i==s||i==t) g.addEdge(i,i+n,inf),g.addEdge(i+n,i,0); else g.addEdge(i,i+n,1),g.addEdge(i+n,i,0); for(int i=1;i&lt;=m;i++) { g.addEdge(a[i]+n,b[i],inf); g.addEdge(b[i],a[i]+n,0); g.addEdge(b[i]+n,a[i],inf); g.addEdge(a[i],b[i]+n,0); } int maxFlow=0,flow; while(bfs()) while((flow=dinic(s,inf))) maxFlow+=flow; if(maxFlow&lt;ans) ans=maxFlow; } } if(n&lt;=1 || ans==inf) ans=n; printf(&quot;%d\\n&quot;,ans); } return 0;}inline int read() { int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;} Note 这次的 Sol 板块感觉是写得最好的一次！","link":"/2021/04/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91SP300-CABLETV---Cable-TV-Network/"},{"title":"【题解】UVA10810 Ultra-QuickSort","text":"一个元素想要到达正确的位置,前面的元素必须比它小.也就是说,该元素至少必须和前面比自己大的元素交换一次.这道题就转化成了求逆序对. 接下来就是归并排序求逆序对的过程.代码中最重要的部分是ans+=p2-k-1.说明:若第二部分的元素进入了答案数组,说明它比第一部分还未进入答案数组的数要小,即第一部分还未进入答案数组的数的数量便是逆序对个数. Des: UVA10810 Ultra-QuickSort - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Sol: 一个元素想要到达正确的位置,前面的元素必须比它小.也就是说,该元素至少必须和前面比自己大的元素交换一次.这道题就转化成了求逆序对. 接下来就是归并排序求逆序对的过程.代码中最重要的部分是ans+=p2-k-1.说明:若第二部分的元素进入了答案数组,说明它比第一部分还未进入答案数组的数要小,即第一部分还未进入答案数组的数的数量便是逆序对个数. My code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5;int n=5e5+5,a[N],t[N];long long ans;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}void merge_sort(int l,int r){ if(l&gt;=r) return; int mid=(l+r)&gt;&gt;1; merge_sort(l,mid); merge_sort(mid+1,r); int p1=l,p2=mid+1,k=l-1;//p1,p2为2部分指针，k为答案数组指针 while(p1&lt;=mid &amp;&amp; p2&lt;=r) { if(a[p1]&lt;=a[p2]) t[++k]=a[p1++]; else ans+=p2-k-1,t[++k]=a[p2++]; } while(p1&lt;=mid) t[++k]=a[p1++]; while(p2&lt;=r) t[++k]=a[p2++]; for(int i=l;i&lt;=r;i++) { a[i]=t[i]; }}int main(){ while(n) { ans=0; n=read(); if(n==0) break; for(int i=1;i&lt;=n;i++) { a[i]=read(); } merge_sort(1,n); printf(&quot;%lld\\n&quot;,ans); } return 0;}","link":"/2021/02/22/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91UVA10810%20Ultra-QuickSort/"},{"title":"【题解】WOJ4240 约数个数","text":"Des 给出整数x，求它的约数个数 为了加大难度，有m次询问，将每次询问的答案求和然后mod 1e9+7 Sol 设 x 的标准分解式为 \\(p_1^{b_1}p_2^{b_2}\\dots p_n^{b_n}\\) ,那么 x 的约数个数为 \\((b_1+1)(b_2+1)\\dots (b_n+1)\\). 其实就是说每个质因子有指数加一中幂次选择,然后运用乘法原理得到因数个数. 观察数据范围,只能用线性筛来求解. 考虑在线性筛进行标记时处理答案. 将处理的数表为 \\(am\\) ,设 \\(m=\\prod q_i^{c_i}\\) ,我们需要知道的仅仅是当 \\(q_i=a\\) 时 \\(c_i\\) 的值.即 \\(m\\) 的最小质因子的幂次. 若找不到 \\(q_i=a\\) ,那么 \\(am\\) 的最小质因子为 \\(a\\) ,最小质因子的幂次为 1. 若找得到 \\(q_i=a\\) ,那么 \\(am\\) 的最小质因子仍然是 \\(q_i\\) ,幂次为 \\(c_i+1\\). 同时,上面 2 中情况的 \\(am\\) 因数个数也可被求解. 整理一下,我们需要记录每个数的因数个数,最小质因子以及幂次. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e7,P=1e9+7;ll m,q,a,b,c;int cnt,pri[N+10],lc[N+10];ll ans[N+10];bool nok[N+10];void sieve() { ans[1]=1; for(int i=2;i&lt;=N;i++) { if(!nok[i]) pri[++cnt]=i,lc[i]=1,ans[i]=2; for(int j=1;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=N;j++) { int v=pri[j]*i; nok[v]=true; if(i%pri[j]==0) { lc[v]=lc[i]+1,ans[v]=ans[i]/(lc[v])*(lc[v]+1); break; } lc[v]=1,ans[v]=ans[i]*2; } }}inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { cin&gt;&gt;m&gt;&gt;q&gt;&gt;a&gt;&gt;b&gt;&gt;c; sieve(); ll res=0; for(int i=1;i&lt;=m;i++) { res=(res+ans[q])%P; q=(q*a+b)%c; } printf(&quot;%lld\\n&quot;,res); return 0;}","link":"/2021/04/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91WOJ%204240-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"title":"【杂项】任务计划","text":"前言 某些题已经口胡出了解法，没来得及写，就记录在这了。也可以当作一个增强版任务计划。 图论 P5058 [ZJOI2004]嗅探器 连通性相关，点双连通分量 跑一次连通分量，再跑一次点双连通分量。 若两个中心不在一个连通分量内，或在同一个点双连通分量内，则无解。 否则，对 2 个中心所在的连通分量求割点，即为答案。 做法见该题题解。 P3469 [POI2008]BLO-Blockade 连通性问题 记录连通块大小即可。 数据结构 P2486 [SDOI2011]染色 树链剖分 线段树维护长链内答案，在向上跳的时候判断相邻的两个长链对答案的贡献。 P2146 [NOI2015] 软件包管理器 树链剖分 直接树剖 P3313 [SDOI2014]旅行 树链剖分，平衡树 给每个宗教信仰建立平衡树，求和不依靠线段树，而是依靠多根平衡树了。 数学 UVA11327 Enumerating Rational Numbers 线性筛，欧拉函数 线性筛欧拉函数板题","link":"/2021/05/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/"},{"title":"【题解】测试 210404","text":"所有代码中注释掉的部分为错误代码 A 函数 Des 对于一个整数，定义 f(x)为他的每个数位的阶乘的乘积。例如 f(135)=1!∗3!∗5!=720 给出一个数 a（可以包含前缀零），a 满足他的至少一个数位大于 1。我们要求出最大的整数 x，其中 x 不含 0 或 1，并且满足 f(a) = f(x)。 Sol 观察数据范围,显然不用对 f(x) 进行分解. 由于每个数位最大为 9 ,可以考虑找规律. 像 \\(5!=5\\times 4\\times 3\\times 2\\times 1\\) 这种,你以为它可以被拆散,然后和其它的阶乘组成更多的阶乘的乘积吗? 其实不能. 但像 \\(4!=4\\times 3\\times2\\times1=3!\\times2!\\times2!\\) 就可以.所以只需要枚举 1 到 9, 把能拆散的打表出能拆成哪几个相乘就好了. 需要注意 \\(9!=7!\\times 3!\\times 3!\\times 2!\\) ,也就是说 9 不是不可以拆.我因为这个挂掉了 50 分. 其实最稳妥的办法是先写个暴力程序看怎么拆,然后再打表. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,a,t=1;int cnt[20];int add[20][20]={ { 0 }, { 0 }, { 0,0,1 }, { 0,0,0,1 }, { 0,0,2,1 }, { 0,0,0,0,0,1 }, { 0,0,0,1,0,1 }, { 0,0,0,0,0,0,0,1 }, { 0,0,3,0,0,0,0,1 }, { 0,0,1,2,0,0,0,1 // 0,0,0,0,0,0,0,0,0,1 }};int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%1d&quot;,&amp;a); for(int i=2;i&lt;=9;i++) { cnt[i]+=add[a][i]; } } for(int i=9;i&gt;=2;i--) { for(int j=cnt[i];j&gt;=1;j--) printf(&quot;%d&quot;,i); } return 0;} B 短文评估 Des 为了维持生计，上学期期末迎考期间小可可在育红小学兼任了英语助教。首要任务就 是协助英语教研室的老师们挑选合适的短文作为寒假作业布置给小朋友们，以提高他们的 英语阅读能力。 挑选短文有一个评价标准。那就是同样长的文章，出现的单词越少越好，也就是说文 章中词汇出现的频度越高越好。小可可根据思路设计了一个评估函数： \\(e(T)=\\frac{P(T)}{Q(T)}=\\frac{\\sum_{w\\in \\Psi(T)}f(w,T)^4}{Q(T)}\\),其值越大，文章阅读难度越小。 其中：T是待评估的短文；Q(T)是短文中的单词数量，相同的单词重复计算；\\(\\Psi(T)\\) 是短文T中单词构成的集合，单词是不区分大小写的，且该集合中没有重复的元素；f(w,T) 表示单词w在短文T中出现的次数。 \\(\\sum_{w\\in \\Psi(T)}f(w,T)^4\\)表示短文T中出现的各个不同单词的出现次数的四次方和。 为了简化处理，。除了英文字母，短文中出现的数字和标点符号都不算单词，只能算作分隔符。 例如短文：The International Olympic Committee (IOC) will decide the 2012 Olympic Games host in three years at a meeting in Singapore. 这篇短文的Q(T)=19。\\(\\Psi(T)\\)是由 The，International，Olympic，Committee，IOC， will，decide，Games，host，in，three，years，at，a，meeting，Singapore 等单词构成的集合（注意：The 和 the 算同一个单词），这些单词在该短文中出现的次数分别是 2，1，2，1，1，1，1，1，1，2，1，1，1，1，1，1。 因此\\(P(T) =\\sum_{w\\in \\Psi(T)}f(w,T)^4= 13\\times 1^4+3\\times 2^4=61\\)所以该短文的评估值\\(e(T)=\\frac{P(T)}{Q(T))}=\\frac{61}{19}\\) 计算短文的评估值可不是一件轻松的事情，为了提高小可可的工作效率，请你帮她编 写一个程序，只需要求出计算短文评估值所需要的 P(T)和Q(T)。 Sol 有了 NOI Online 的经验,我们直接字符串哈希就好. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char c='a';namespace hash { const ll base=131,mod=23456789; ll val[25000000],h,P; int cnt,pre; void insert(char c) { if(isalpha(c)) { h=(h*base+tolower(c)-'a'+1)%mod; pre=1; } else { if(pre) val[++cnt]=h,h=0; pre=0; } } void getAns() { sort(val+1,val+cnt+1); ll con=0; for(int i=1;i&lt;=cnt+1;i++) { if(val[i]==val[i-1]) ++con; else { P+=con*con*con*con; con=1; } } cout&lt;&lt;P&lt;&lt;' '&lt;&lt;cnt; }}int main() { while(1) { c=getchar(); if(c==EOF) break; hash::insert(c); } hash::getAns(); return 0;} C 矩阵 Des 在麦克雷的面前出现了一个有$ n*m$ 个格子的矩阵，每个格子用“.”或“#”表示，“.”表示这个格子可以放东西，“#”则表示这个格子不能放东西。现在他拿着一条 \\(1*2\\) 大小的木棒，好奇的他想知道对于一些子矩阵，有多少种放木棒的方案。 Sol 第一眼,状压 DP ! 结果不要求铺满. 第二眼,有点复杂的动态规划! 结果只有一根木棍. 好吧,说正解. 设 (1,1) 到 (i,j) 的答案为 f[i][j] ,那么显然 f[i][j] 由 f[i-1][j] 和 f[i][j-1] 转移而来.但是这个过程会重复计算 f[i-1][j-1] ,所以需要将其减掉. 在计算答案时,如果直接套用矩阵前缀和的思想,会发现重复计算了一些横跨 2 个部分的木棍,再将它们减掉即可. 如果这里枚举行列来减掉,时间复杂度是 \\(O(QN)\\) ,有一点危险. 于是有两种解决方案. 一是用前缀和优化,二是......用 printf . 没错,考试的时候用 cout 被卡掉了 40 分. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=505;int n,m,q;int f[N][N],preh[N][N],prel[N][N];char mp[N][N];int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,mp[i]+1); for(int j=1;j&lt;=m;j++) { f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]; preh[i][j]+=preh[i][j-1]; prel[i][j]+=prel[i-1][j]; if(mp[i][j]=='.') { if(mp[i][j]==mp[i][j-1]) f[i][j]++,prel[i][j]++; if(mp[i][j]==mp[i-1][j]) f[i][j]++,preh[i][j]++; } } } scanf(&quot;%d&quot;,&amp;q); int r1,c1,r2,c2; for(int i=1;i&lt;=q;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;r1,&amp;c1,&amp;r2,&amp;c2); int ans=f[r2][c2]-f[r1-1][c2]-f[r2][c1-1]+f[r1-1][c1-1]; ans-=(preh[r1][c2]-preh[r1][c1-1]);// for(int j=c2;j&gt;=c1;j--) {// if(mp[r1][j]=='.' &amp;&amp; mp[r1-1][j]=='.') --ans;// } ans-=(prel[r2][c1]-prel[r1-1][c1]);// for(int j=r2;j&gt;=r1;j--) {// if(mp[j][c1]=='.' &amp;&amp; mp[j][c1-1]=='.') --ans;// } printf(&quot;%d\\n&quot;,ans);// cout&lt;&lt;ans&lt;&lt;endl; } return 0;} D Work Des 假设现在离 noip 还有 m 天，有 n 个人要去参加比赛。 他们每个人都有一个预定的训练量 r[i]，所以每一天他们都抓紧时间练习。 但是由于条件限制，第 i 天只有 t[i]的时间可以练习。 我们都知道，一个人在开始干活以前总要浪费一些时间做一些杂七杂八的事情。 现在我们假定第 i 个人每天在训练前浪费的时间是固定的，记为 d[i]。 这段浪费掉的时间过后，选手会专心致志训练，他们会充分利用剩下的时间。 然而一个可能的情况时，一个人还在无所事事的时候，某一天的训练时间已经过去了， 所以他那一天什么事情都没有做。 现在请问每个人在第几天的时候可以完成自己的训练任务。当然会存在志向远大但是很 懒惰的人到最后也是做不完的情况。 Sol 题目 PDF 上打错数据范围,于是所有人都打了暴力 40 分 Orz. 算法过程一定会用到对时间的求和,所以基本确定用线段树. d[i] 值从小到大的选手的答案值是单调递减的,所以可以离线询问. 但线段树上的数据很难维护. 每次更新都要判断叶子节点是否小于 0 ,也不会像 P4145 上帝造题的七分钟2 那样可以标记全部为 0 的区间. 不过,好就好在可以利用 d[i] 的单调性. 想要判断节点是否小于 0 很难,那我直接不要那个节点不就好了吗? 现将 t[i] , d[i] 从大到小排序,并维护 2 个指针.如果 t[i]-d[i]&gt;0 ,才把 t[i] 加入线段树(其实是赋值). 然后二分权值线段树就好,时间复杂度 \\(O(n\\log n)\\). My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=2e5+5; int n,m;struct day { int tim,idx; bool operator &lt; (const day &amp;b) const {return tim&gt;b.tim;}}t[N];struct person { int d,r,idx; bool operator &lt; (const person &amp;b) const {return d&gt;b.d;}}a[N];inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}namespace sg { int x,y,ans,res; ll val[N&lt;&lt;2],cnt[N&lt;&lt;2]; int ls[N&lt;&lt;2],rs[N&lt;&lt;2]; void pre() {for(int i=1;i&lt;=m&lt;&lt;2;i++) ls[i]=i&lt;&lt;1,rs[i]=i&lt;&lt;1|1;} void update(int l,int r,int p,int k) { if(l==r) {val[p]=k,cnt[p]=1;return;} int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p],k); if(y&gt;mid) update(mid+1,r,rs[p],k); val[p]=val[ls[p]]+val[rs[p]],cnt[p]=cnt[ls[p]]+cnt[rs[p]]; } void query(int l,int r,int p,ll k,ll res) { if(l==r) {ans=l;return;} int mid=(l+r)&gt;&gt;1; if(val[ls[p]]-cnt[ls[p]]*k&gt;=res) query(l,mid,ls[p],k,res); else if(val[ls[p]]+val[rs[p]]-(cnt[rs[p]]+cnt[ls[p]])*k&gt;=res) query(mid+1,r,rs[p],k,res-val[ls[p]]+cnt[ls[p]]*k); }}int main() { n=read(),m=read(); for(int i=1;i&lt;=m;i++) t[i].tim=read(),t[i].idx=i; sort(t+1,t+m+1); for(int i=1;i&lt;=n;i++) a[i].d=read(),a[i].r=read(),a[i].idx=i; sort(a+1,a+n+1); sg::pre(); int p=1,ans[N]; for(int i=1;i&lt;=n;i++) { while(t[p].tim-a[i].d&gt;=0 &amp;&amp; p&lt;=m) { sg::x=t[p].idx,sg::y=t[p].idx; sg::update(1,m,1,t[p].tim); ++p; } sg::ans=0; sg::query(1,m,1,a[i].d,a[i].r); ans[a[i].idx]=sg::ans; } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); return 0;} Note 我真的是醉了. 这道题 WA 的次数大概可以排到第一了. 先是写出 二分权值 + 线段树 的 \\(O(n\\log ^2n)\\) 的乱搞做法 WA 了几次. 然后写正解的调用线段树的函数的时候又把范围弄错了(范围应该到题目中的 m),改了十多次才发现这个问题.太淦了.","link":"/2021/04/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B5%8B%E8%AF%95-210404/"},{"title":"【题解】简单双向链表的实现&amp;新约瑟夫问题","text":"题目描述： 给定m个人，从s开始报数，数字顺加，报到n的人出列，然后数字顺减报到k的人出列，求出列顺序 样例输入： 8 1 3 2 样例输出： 3 6 1 5 2 8 4 7 分析： 约瑟夫问题主要就是处理边界，因此选用链表，第一个指向最后一个，最后一个指向第一个。 注意，这里链表不用指针！不用指针！为什么？因为m&lt;=100,链表节点数量小，可直接用数组+结构体！ q为前驱，h为后继。 完整代码如下： #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;cstdio&gt; using namespace std; int m,s,n,k,cnt,pd=true,pd2=true; struct lb { int q,h; }a[105]; void del(int x)//删除节点 { a[a[x].q].h=a[x].h; a[a[x].h].q=a[x].q; } int main() { // freopen(\"newjsf.in\",\"r\",stdin); //打开输入文件 // freopen(\"newjsf.out\",\"w\",stdout); //打开输出文件 cin&gt;&gt;m&gt;&gt;s&gt;&gt;n&gt;&gt;k; a\\[1\\].q=m,a\\[1\\].h=2,a\\[m\\].q=m-1,a\\[m\\].h=1; cnt=m; for\\(int i=2;i\\&lt;=m-1;i++\\) \\{ a\\[i\\].q=i-1,a\\[i\\].h=i+1; \\} while\\(cnt&gt;0\\) \\{ if\\(pd\\) for\\(int i=1;i\\&lt;=n;i++\\) \\{ if\\(pd2\\)//判断是否第一个人 \\{ pd2=false; continue; \\} s=a\\[s\\].h; \\} else for\\(int i=1;i\\&lt;=k;i++\\) s=a\\[s\\].q; cout\\&lt;\\&lt;s\\&lt;\\&lt;&quot; &quot;; cnt--; del\\(s\\); \\} fclose\\(stdin\\);//关闭输入文件 fclose\\(stdout\\);//关闭输出文件 }","link":"/2019/10/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%AE%80%E5%8D%95%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0&%E6%96%B0%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"},{"title":"【专题】最小生成树","text":"最小生成树 生成树:在图的边集中选择\\(n-1\\)条,使得所有顶点连通. 最小生成树指边权和最小的生成树. 其实,说是最小生成树,不如说是\"满足某个特定条件的连通子图\". 这个\"特定条件\"至少有: 任意子图边权和最大/最小 任意路径上最大/最小边最大/最小(搭配LCA) 如果你现在不理解,没有关系,做完例题就明白了. 本文介绍了求解最小生成树的Prim算法和Kruskal算法. Prim算法 将所有点分为2个点集\\(V\\)和\\(R\\),每次将\\(R\\)中dis[x]最小的点\\(x\\)抽离并加入\\(V\\)中.更新\\(x\\)连接的所有点的dis. dis[i]表示\\(min(g(m\\in V,i))\\). 与dijkstra求最短路不同,这里的dis的值仅仅是一条边,不是从源点出发到当前点的最短路. 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define INF 1e9using namespace std;const int N=5e3+5,M=2e5+5;int n,m,ans;int dis[N],vis[N];vector&lt;pair&lt;int,int&gt; &gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void prim(int x){ for(int i=1;i&lt;=n;i++) { dis[i]=INF; } int len=g[x].size(); for(int i=0;i&lt;len;i++) { dis[g[x][i].first]=min(dis[g[x][i].first],g[x][i].second); } vis[x]=true; int tot=1; while(++tot&lt;=n) { int minDis=INF,u=0; for(int i=1;i&lt;=n;i++) { if(dis[i]&lt;minDis &amp;&amp; vis[i]==false) { minDis=dis[i]; u=i; } } ans+=minDis; len=g[u].size(); for(int i=0;i&lt;len;i++) { int v=g[u][i].first,disNow=g[u][i].second; if(disNow&lt;dis[v]) { dis[v]=disNow; } } vis[u]=true; }} int main(){ n=read(),m=read(); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(),x=read(); g[u].push_back(make_pair(v,x)); g[v].push_back(make_pair(u,x)); } prim(1); for(int i=1;i&lt;=n;i++) { if(vis[i]==false) { cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; return 0; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} 时间复杂度 Prim算法可在寻找最小的dis[x]这一步优化. 暴力:\\(O(n^2+m)\\) 二叉堆优化:\\(O((n+m)\\log n)\\) 斐波纳契堆优化:\\(O(n\\log n+m)\\) Kruskal算法 将边权排序后挨个选择.设当前边连接点\\(u\\),\\(v\\).若\\(u\\)和\\(v\\)已经相连,说明添加此边会出现环,跳过.反之将\\(ans\\)加上边权. 判断2点是否已经连通用并查集实现. 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define INF 1e9using namespace std;const int N=5e3+5,M=2e5+5;int n,m,ans;struct Edge{ int u,v,l; bool operator &lt; (const Edge &amp;b) const { return l&lt;b.l; }}a[M];struct disjointSet//并查集 { int father[N],size[N]; void pre() { for(int i=1;i&lt;=n;i++) { father[i]=i; size[i]=1; } } int find(int x) { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return true; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y; return false; }}s;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(),m=read(); s.pre(); for(int i=1;i&lt;=m;i++) { a[i].u=read(),a[i].v=read(),a[i].l=read(); } sort(a+1,a+m+1); for(int i=1;i&lt;=m;i++) { if(s.merge(a[i].u,a[i].v)) { continue; } else { ans+=a[i].l; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} 时间复杂度 如果使用\\(O(m\\log m)\\)的排序算法，并且使用\\(O(m\\alpha (m,n))\\)或\\(O(m\\log n)\\)的并查集，就可以得到时间复杂度为\\(O(m\\log m)\\)的 Kruskal 算法. 例题 P2872 [USACO07DEC]Building Roads S Des 给定 \\(n\\) 个点的坐标，第 \\(i\\) 个点的坐标为 \\((x_i,y_i)\\)，这 \\(n\\) 个点编号为 \\(1\\) 到 \\(n\\)。给定 \\(m\\) 条边，第 \\(i\\) 条边连接第 \\(u_i\\) 个点和第 \\(v_i\\) 个点。现在要求你添加一些边，并且能使得任意一点都可以连通其他所有点。求添加的边的总长度的最小值。 Sol 子图边权和最小 把已经给出的边先连起来,然后把所有点之间相互连一条边,再跑Kruskal. 时间复杂度\\(O(n^2\\log n^2)\\).勉强跑过. 如果用Prim的话应该可以到\\(O(n^2)\\)?不管了. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define INF 1e9using namespace std;const int N=1e3+5,M=1e6+5;int n,m;double ans;int x[N],y[N];struct Edge{ int u,v; double l; bool operator &lt; (const Edge &amp;b) const { return l&lt;b.l; } void dist() { double disx=x[u]-x[v],disy=y[u]-y[v]; l=sqrt(disx*disx+disy*disy); }}a[M];struct disjointSet//并查集 { int father[N],size[N]; void pre() { for(int i=1;i&lt;=n;i++) { father[i]=i; size[i]=1; } } int find(int x) { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return true; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y; return false; }}s;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(),m=read(); s.pre(); for(int i=1;i&lt;=n;i++) { x[i]=read(),y[i]=read(); } for(int i=1;i&lt;=m;i++) { int u=read(),v=read(); s.merge(u,v); } m=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { a[++m].u=i,a[m].v=j; a[m].dist(); } } sort(a+1,a+m+1); for(int i=1;i&lt;=m;i++) { if(s.merge(a[i].u,a[i].v)) { continue; } else { ans+=a[i].l; } } printf(&quot;%.2f&quot;,ans); return 0;} P1991 无线通讯网 Des 国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络； 每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。 任意两个配备了一条卫星电话线路的哨所（两边都有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。 收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。 Sol 路径上最大边最小 Orz题解大佬. 选择\\(S\\)个用卫星电话的哨所太麻烦,考虑更改做法. 那么选择\\(P-S\\)个用收发器的哨所.剩下的用卫星电话.可以保证这样做继承了问题的完整性. 具体做法: 为题目中所有哨所构成的点集建立完全图.用Kruskal跑最小生成树,直到选择了\\(P-S\\)个点为止. 证明: 设将另一个点\\(U\\)替换最小生成树中的点\\(P\\)可以得到最优解.那么\\(g(U,father[P])&lt;g(P,father[P])\\).与按边长从小到大选边违背.所以现在生成的最小生成树已经是最优解. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define ll long long#define min(a,b) ((a)&lt;(b)?(a):(b))#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=505,M=250005;int s,p,m;double ans;int x[N],y[N];struct Edge{ int u,v; double l; void dist() { double disx=x[u]-x[v],disy=y[u]-y[v]; l=sqrt(disx*disx+disy*disy); } bool operator &lt; (const Edge &amp;b) const { return l&lt;b.l; }}g[M];struct disJointSet{ int father[N],size[N]; void pre() { for(int i=1;i&lt;=p;i++) { father[i]=i; size[i]=1; } } int find(int x) { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return false; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y; return true; }}Set;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ s=read(),p=read(); for(int i=1;i&lt;=p;i++) { x[i]=read(),y[i]=read(); } Set.pre(); for(int i=1;i&lt;=p;i++) { for(int j=1;j&lt;=p;j++) { g[++m].u=i,g[m].v=j; g[m].dist(); } } sort(g+1,g+m+1); int tot=0; for(int i=1;i&lt;=m;i++) { if(Set.merge(g[i].u,g[i].v)) { ans=g[i].l; if(++tot==p-s) { printf(&quot;%.2f\\n&quot;,ans); return 0; } } } return 0;} P4047 [JSOI2010]部落划分 Des 聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 n个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 k 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 (图在洛谷) Sol 路径上最大边最小 先了解一个知识:如果将一棵树的任意一条边砍掉,那么这棵树就会变成2颗树(相当于2个连通块). 也就是说想要划分出\\(k\\)个部落,只需要将连接整个图的一颗生成树砍掉\\(k-1\\)条边. 这棵树本有\\(n-1\\)条边,砍掉后剩下\\(n-k\\)条边.目的是让这\\(n-k\\)条边中最大的一条最小.使用Kruskal算法求出最小生成树中第\\(n-k+1\\)大的边,边权就是答案. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define ll long long#define min(a,b) ((a)&lt;(b)?(a):(b))#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=1005,M=1e6+5;int n,k,m;int x[N],y[N];struct Edge{ int u,v; double l; void dist() { double disx=x[u]-x[v],disy=y[u]-y[v]; l=sqrt(disx*disx+disy*disy); } bool operator &lt; (const Edge &amp;b) const { return l&lt;b.l; }}g[M];struct disJointSet{ int father[N],size[N]; void pre() { for(int i=1;i&lt;=n;i++) { father[i]=i; size[i]=1; } } int find(int x) { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return false; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y; return true; }}Set;int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x[i]&gt;&gt;y[i]; } Set.pre(); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { g[++m].u=i,g[m].v=j; g[m].dist(); } } sort(g+1,g+m+1); int tot=0; for(int i=1;i&lt;=m;i++) { if(Set.merge(g[i].u,g[i].v)) { ++tot; if(tot==n-k+1) { printf(&quot;%.2f\\n&quot;,g[i].l); return 0; } } } return 0;} Note 图片有彩蛋! P1967 [NOIP2013 提高组] 货车运输 Des 题目描述 A 国有 \\(n\\) 座城市，编号从 $1 $ 到 $ n$，城市之间有 \\(m\\) 条双向道路。每一条道路对车辆都有重量限制，简称限重。 现在有 \\(q\\) 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入格式 第一行有两个用一个空格隔开的整数 $ n,m$，表示 \\(A\\) 国有 $ n$ 座城市和 \\(m\\) 条道路. 接下来 \\(m\\) 行每行三个整数 \\(x, y, z\\)，每两个整数之间用一个空格隔开，表示从 $x $ 号城市到 $ y $ 号城市有一条限重为 \\(z\\) 的道路。 注意： \\(x \\neq y\\)，两座城市之间可能有多条道路 。 接下来一行有一个整数 \\(q\\)，表示有 \\(q\\) 辆货车需要运货。 接下来 \\(q\\) 行，每行两个整数 \\(x,y\\)，之间用一个空格隔开，表示一辆货车需要从 \\(x\\) 城市运输货物到 \\(y\\) 城市，保证 \\(x \\neq y\\) Sol 路径上最小边最大 LCA-getPlus+生成树-pathMinMax 可以证明,每个答案一定是最小生成树上某个边权值(我就不证了). 由于\\(min\\)运算满足结合律,可以用LCA求出x城市到LCA(x,y)的min值,以及y城市到LCA(x,y)的min值,再合并. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/*- 两座城市之间可能有多条道路- x不等于y*/#include &lt;bits/stdc++.h&gt;#define ll long long#define INF 1e9;#define min(a,b) ((a)&lt;(b)?(a):(b))#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=1e4+5,M=5e4+5,Q=3e4+5;int n,m,q;struct Edge//Edge for LCA{ int v,l;};vector&lt;Edge&gt; g[N];struct Edge2//Edge for Kruskal{ int u,v,l; bool operator &lt; (const Edge2 &amp;b) const { return l&gt;b.l; }}edges[M];struct disJointSet{ int father[N],size[N]; void pre() { for(int i=1;i&lt;=n;i++) { father[i]=i; size[i]=1; } } int find(int x) { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } bool merge(int x,int y) { x=find(x),y=find(y); if(x==y) return false; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y; return true; } bool query(int x,int y) { x=find(x),y=find(y); if(x==y) return true; else return false; }}Set;struct lowestCommonAncestor{ int depth[N],lg[N&lt;&lt;1],f[N][20],minW[N][20]; bool vis[N]; void lg2() { for(int i=1;i&lt;=14;i++) lg[1&lt;&lt;i]++; for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1]; } void pre(int x,int father) { vis[x]=true; depth[x]=depth[father]+1,f[x][0]=father; int len=g[x].size(),minWNow=INF; for(int i=0;i&lt;len;i++) { if(g[x][i].v==father &amp;&amp; g[x][i].l&lt;minWNow) { minWNow=g[x][i].l; } } minW[x][0]=minWNow; for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1]; minW[x][i]=min(minW[x][i-1],minW[f[x][i-1]][i-1]); } for(int i=0;i&lt;len;i++) { if(g[x][i].v!=father) pre(g[x][i].v,x); } } int getMinW(int x,int y) { int minWNow=INF; if(depth[x]&gt;depth[y]) swap(x,y); for(int i=lg[depth[y]-depth[x]];i&gt;=0;i--) { if(depth[f[y][i]]&gt;=depth[x]) minWNow=min(minWNow,minW[y][i]),y=f[y][i]; } if(x==y) return minWNow; for(int i=lg[depth[x]];i&gt;=0;i--) { if(f[x][i]!=f[y][i]) { minWNow=min(minWNow,min(minW[x][i],minW[y][i])); x=f[x][i],y=f[y][i]; } } minWNow=min(minWNow,min(minW[x][0],minW[y][0])); return minWNow; }}lca;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(),m=read(); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(),z=read(); edges[i].u=u,edges[i].v=v,edges[i].l=z; } sort(edges+1,edges+m+1); Set.pre(); int tot=0; for(int i=1;i&lt;=m;i++) { int u=edges[i].u,v=edges[i].v,l=edges[i].l; if(Set.merge(u,v)) { g[u].push_back((Edge){v,l}); g[v].push_back((Edge){u,l}); tot++; if(tot==n-1) break; } } lca.lg2(); for(int i=1;i&lt;=n;i++) { if(lca.vis[i]==false) lca.pre(i,0); } q=read(); for(int i=1;i&lt;=q;i++) { int x=read(),y=read(); if(Set.query(x,y)==false) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,lca.getMinW(x,y)); } return 0;} 总结 最小生成树的题目都会满足\"连通\"这个约束条件,并有许多经典应用.","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"title":"【专题】线段树-入门","text":"概览 线段树是什么就不说了,主要记录几种题型(下面的题在学习了普通线段树后就可以做): 多个lazy_tag,并限制lazy_tag修改顺序(pushDownPlus) 【模板】线段树 2 两个lazy_tag修改顺序其实是可先可后的,但我们并不知道哪个先,哪个后.所以固定一种顺序,并推导出tag的转换公式. 复杂的push_up操作(pushUpPlus) SP1043 GSS1 - Can you answer these queries I 如果只是push_up变复杂了都还好说,但query的本质和push_up是差不多的,所以query也要修改.像这道题的节点只能用结构体存,并且要对各个元素的初值进行精确的控制. 这类问题需要抓住当前区间的答案与子区间的联系 #2126 哨戒炮 两个区间能否合并,取决于它们的左端点和右端点是否选择. P4145 上帝造题的七分钟2 / 花神游历各国 加入一个判断区间性质的tag,在pushUp时更新. 在答案统计上下功夫的思维题(queryPlus) P2184 贪婪大陆 区间修改,区间询问?这不就是线段树嘛???可惜我们还需要一点思考. P4588 [TJOI2018]数学计算 这不O(n)就能过吗?等等,蓝题? 例题 P3372 【模板】线段树 1 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1e5+5,M=1e5+5;int n,m,op,a[N],x,y,k;ll ans[4*N],tag[4*N];inline ll read(){ ll s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } inline int ls(int p){ return p&lt;&lt;1;}inline int rs(int p){ return p&lt;&lt;1|1;}inline ll pup(int p){ return ans[ls(p)]+ans[rs(p)];}void build(int l,int r,int p){ if(l==r) { ans[p]=a[l]; // cout&lt;&lt;p&lt;&lt;' '&lt;&lt;ans[p]&lt;&lt;endl; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,ls(p)); build(mid+1,r,rs(p)); ans[p]=pup(p); // cout&lt;&lt;p&lt;&lt;' '&lt;&lt;ans[p]&lt;&lt;endl;}void pdown(int l,int r,int p)//update ans[ls.p],ans[rs.p],tag[ls.p],tag[rs.p]{ ll mid=(l+r)&gt;&gt;1; tag[ls(p)]+=tag[p],ans[ls(p)]+=(mid-l+1)*tag[p]; tag[rs(p)]+=tag[p],ans[rs(p)]+=(r-mid)*tag[p]; tag[p]=0;}void update(int l,int r,ll k,int p){ if(x&lt;=l&amp;&amp;r&lt;=y) { tag[p]+=k; ans[p]+=k*(r-l+1); return; } pdown(l,r,p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,k,ls(p)); if(y&gt;mid) update(mid+1,r,k,rs(p)); ans[p]=pup(p);}ll query(int l,int r,int p){ if(x&lt;=l&amp;&amp;r&lt;=y) { // cout&lt;&lt;p&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;ans[p]&lt;&lt;endl; return ans[p]; } pdown(l,r,p); int mid=(l+r)&gt;&gt;1; ll res=0; if(x&lt;=mid) res+=query(l,mid,ls(p)); if(y&gt;mid) res+=query(mid+1,r,rs(p)); return res;}int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } build(1,n,1); // for(int i=1;i&lt;=n*2;i++) // { // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ans[i]&lt;&lt;endl; // } for(int i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==1) { k=read(); update(1,n,k,1); } else { printf(&quot;%lld\\n&quot;,query(1,n,1)); } } return 0;} Note 这时的代码并不趋近于完善. P3373 【模板】线段树 2 Des 如题，已知一个数列，你需要进行下面三种操作： 将某区间每一个数乘上 \\(x\\) 将某区间每一个数加上 \\(x\\) 求出某区间每一个数的和 Sol 假设有一个加法tag \\(a\\)先被标记,后有一个乘法tag \\(b\\)被标记,原数为\\(x\\).正常来说\\(x=(x+a)\\times b=xa+xb\\),但我们并不知道加法和乘法谁先进来!所以我们对原数的操作永远先乘后加,正确性通过更改tag的值来实现. 好的,现在的操作已经变成了先乘后加:\\(x=xb+a\\).和本来的先加后乘的的区别就在于tag a!只需要将tag a改成\\(xa\\)即可.这一步可在tag b被标记时将tag a乘上tag b实现.只要用这一规则,无论将tag更改多少次,最后的答案也是正确的. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#define ull unsigned long longusing namespace std;const int N=1e5+5,M=1e5+5;int n,m,mod,a[4*N],ls[4*N],rs[4*N];ull ans[4*N],taga[4*N],tagm[4*N],k;int op,x,y;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } namespace segtree{ void pup(int p) { ans[p]=ans[ls[p]]+ans[rs[p]]; ans[p]%=mod; } void pd(int l,int r,int p) { int mid=(l+r)&gt;&gt;1; taga[ls[p]]*=tagm[p],tagm[ls[p]]*=tagm[p],taga[ls[p]]+=taga[p]; ans[ls[p]]*=tagm[p],ans[ls[p]]+=taga[p]*(mid-l+1); taga[rs[p]]*=tagm[p],tagm[rs[p]]*=tagm[p],taga[rs[p]]+=taga[p]; ans[rs[p]]*=tagm[p],ans[rs[p]]+=taga[p]*(r-mid); taga[ls[p]]%=mod,tagm[ls[p]]%=mod,taga[rs[p]]%=mod,tagm[rs[p]]%=mod; ans[ls[p]]%=mod,ans[rs[p]]%=mod; tagm[p]=1,taga[p]=0; } void build(int l,int r,int p) { if(l==r) { ans[p]=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,ls[p]); build(mid+1,r,rs[p]); pup(p); } void upm(int l,int r,int p,int k) { if(l&gt;=x&amp;&amp;r&lt;=y) { taga[p]*=k; tagm[p]*=k; ans[p]*=k; taga[p]%=mod,tagm[p]%=mod,ans[p]%=mod; return; } pd(l,r,p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) upm(l,mid,ls[p],k); if(y&gt;mid) upm(mid+1,r,rs[p],k); pup(p); } void upa(int l,int r,int p,int k) { if(l&gt;=x&amp;&amp;r&lt;=y) { taga[p]+=k; ans[p]+=k*(r-l+1); taga[p]%=mod,ans[p]%=mod; return; } pd(l,r,p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) upa(l,mid,ls[p],k); if(y&gt;mid) upa(mid+1,r,rs[p],k); pup(p); } ull query(int l,int r,int p) { if(l&gt;=x&amp;&amp;r&lt;=y) return ans[p]; ull res=0; pd(l,r,p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) res+=query(l,mid,ls[p]); if(y&gt;mid) res+=query(mid+1,r,rs[p]); res%=mod; return res; }}using namespace segtree;int main(){ n=read(),m=read(),mod=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=4*n;i++) { ls[i]=i&lt;&lt;1; rs[i]=i&lt;&lt;1|1; tagm[i]=1; } build(1,n,1); for(int i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op!=3) k=read(); switch(op) { case 1: upm(1,n,1,k); break; case 2: upa(1,n,1,k); break; case 3: printf(&quot;%lld\\n&quot;,query(1,n,1)%mod); } } return 0;} P2184 贪婪大陆 Des 小FF最后一道防线是一条长度为N的战壕， 小FF拥有无数多种地雷，而SCV每次可以在[ L , R ]区间埋放同一种不同于之前已经埋放的地雷。 由于情况已经十万火急，小FF在某些时候可能会询问你在[ L' , R'] 区间内有多少种不同的地雷， 他希望你能尽快的给予答复。 对于30%的数据： 0&lt;=n, m&lt;=1000; 对于100%的数据： 0&lt;=n, m&lt;=10^5. Sol 在[l,r]区间放下了地雷,不就等于在\\(\\complement_{[1,n]}[l,r]\\)没有放地雷吗?那么我给\\(\\complement_{[1,n]}[l,r]\\)打上标记不就好了? My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,M=1e5+5,N4=4e5+5;int n,m,ls[N4],rs[N4],cnt,ans[N4][2],tag[N4][2];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } namespace segtree{ int x,y; void pup(int p) { for(int mode=1;mode&lt;=2;mode++) ans[p][mode]=ans[ls[p]][mode]+ans[rs[p]][mode]; } void pd(int l,int r,int p) { int mid=(l+r)&gt;&gt;1; for(int mode=1;mode&lt;=2;mode++) { tag[ls[p]][mode]+=tag[p][mode],tag[rs[p]][mode]+=tag[p][mode]; ans[ls[p]][mode]+=tag[p][mode]*(mid-l+1); ans[rs[p]][mode]+=tag[p][mode]*(r-mid); tag[p][mode]=0; } } void update(int l,int r,int p,int mode,int k) { if(l&gt;=x&amp;&amp;r&lt;=y) { tag[p][mode]+=k; ans[p][mode]+=k*(r-l+1); return; } pd(l,r,p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p],mode,k); if(y&gt;mid) update(mid+1,r,rs[p],mode,k); pup(p); } int query(int l,int r,int p,int mode) { if(l&gt;=x&amp;&amp;r&lt;=y) return ans[p][mode]; pd(l,r,p); int res=0; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) res+=query(l,mid,ls[p],mode); if(y&gt;mid) res+=query(mid+1,r,rs[p],mode); return res; }}using namespace segtree;int main(){ n=read(),m=read(); for(int i=1;i&lt;=4*n;i++) { ls[i]=i&lt;&lt;1; rs[i]=i&lt;&lt;1|1; } int op,x,y; for(int i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==1) { segtree::x=1,segtree::y=x-1; if(1&lt;=x-1) update(1,n,1,2,1);//[1,x-1]的右边增加一条 segtree::x=y+1,segtree::y=n; if(y+1&lt;=n) update(1,n,1,1,1);//[y+1,n]的左边增加一条 cnt++; } else { int ans=cnt; segtree::x=x,segtree::y=x; ans-=query(1,n,1,1); segtree::x=y,segtree::y=y; ans-=query(1,n,1,2); printf(&quot;%d\\n&quot;,ans); } } return 0;} SP1043 GSS1 - Can you answer these queries I Des 给出了序列 \\(A[1],A[2],…,A[N]\\) 。 ($ a[i]≤15007,1≤N≤50000$ )。查询定义如下： 查询 \\((x,y)=\\max\\{a[i]+a[i+1]+...+a[j];x≤i≤j≤y\\}\\)。 给定\\(M\\)个查询，程序必须输出这些查询的结果。 Sol 这道题本身的ans并不满足结合律,更精确的说,ans只能代表区间的一个信息.我们可以扩展区间的信息,使其支持结合律(其实就是说节点的答案能从子节点更新到)! 具体看代码 My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//线段树，复杂的push_up #include &lt;bits/stdc++.h&gt;#define INF (1e9+7)#define min(a,b) ((a)&lt;(b)?(a):(b))#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=4e5+5,M=1e5+5;int n,m,a[N],sum[N],suml[N],sumr[N],ans[N],ls[N],rs[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct node{ int s,sl,sr,a;};namespace sg{ int x,y; void pup(int p) { sum[p]=sum[ls[p]]+sum[rs[p]]; suml[p]=max(suml[ls[p]],sum[ls[p]]+suml[rs[p]]); sumr[p]=max(sumr[rs[p]],sum[rs[p]]+sumr[ls[p]]); ans[p]=max(ans[ls[p]],ans[rs[p]]); ans[p]=max(ans[p],suml[rs[p]]+sumr[ls[p]]); } void build(int l,int r,int p) { if(l==r) { ans[p]=sum[p]=suml[p]=sumr[p]=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,ls[p]); build(mid+1,r,rs[p]); pup(p); } void update(int l,int r,int p,int k) { if(l==r) { ans[p]=sum[p]=suml[p]=sumr[p]=k; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p],k); if(y&gt;mid) update(mid+1,r,rs[p],k); pup(p); } node query(int ll,int rr,int p) { int mid=(ll+rr)&gt;&gt;1; if(ll&gt;=x&amp;&amp;rr&lt;=y) { return (node){sum[p],suml[p],sumr[p],ans[p]}; } node res,l,r; l.sl=l.sr=l.a=r.sl=r.sr=r.a=-INF; l.s=r.s=0; if(x&lt;=mid) l=query(ll,mid,ls[p]); if(y&gt;mid) r=query(mid+1,rr,rs[p]); res.s=l.s+r.s; res.sl=max(l.sl,l.s+r.sl),res.sr=max(r.sr,r.s+l.sr); res.a=max(l.a,r.a); res.a=max(res.a,l.sr+r.sl); return res; }}using namespace sg;int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=4*n;i++) ls[i]=i&lt;&lt;1,rs[i]=i&lt;&lt;1|1,ans[i]=sum[i]=-INF; build(1,n,1); int op,x,y; for(int i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==0) { sg::x=x,sg::y=y; printf(&quot;%d\\n&quot;,query(1,n,1).a); } else { sg::x=x,sg::y=x; update(1,n,1,y); } } return 0;} Note 一开始就应该用node的 P4588 [TJOI2018]数学计算 Sol 乘上一个数,就在线段树对应pos处更新,并输出query(1,i).除一个数,输出query(1,x-1)*query(x+1,n),将x处的数置为1. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define INF 1e9#define ll long long#define min(a,b) ((a)&lt;(b)?(a):(b))#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=4e5+5; ll mod,k,a[N],ans[N],ls[N],rs[N];int q,op;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } namespace sg{ int x,y; void pup(int p) { ans[p]=(ans[ls[p]]*ans[rs[p]])%mod; } void update(int l,int r,int p,int k) { if(l==r) { ans[p]=k; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p],k); if(y&gt;mid) update(mid+1,r,rs[p],k); pup(p); } ll query(int l,int r,int p) { if(l&gt;=x&amp;&amp;r&lt;=y) return ans[p]; int mid=(l+r)&gt;&gt;1; ll res=1; if(x&lt;=mid) res=(res*query(l,mid,ls[p]))%mod; if(y&gt;mid) res=(res*query(mid+1,r,rs[p]))%mod; return res; }}using namespace sg;int main(){ int T=read(); while(T--) { q=read(),mod=read(); for(int i=1;i&lt;=4*q;i++) ls[i]=i&lt;&lt;1,rs[i]=i&lt;&lt;1|1; for(int j=1;j&lt;=4*q;j++) ans[j]=1; for(int i=1;i&lt;=q;i++) { op=read(),k=read(); if(op==1) { k%=mod; sg::x=i,sg::y=i; update(1,q,1,k); sg::x=1,sg::y=i; printf(&quot;%lld\\n&quot;,query(1,q,1)%mod); } else { ll t=1; sg::x=1,sg::y=k-1; if(1&lt;=k-1) t=(t*query(1,q,1))%mod; sg::x=k+1,sg::y=i; if(k+1&lt;=q) t=(t*query(1,q,1))%mod; printf(&quot;%lld\\n&quot;,t); sg::x=k,sg::y=k; update(1,q,1,1); } } } return 0;} Note 学信奥,请认准g++ 7.3.0. #2126 哨戒炮 Des 防线上有 N 个紧挨着排成一行的炮台，每一个炮台至多能够放置一个哨戒炮。在不同地炮 台放置哨戒炮能获得不同的防御力（防御力可以为负，表示有负的防御作用） 。特别地，初 始时第 i 个炮台放置哨戒炮能获得的防御力为pi。 由于哨戒炮工作时需要周围有足够的空间，相邻的两个炮台不能同时放置哨戒炮。有时，由于地形条件的变化炮台放置哨戒炮获得 的防御力会发生改变。现在，你需要写个程序来回答这样的询问：仅使用[l,r]区间内的炮 台放置哨戒炮能够获得的最大防御力总和是多少（可以一个都不放置，这时防御力总和为0） 。 Sol ans[i][0]表示选择了区间左、右端点的最大值 ans[i][1]表示选择了区间左端点,未选择区间右端点的最大值 ans[i][2]表示未选择区间左端点,选择了区间右端点的最大值 ans[i][3]表示未选择区间左右端点的最大值 设l和r为x的左儿子,右儿子. \\(ans[x][0]=max(ans[l][0]+ans[r][2],ans[r][0]+ans[l][1],ans[l][1]+ans[r][2])\\) \\(ans[x][1]=max(ans[l][0]+ans[r][3],ans[l][1]+ans[r][1],ans[l][1]+ans[r][3])\\) \\(ans[x][2]=max(ans[l][2]+ans[r][2],ans[l][3]+ans[r][0],ans[l][3]+ans[r][2])\\) \\(ans[x][3]=max(ans[l][3]+ans[r][3],ans[l][2]+ans[r][3],ans[l][3]+ans[r][1])\\) 初始化 ans[p][0]=a[l],其余为0. 名副其实的pushUpPlus!只要能写出来方程,都不是问题. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;const int N=1e6+5;int m,n,a[N],ls[N],rs[N],ans[N][5],tmp[N][5],pt;int op,x,y;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void pup(int p){ int l=ls[p],r=rs[p]; ans[p][0]=max(ans[l][0]+ans[r][2],max(ans[r][0]+ans[l][1],ans[l][1]+ans[r][2])); ans[p][1]=max(ans[l][0]+ans[r][3],max(ans[l][1]+ans[r][1],ans[l][1]+ans[r][3])); ans[p][2]=max(ans[l][2]+ans[r][2],max(ans[l][3]+ans[r][0],ans[l][3]+ans[r][2])); ans[p][3]=max(ans[l][3]+ans[r][3],max(ans[l][2]+ans[r][3],ans[l][3]+ans[r][1]));}void build(int l,int r,int p){ if(l==r) { ans[p][0]=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,ls[p]); build(mid+1,r,rs[p]); pup(p);}int query(int l,int r,int p){ if(l&gt;=x&amp;&amp;r&lt;=y) { pt++; for(int i=0;i&lt;=3;i++) tmp[pt][i]=ans[p][i]; return pt; } int mid=(l+r)&gt;&gt;1,al=-1,ar=-1; if(x&lt;=mid) al=query(l,mid,ls[p]); else { pt++; for(int i=0;i&lt;=3;i++) tmp[pt][i]=0; al=pt; } if(y&gt;mid) ar=query(mid+1,r,rs[p]); else { pt++; for(int i=0;i&lt;=3;i++) tmp[pt][i]=0; ar=pt; } pt++; tmp[pt][0]=max(tmp[al][0]+tmp[ar][2],max(tmp[ar][0]+tmp[al][1],tmp[al][1]+tmp[ar][2])); tmp[pt][1]=max(tmp[al][0]+tmp[ar][3],max(tmp[al][1]+tmp[ar][1],tmp[al][1]+tmp[ar][3])); tmp[pt][2]=max(tmp[al][2]+tmp[ar][2],max(tmp[al][3]+tmp[ar][0],tmp[al][3]+tmp[ar][2])); tmp[pt][3]=max(tmp[al][3]+tmp[ar][3],max(tmp[al][2]+tmp[ar][3],tmp[al][3]+tmp[ar][1])); return pt;}void update(int l,int r,int p,int k){ if(l&gt;=x&amp;&amp;r&lt;=y) { ans[p][0]=k; for(int i=1;i&lt;=3;i++) ans[p][i]=0; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,ls[p],k); if(y&gt;mid) update(mid+1,r,rs[p],k); pup(p);}int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } for(int i=1;i&lt;=4*n;i++) { ls[i]=i&lt;&lt;1,rs[i]=i&lt;&lt;1|1; } build(1,n,1); for(int i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==1) { pt=0; int t=query(1,n,1),out=0; for(int i=0;i&lt;=3;i++) { out=max(out,tmp[t][i]); } printf(&quot;%d\\n&quot;,out); } else { int t=y; y=x; update(1,n,1,t); } } return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"title":"【笔记】数论学习笔记","text":"前言 本文抄自基于《数论讲义》(柯召 孙琦 编著）。 第一章 整数的唯一分解定理 整数的唯一分解定理，又叫算数基本定理． §1 整除性 定义 任给两个整数 a,b，其中 \\(b\\neq0\\)，如果存在一个整数 q 使得等式 \\[ a=bq\\tag1 \\] 成立，我们就说 b 整除 a，记作 b|a，此时 b 叫做 a 的因数，a 是 b 的倍数．如果整数 q 不存在，则 b 不整除 a，记作 \\(b\\nmid a\\)．比如 \\(3|6\\)，\\(3\\nmid7\\)． 这里要注意,因为 \\(b\\neq0\\), 所以 \\(a\\neq0\\),即0没有因数. 可以得到下面的 一些性质： 设a，b，c是整数． 如果 \\(a\\mid b\\)，\\(n\\) 是整数，那么 \\(na\\mid nb\\)． 如果 \\(a\\mid b,a\\mid c\\)，\\(n,m\\)是整数，那么 \\(a\\mid bn+cm\\) . 如果 \\(a\\mid b\\), 那么 \\({b\\over a}\\mid b\\). 如果 \\(b\\mid a\\),且 \\(a\\neq0\\),那么 \\(|a|\\le|b|\\). 定理 1 设 a,b 是两个整数,其中 \\(b&gt;0\\) ,则存在两个唯一的整数 q 和 r. 使得 \\[ a=qb+r(0\\le r&lt;b)\\tag2 \\] 定义 把(2)中的 q 称作 a 除以 b 的不完全商, r 称作 a 除以 b 的非负最小剩余,用 \\(\\langle a\\rangle_b\\) 表示,不引起歧义的情况下可以省去 b. 也就是说 \\(a=qb+\\langle a\\rangle\\). 定理 2 对于整数 \\(a_1,a_2,b\\) ,其中 \\(b&gt;0\\).有 \\[ \\langle a_1+a_2\\rangle=\\langle\\langle a_1\\rangle+\\langle a_2\\rangle\\rangle \\tag3 \\] \\[ \\langle a_1-a_2\\rangle=\\langle\\langle a_1\\rangle-\\langle a_2\\rangle\\rangle \\tag4 \\] \\[ \\langle a_1a_2\\rangle=\\langle\\langle a_1\\rangle\\langle a_2\\rangle\\rangle \\tag5 \\] 其实这个定理在各种取模的地方都在用,但从来都没证过. 的证明和 (3) 没有太大差别, (3) 的证明书上有.这里证一下 (5). 证明 要证明 \\(\\langle n\\rangle=\\langle m\\rangle\\), 其实就等于找出一个整数 q 使得 \\(n=bq+\\langle m\\rangle\\). 那么对于式(5),要证的就是 \\(a_1a_2=bq+\\langle\\langle a_1\\rangle\\langle a_2\\rangle\\rangle\\). 设 \\(a_1=bq_1+\\langle a_1\\rangle\\),\\(a_2=bq_1+\\langle a_2\\rangle\\), 那么 \\[ \\begin{align} a_1a_2 &amp;=b(q_1+q_2+q_1\\langle a_2\\rangle+q_2\\langle a_1\\rangle)+\\langle a1\\rangle\\langle a2\\rangle\\\\ &amp;=b(q_1+q_2+q_3+q_1\\langle a_2\\rangle+q_2\\langle a_1\\rangle)+\\langle\\langle a1\\rangle\\langle a2\\rangle\\rangle \\end{align} \\] 证毕 小结 定理 1 设 a,b 是两个整数,其中 \\(b&gt;0\\) ,则存在两个唯一的整数 q 和 r. 使得 \\[ a=qb+r(0\\le r&lt;b)\\tag2 \\] 定理 2 对于整数 \\(a_1,a_2,b\\) ,其中 \\(b&gt;0\\).有 \\[ \\langle a_1+a_2\\rangle=\\langle\\langle a_1\\rangle+\\langle a_2\\rangle\\rangle \\tag3 \\] \\[ \\langle a_1-a_2\\rangle=\\langle\\langle a_1\\rangle-\\langle a_2\\rangle\\rangle \\tag4 \\] \\[ \\langle a_1a_2\\rangle=\\langle\\langle a_1\\rangle\\langle a_2\\rangle\\rangle \\tag5 \\] 我愿称定理 1 为带余除法定律,定理 2 实质上则是模意义下加法与乘法的结合律. §2 最大公因数与辗转相除法 定义 设 \\(a_1,a_2,\\dots,a_n\\)是 \\(n\\) 个不全为零的整数,若整数 \\(d\\) 是它们每一个的因数,那么 d 就是 \\(a_1,a_2,\\dots,a_n\\) 的一个公因数. \\(a_1,a_2,\\dots,a_n\\) 的公因数中最大的一个就是它们的最大公因数,记作 \\((a_1,\\dots,a_n)\\),若 \\((a_1,\\dots,a_n)=1\\) ,就说 \\(a_1,\\dots,a_n\\) 互素. 可以得到一点有用的结论: 由整除的性质得到 \\((a_1,a_2,\\dots\\,a_n)\\le {\\rm min}(a_1,a_2,\\dots,a_n)\\). \\((a_1,\\dots,a_n)\\mid a_1,(a_1,\\dots,a_n)\\mid a_2,\\dots,(a_1,\\dots,a_n)\\mid a_n\\). 定理 1 设 a,b,c 是3个不全为零的整数,且 \\(a=bq+c\\) ,其中 \\(q\\) 是整数,那么有 \\((a,b)=(b,c)\\). 证明 因为 \\((a,b)\\mid a,(a,b)\\mid b,c=a-bq\\), 所以 \\((a,b)\\mid c\\). 由于 2 个数的公因数肯定小于等于最大公因数,所以得到 \\((a,b)\\le(b,c)\\). 同理,因为 \\((b,c)\\le b,(b,c)\\le c,a=bq+c\\), 所以 \\((b,c)\\mid a\\), 可得 \\((b,c)\\le(a,b)\\), 于是得到 \\((a,b)=(b,c)\\). 证毕 点评: 本证明方法利用了证明 \\(a=b\\) 的常用方法,即证明 \\(a\\le b,b \\le a\\). 并且抓住了式子 \\(a=bq+c\\) 可以得到 \\(c=bq-a\\) 的本质. 因为有 \\((a_1,a_2,\\dots,a_n)=(|a_1|,|a_2|,\\dots,|a_n|)\\), 所以不妨设 \\(a_i&gt;0\\). 然后就可以讨论求两个正整数的最大公因数的方法,进而推出最大公因数的性质. 任给整数 \\(a&gt;0,b&gt;0\\),有 \\[ a=bq_1+r_1(0&lt;r_1&lt;b),\\\\ b=r_1q_2+r_2(0&lt;r_2&lt;r_1),\\\\ \\cdots\\cdots\\\\ r_{n-2}=r_{n-1}q_{n}+r_{n}(0&lt;r_{n}&lt;r_n), \\] \\[ r_{n-1}=r_{n}q_{n+1}+r_{n+1},r_{n+1}=0.\\tag1 \\] 因为 \\(b&gt;r_1&gt;r_2&gt;\\cdots\\), 所以经过有限次带余除法后,总可以得到 \\(r_{n+2}=0\\). 利用这个性质,我们可以写出求最大公约数的算法. 设有两个整数 \\(a,b\\),且\\(a&gt;b\\),那么 \\[ {\\rm gcd}(a,b)= \\begin{cases} \\gcd(b,a \\bmod b) &amp; \\text{if b $\\neq$ 0}\\\\ a &amp; \\text{if b = 0} \\end{cases} \\] 定理 2 任给整数 \\(a&gt;0,b&gt;0\\) ,\\((a,b)\\) 就等于 (1) 中最后一个不等于零的余数,即 \\(r_n\\). 证明 由定理1得 \\((a,b)=(b,r_1)=(r_1,r_2)=\\dots=(r_{n-1},r_n)=r_n\\). 证毕 由 (1) 得 \\[ r_n=r_{n-2}-r_{n-1}q_n\\tag*① \\] \\[ r_{n-1}=r_{n-3}-r_{n-2}q_{n-1}\\tag*② \\] 将 ② 代入 ① 得 \\[ r_n=r_{n-2}(1+q_nq_{n-1})-r_{n-3}q_n \\] 同理,将 \\(r_{n-2},r_{n-3},\\dots,r_1,b,a\\) 代入上式,可 得到 \\(r_n=sa+tb\\), 其中 \\(s,t\\) 都是整数. 于是有 定理 3 若任给整数 \\(a&gt;0,b&gt;0\\) ,则有两个整数 \\(m,n\\) 使得 \\[ (a,b)=ma+nb. \\] 假设 \\(c\\) 是 a,b 的公因数,有 \\(c\\mid ma+nb\\),于是有 推论 a和b 的公因数是 (a,b) 的因数,即 \\(c\\mid (a,b)\\). 对于 §1 (2) 中的余数,如果不要求它是正的,那么对于数 a 和 b&gt;0, 则存在整数 s,t, 使得 a=bt+s 成立,其中 \\(|s|&lt;=\\cfrac b 2\\).因为当 \\(r&lt;\\cfrac b 2\\)时,取 \\(s=r\\); 当 \\(r\\ge \\cfrac b2\\)时,取 \\(s=r-b\\). 数 \\(s\\) 称作 a 除以 b 所得到的绝对最小剩余.在(1)的计算过程中,设最后一个不小于0的余数为 \\(|s_m|\\)由定理1,仍有 \\(|s_m|=(a,b)\\). 定理3就是扩展欧几里得算法的理论依据,使用绝对最小剩余可以减少辗转相除法求解最大公因数的步骤.下面展示扩展欧几里得算法求解定理3中 m 和 n 的过程. 首先,进行正常的辗转相除法(递归实现) \\[ \\begin{align} &amp; 288=158\\cdot 2-28,\\\\ &amp; 158=28\\cdot 6-10,\\\\ &amp; 28=10\\cdot 3-2,\\\\ &amp; 10=2\\cdot 5+0. \\end{align} \\] 然后运用定理3迭代回去求解最初的 m 和 n \\[ \\begin{align} 2&amp;=10*0+2*1\\\\ &amp;=10*0+(10*3-28)*1\\\\ &amp;=10*3-28\\\\ &amp;=(28*6-158)*3-28\\\\ &amp;=17*28-3*158\\\\ &amp;=(158*2-288)*17-3*158\\\\ &amp;=31*158-17*288 \\end{align} \\] 所以 \\(m=-17,n=31\\). 由于在程序设计中计算绝对最小剩余较为复杂,且效率较低,所以用非负最小剩余(取模得到的结果)即可. 但是,这样的计算过程显然不是形式化的计算机语言,我们来看看如何写出代码.在递归求解的每一步中, a 和 b 的值分别是: 12345678288 158158 130130 2828 18 18 1010 88 2 2 0 设递归下一层得到的 \\(m=x,n=y,a'=b,b'=c\\). 那么 \\[ am+bn=bx+cy, \\] 由于 \\(c=a+bk\\), 有, \\[ am+bn=ay+b(x-ky) \\] 这里的 \\(k\\) 实际上就是 \\(\\left\\lfloor \\cfrac ab\\right\\rfloor\\). 于是就可以写出代码了,congratulation! 123456void gcd(int a,int b,int &amp;m,int &amp;n) { if(b==0) {m=1,n=0;return;} gcd(b,a%b,m,n); int t=n; n=m-(a/b)*n,m=t;} 定理 4 若 \\(a\\mid bc\\), 且 \\((a,b)=1\\) ,那么 \\(a\\mid c\\). 证明 \\[ ma+nb=1\\\\ mac+nbc=c \\] 设 \\(bc=ka\\), 有 \\[ a(cm+kn)=c \\] 证毕 现在来研究 2 个数以上的最大公因数. 设 \\(n&gt;2,a_1&gt;0,a_2&gt;0\\dots a_n&gt;0,(a1,a2)=d_2,(d_2,a_3)=d_3,\\dots,(d_{n-1},a_n)=d_n\\). 有 定理 5 \\((a_1,a_2,\\dots,a_n)=d_n\\). 证明 有 \\(d_n\\mid d_{n-1},d_{n-1}\\mid d_{n-2},\\dots d_3\\mid d_2\\), 则 \\(d_n\\mid d_{n-1},d_n\\mid d_{n-2},\\dots,d_n\\mid d_2\\). 又 \\(d_2\\mid a_1,d_2\\mid a_2,d_3\\mid a_3,d_4\\mid a_4,\\dots,d_n\\mid a_n\\). 有 \\(d_n\\mid a_n,d_n\\mid a_{n-1},\\dots,d_n\\mid a_1\\). 另一方面,设 \\((a_1,a_2,\\dots,a_n)=d\\) ,由定理 3 的推论可得 \\(d\\mid d_2,d\\mid d_3,\\dots,d\\mid d_n\\), 所以 \\(d\\le d_n\\), 于是得到 \\((a_1,a_2,\\dots,a_n)=d_n\\). 证毕 定理 6 设 \\(a_1,a_2,\\dots,a_n\\) 是正整数,且 \\(n&gt;2\\) ,那么存在整数 \\(x_1,x_2,\\dots,x_n\\).那么 \\((a_1,a_2,\\dots,a_n)=a_1x_1+a_2x_2+\\dots+a_nx_n\\). 小结 定理 1 设 a,b,c 是3个不全为零的整数,且 \\(a=bq+c\\) ,其中 \\(q\\) 是整数,那么有 \\((a,b)=(b,c)\\). 定理 2 任给整数 \\(a&gt;0,b&gt;0\\) ,\\((a,b)\\) 就等于 (1) 中最后一个不等于零的余数,即 \\(r_n\\). 定理 3 若任给整数 \\(a&gt;0,b&gt;0\\) ,则有两个整数 \\(m,n\\) 使得 \\[ (a,b)=ma+nb. \\] 假设 \\(c\\) 是 a,b 的公因数,有 \\(c\\mid ma+nb\\),于是有 ​ 推论 a和b 的公因数是 (a,b) 的因数,即 \\(c\\mid (a,b)\\). 定理 4 若 \\(a\\mid bc\\), 且 \\((a,b)=1\\) ,那么 \\(a\\mid c\\). 定理 5 \\((a_1,a_2,\\dots,a_n)=d_n\\). 定理 6 设 \\(a_1,a_2,\\dots,a_n\\) 是正整数,且 \\(n&gt;2\\) ,那么存在整数 \\(x_1,x_2,\\dots,x_n\\).那么 \\((a_1,a_2,\\dots,a_n)=a_1x_1+a_2x_2+\\dots+a_nx_n\\). 定理 1 是定理 2 的基础,定理 2 证明了辗转相除法的正确性.定理 3 则适用于扩展欧几里得求解不定方程.定理 5 和定理 6 是多个数最大公因数的相关内容. 我愿称定理 2 为辗转相除法定理(gcd 等于辗转相除法中最后一个不为 0 的数),定理 3 为不定方程定理(gcd 使得不定方程有解). 另外一些个人认为比较重要的定理: 定理 S1 若 \\(a_1,a_2,\\dots,a_n\\) 为不等于 0 的整数,那么 \\((a_1,a_2,\\dots,a_n)=(|a_1|,|a_2|,\\dots,|a_n|)\\) 这个定理说明在讨论若干个数的最大公因数时,假设它们大于 0 不会失去一般性. 定理 S2 若整数 \\(a,b\\neq0\\),且 \\(ma+nb=n\\). 那么有 \\((a,b)\\mid n\\). §4 素数、整数的唯一分解定理 在正整数里(注意没有0,0没有因数),1 的因数只有它本身.大于 1 的正整数都至少有 2 个因数,即 1 和它本身. 定义 如果一个大于 1 的正整数的因数只有 1 和它本身,那么把它叫做质数或者素数,否则叫做合数(因数的数量大于2). 在证明整数的唯一分解定理前,先证明几个引理. 引理 1 设 a 是任意大于 1 的正整数,那么 a 的除 1 外的最小正因数是素数.设该素数为 q ,如果 a 是合数还有 \\[ q\\le \\sqrt a \\] 证明 若 q 不是质数,则有不为 1 的正整数 b 使得 \\(b\\mid q,b&lt;q\\),由于 \\(q\\mid a\\),那么 \\(b\\mid a\\),即 b 也是 a 的因数,与 q 为 a 的最小正因数矛盾. 若 a 是合数,设 \\(a=a_1q\\), 其中 \\(a_1\\) 为正整数,且 \\(q\\le a_1\\) ,那么 \\(q\\le \\sqrt a\\). 证毕 由这个定理,我们可以得知,如果知道了所有小于等于 \\(\\sqrt n\\) 的质数,那么便可判断 \\(2\\) 到 \\(n\\) 范围的所有整数是不是质数. 引理 2 若 p 为质数, a 为任意正整数,则 \\(p\\mid a\\),或 \\((p,a)=1\\). 证明 因为 \\((p,a)\\mid p\\),故 \\((p,a)=1\\) 或 \\((p,a)=p\\), 后者即 \\(p\\mid a\\). 证毕 引理 3 若 p 是质数,\\(p\\mid ab\\), 则 \\(p\\mid a\\) 或 \\(p\\mid b\\). 证明 若 \\(p\\nmid a\\), 由引理 2 知 \\((p,a)=1\\) .由 §2 的定理 2 知 \\(p\\mid b\\). 证毕 定理(整数的唯一分解定理) 任一大于 1 的整数能表成质数的乘积,若质数从小到大排列,则表示方法是唯一的.即对于任一整数 \\(a&gt;1\\) ,有 \\[ a=p_1p_2\\cdots p_n,\\quad p_1\\le p_2\\le p_n,\\tag 1 \\] 其中 \\(p_1,p_2,\\dots,p_n\\) 为质数,并且若 \\[ a=q_1q_2\\cdots q_m,\\quad q_1\\le q_2\\le \\dots \\le q_m,\\tag2 \\] 其中 \\(q_1,q_2,\\dots ,q_n\\) 为质数,则 \\(m=n,p_i=q_i(i=1,2,\\dots ,n)\\). 证明 首先运用数学归纳法证明 (1) 式成立. 当 \\(a=2\\) 时, (1) 式成立.当 \\(a&gt;2\\) 时,若 \\(a\\) 是质数,(1) 式成立.若 \\(a\\) 是合数,则有 2 个整数 \\(b,c\\) 满足条件 \\[ a=bc,\\quad 1&lt;b\\le c&lt;a, \\] 由归纳法假设,b 和 c 分别能表成质数的乘积,故 a 能表成质数的乘积. 其次,证明唯一性.若对 a 同时有 (1),(2) 两式成立,则 \\[ p_1p_2\\cdots p_n=q_1q_2\\cdots q_m.\\tag 3 \\] 由引理 (3) 知有 \\(p_k,q_j\\) 使得 \\(p_1p_2\\dots p_n\\mid q_j\\) , \\(q_1q_2\\dots q_m\\mid p_k\\). 那么 \\(p_1\\mid q_j\\), \\(q_1\\mid p_k\\). 由于 \\(q_j,p_k\\) 都是质数,所以 \\(p_1=q_j\\) , \\(q_1=p_k\\). 又 \\(p_1\\le p_k,q_1\\le q_j\\), 故同时有 \\(p_1\\le q_1, q_1\\le p_1\\) 成立,所以有 \\(p_1=q_1\\).同理可得 \\(p_2=q_2,p_3=q_3\\), 依次类推,最后得 \\(m=n,p_n=q_n\\). 说一下为什么可得到 \\(m=n\\). 假设 \\(m&gt;n\\), 在得到 \\(p_1=q_1\\) 后,将 (3) 式等号两边同时除以 \\(p_1\\),可得 \\(p_2p_3\\dots p_n=q_2q_3\\dots q_m\\). 同理,可消去 \\(p_1,p_2,\\dots,p_{n-1}\\), 此时有 \\(p_n=q_i,q_{i+1},\\dots,q_m\\),与 \\(p_n\\) 为质数矛盾.同理,可证明 \\(n&gt;m\\) 是不成立的. 证毕 整数唯一分解定理又叫算数基本定理,它告诉我们任一大于 1 的整数都能唯一的写成 \\[ a=p_1^{a_1}p_2^{a_2}\\dots p_n^{a_n},\\tag4 \\] 其中 \\(p_i&lt;p_j(i&lt;j)\\) 是质数. 叫做 a 的标准分解式. 如果 \\(d\\mid a,d&gt;0\\), 则由 (8) 和引理 3,d 可表成 \\[ d=p_1^{b_1}p_2^{b_2}\\dots p_n^{b_n},\\quad a_i\\ge b_i\\ge 0(i=1,\\dots,k)\\tag5 \\] 的形式.反之,如 d 可以表成 (5) 的形式,则必有 \\(d\\mid a,d&gt;0\\). 设 \\(a&gt;0,b&gt;0\\), 且 \\[ a=p_1^{a_1}p_2^{a_2}\\dots p_n^{a_n},\\quad a_i\\ge0(i=1,\\dots,k),\\\\ b=p_1^{b_1}p_2^{b_2}\\dots p_n^{b_n},\\quad b_i\\ge 0(i=1,\\dots,k), \\] 则 \\[ (a,b)=p_1^{c_1}p_2^{c_2}\\dots p_n^{c_n},\\quad c_i=\\min (a_i,b_i)\\quad (i=1,\\dots,k),\\\\ [a,b]=p_1^{d_1}p_2^{d_2}\\dots p_n^{d_n},\\quad d_i=\\max (a_i,b_i)\\quad (i=1,\\dots,k).\\tag6 \\] 由于 \\[ ab=\\max(a,b)\\times \\min (a,b),\\\\ a+b=\\max(a,b)+ \\min (a,b), \\] 由 (6) 可以得到 \\(ab=(a,b)\\times [a,b]\\). §5 素数筛法 §5.1 厄拉多塞筛法 古希腊数学家厄拉多塞(Eratosthenes)曾提出一个造出不超过 N 的素数表的方法,后来人们称之为厄拉多塞筛法. 我们在 §4 的引理 1处提到过,如果知道了所有小于等于 \\(\\sqrt n\\) 的质数,那么便可判断 \\(2\\) 到 \\(n\\) 范围的所有整数是不是质数.厄拉多塞筛法便是基于这一简单性质. 厄拉多塞筛法的具体方法为:先列出不超过 \\(\\sqrt N\\) 的全体质数,再将它们小于等于 N 的倍数从数表中划掉.最后存留在数表中的数即为质数. 当然,在编写程序时连不超过 \\(\\sqrt N\\) 的质数都不知道. 但只列出第一个质数 2 ,也可以筛出不超过 N 的素数.如果小于一个整数 \\(a\\) 的所有素数都已筛过,且没有对 a 进行标记,那么 a 显然是素数.从 3 开始枚举 a ,每次 a 可以增加 1,直到 a 达到 \\(\\sqrt N\\), 我们就完成了筛选.代码如下: 123456789int pri[PN];bool nok[N];void getPrime() { for(int i=2;i&lt;=SQN;i++) { if(nok[i]) continue; pri[++cnt]=i; for(int j=i*i;j&lt;=N;j+=i) nok[j]=true; }} 若 \\(j=i\\times q\\quad (q&lt;i)\\), 那么 nok[j]​ 在 i=q 的时候已经被筛过.所以 j 可以从 i*i 开始枚举. §5.2 线性筛法 线性筛法是一种在线性时间内筛出质数,数论积性函数值或约数个数,约数和的值的方法. 在使用厄拉多塞筛法时,会进行标记合数的操作,但一个合数可能被多次标记. 具体来说,使用厄拉多塞筛法一共需要标记 \\[ \\sum_{P\\le N} \\frac NP=N\\sum_{P\\le N}\\frac 1P \\] 次,时间复杂度为 \\(O(n\\log \\log n)\\). 如果每个合数能够只被标记一次,那么时间复杂度可降至 \\(O(n)\\) ,线性筛就是基于这一简单思想。 用每个合数乘上比自己小的质数，一定能标记到所有的合数。但若 \\(prime(j)\\) 是第一个能整除 \\(i\\) 的质数，那么后序的标记可看作是 \\(i*prime(k)=prime(j)*a*prime(k)\\)，而 \\(prime(j)*a\\) 在后面或前面一定会被枚举到。 那么,我们只需要枚举整数 m ,再枚举质数 a ,即可筛出质数. 123456789void getPrime() { for(int i=2;i&lt;=n;i++) { if(!nok[i]) pri[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=n;j++) { nok[pri[j]*i]=true; if(i%pri[j]==0) break; } }} 在 i 达到 \\(\\sqrt n\\) 时,就已经判断出哪些是素数.但为了得到连续的素数表,需要继续枚举到 n. §8 一次不定方程 二元一次不定方程是指 \\[ a_1x+a_2y=n,\\tag1 \\] 其中 \\(a_1,a_2,n\\) 被给定,且 \\(a_1,a_2\\neq0\\). 定理1 方程(1)有整数解 \\(x,y\\) 的充分必要条件是 \\[ (a_1,a_2)\\mid n.\\tag2 \\] 证明 假设(1)有解,那么(2)成立. 假设(1)无解,设 \\((a_1,a_2)=d\\). 并设 \\(a_1&gt;0,a_2&gt;0\\), 不失一般.由 §2 的定理 (3) 知,存在整数 u,v, 使得 \\(a_1u+a_2v=d\\). 那么, \\(x=\\cfrac {nu} d,y=\\cfrac {nv} d\\) 就是原方程的一组解. 证毕 这个定理也叫做裴蜀定理. 定理 2 设 \\((a_1,a_2)=d\\), 则(1)的全部解可表示为 \\[ x=x_0+\\cfrac {a_2t} d,\\quad y=y_0-\\cfrac {a_1t} d,\\tag3 \\] 其中 \\(x_0,y_0\\) 为 (1) 的一组解, \\(t\\) 为 \\(d\\) 的倍数. 证明 将(3)代入(1)得 \\[ a_1(x_0+\\cfrac {a_2t}d)+a_2(y_0-\\cfrac {a_1t} d)=a_1x_0+a_2y_0=n. \\] 证毕 其实, \\(t\\over d\\) 可以换成任意数,但那样得到的 \\(a_1,a_2\\) 就不是整数了. 习题 其实通过习题也可以得到很多有用的结论~ 2. 任意 n 个连续整数中 (\\(n\\ge1\\)), 有一个且仅有一个被 n 除尽. 证明 假设 n 个整数为 \\(s_1,s_2,\\dots,s_n\\), 且有使得 \\(s_1=x+1,s_2=x+2,\\dots\\) 的大于等于零的整数 \\(x\\) . 假设在 \\(s_1,s_2,\\dots,s_n\\) 中能被 n 除尽的最小的那个数为 \\(s_i\\), 并设 \\(s_i=np\\). 那么离 \\(s_i\\) 最近的两个能被 n 除尽的整数为 \\(n(p-1),n(p+1)\\). 由于 \\(s_i-s_1=i&lt; n,s_i-n(p-1)=n\\), 则 \\(s_1&gt;n(p-1)\\), 说明 \\(s_1,s_2,\\dots,s_n\\) 中任何一个数都不等于 \\(n(p-1)\\). 用类似方法可证得也不等于 \\(n(p+1)\\). 用反证法可以证得必有一个,懒得写了. 证毕 这玩意在解不定方程的时候证解的范围有点用.","link":"/2021/04/02/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"【小记】2019 CSP-J复赛游记","text":"不出行？不出行考屁呢？ 今天的CSP-J似乎比去年简单了一些，可它。。。 好了，来说一说我的情况。 T1：太水，5分钟秒 T2：这个数据有点尴尬，双重循环铁定爆，用链表有有一点小题大做。本蒟蒻在考场上打了三个版本才过了大样例。 说一下本蒟蒻的思路：首先用两个O（n）的数组存下时间与费用，若是地铁就直接存进去；若是公交车就往前扫，由于时间是递增的，当某一时刻时间差大于45时便停止遍历。若遇到可使用的优惠劵，则将该值清为0；若没有，ans加上price。 代码（或许有点差异）： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; using namespace std; int n,lx,price,t,a[100005],b[100005],ans,q=1; int main() { freopen(\"transfer.in\",\"r\",stdin); freopen(\"transfer.out\",\"w\",stdout); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;lx&gt;&gt;price&gt;&gt;t; if\\(lx==0\\) \\{ b\\[i\\]=t; a\\[i\\]=price; ans+=price; \\} if\\(lx==1\\) \\{ b\\[i\\]=t; a\\[i\\]=price; bool pd=false; for\\(int k=q;k\\&lt;i;k++\\) \\{ if\\(t-b\\[k\\]&gt;45\\) q=k+1; if\\(t-b\\[k\\]\\&lt;=45 \\&amp;\\&amp; a\\[k\\]&gt;=price\\) \\{ a\\[k\\]=0; pd=true; break; \\} \\} if\\(pd==false\\) ans+=price; \\} \\} cout\\&lt;\\&lt;ans\\&lt;\\&lt;endl; return 0; } T3：Orz太难了，比T4还难，像是背包可惜还可以卖，像是搜索可惜数据范围太大。在考场上只写了一个25%数据（应对n为1的情况）的DP，对了第一个样例 T4：本蒟蒻手推了半个小时，又打了半个小时的代码，找到了一个像是正解的算法，可惜是O（n^3) 555555555......QAQ 主要思路就是顺着推，从与小轩直接相连的工人开始，每遇着一个，便把和他相连的所有工人打上标记，等下次循环继续此操作。 其实这可以看作是求全集与每个工人对应的集的交集的过程，看出来了吗，并查集！！！可惜我忘了！！！ 1-16的测试点都只有1000的数据范围，可以用邻接矩阵。最后的应该要用邻接表，可惜我不会！！！ 一年OI一场空，本事不全见祖宗！ 附认真的反思： 就我个人来说，csp对我的意义，不能不说非常重大。 既然如何， 一般来说， 就我个人来说，csp对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 可是，即使是这样，csp的出现仍然代表了一定的意义。 从这个角度来看， 既然如何， 斯宾诺莎曾经说过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。带着这句话，我们还要更加慎重的审视这个问题： 而这些并不是完全重要，更加重要的问题是， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 可是，即使是这样，csp的出现仍然代表了一定的意义。 我们都知道，只要有意义，那么就必须慎重考虑。 现在，解决csp的问题，是非常非常重要的。 所以， 在这种困难的抉择下，本人思来想去，寝食难安。 所谓csp，关键是csp需要如何写。 我认为， 就我个人来说，csp对我的意义，不能不说非常重大。 马尔顿曾经说过，坚强的信心，能使平凡的人做出惊人的事业。这启发了我， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 而这些并不是完全重要，更加重要的问题是， 这样看来， 从这个角度来看， 邓拓在不经意间这样说过，越是没有本领的就越加自命不凡。这不禁令我深思。 经过上述讨论， 克劳斯·莫瑟爵士说过一句富有哲理的话，教育需要花费钱，而无知也是一样。这不禁令我深思。 白哲特曾经说过，坚强的信念能赢得强者的心，并使他们变得更坚强。 我希望诸位也能好好地体会这句话。 而这些并不是完全重要，更加重要的问题是， 我认为， 我们不得不面对一个非常尴尬的事实，那就是， 所谓csp，关键是csp需要如何写。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 所谓csp，关键是csp需要如何写。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 经过上述讨论， 在这种困难的抉择下，本人思来想去，寝食难安。 一般来讲，我们都必须务必慎重的考虑考虑。 带着这些问题，我们来审视一下csp。 经过上述讨论， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 所谓csp，关键是csp需要如何写。 可是，即使是这样，csp的出现仍然代表了一定的意义。 在这种困难的抉择下，本人思来想去，寝食难安。 博在不经意间这样说过，一次失败，只是证明我们成功的决心还够坚强。 维这句话语虽然很短，但令我浮想联翩。 那么， 这样看来， 既然如此， 克劳斯·莫瑟爵士在不经意间这样说过，教育需要花费钱，而无知也是一样。这似乎解答了我的疑惑。 那么， 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 要想清楚，csp，到底是一种怎么样的存在。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 现在，解决csp的问题，是非常非常重要的。 所以， 歌德曾经提到过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 既然如此， 伏尔泰曾经提到过，坚持意志伟大的事业需要始终不渝的精神。这似乎解答了我的疑惑。 要想清楚，csp，到底是一种怎么样的存在。 经过上述讨论， 要想清楚，csp，到底是一种怎么样的存在。 现在，解决csp的问题，是非常非常重要的。 所以， 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 阿卜·日·法拉兹说过一句富有哲理的话，学问是异常珍贵的东西，从任何源泉吸收都不可耻。带着这句话，我们还要更加慎重的审视这个问题： 歌德曾经提到过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 斯宾诺莎说过一句富有哲理的话，最大的骄傲于最大的自卑都表示心灵的最软弱无力。带着这句话，我们还要更加慎重的审视这个问题： 既然如何， 一般来讲，我们都必须务必慎重的考虑考虑。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 一般来讲，我们都必须务必慎重的考虑考虑。 鲁巴金说过一句富有哲理的话，读书是在别人思想的帮助下，建立起自己的思想。这启发了我， 就我个人来说，csp对我的意义，不能不说非常重大。 培根说过一句富有哲理的话，合理安排时间，就等于节约时间。这似乎解答了我的疑惑。 亚伯拉罕·林肯曾经说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。我希望诸位也能好好地体会这句话。 带着这些问题，我们来审视一下csp。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 经过上述讨论。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 问题的关键究竟为何？ 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 就我个人来说，csp对我的意义，不能不说非常重大。 杰纳勒尔·乔治·S·巴顿在不经意间这样说过，接受挑战，就可以享受胜利的喜悦。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 我们都知道，只要有意义，那么就必须慎重考虑。 从这个角度来看， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 那么， 既然如此， 莎士比亚说过一句富有哲理的话，本来无望的事，大胆尝试，往往能成功。这似乎解答了我的疑惑。 问题的关键究竟为何？ 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我认为， 每个人都不得不面对这些问题。 在面对这种问题时， 吕凯特曾经提到过，生命不可能有两次，但许多人连一次也不善于度过。这不禁令我深思。 而这些并不是完全重要，更加重要的问题是， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 那么， 总结的来说， 每个人都不得不面对这些问题。 在面对这种问题时， 从这个角度来看， 我们都知道，只要有意义，那么就必须慎重考虑。 问题的关键究竟为何？ 我认为， 我们不得不面对一个非常尴尬的事实，那就是， csp，到底应该如何实现。 每个人都不得不面对这些问题。 在面对这种问题时， 既然如此， 我们都知道，只要有意义，那么就必须慎重考虑。 所谓csp，关键是csp需要如何写。 现在，解决csp的问题，是非常非常重要的。 所以， 这样看来， 每个人都不得不面对这些问题。 在面对这种问题时， 我们不得不面对一个非常尴尬的事实，那就是， 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 经过上述讨论， 总结的来说， 一般来说， 一般来讲，我们都必须务必慎重的考虑考虑。 一般来说， csp，到底应该如何实现。 总结的来说， 可是，即使是这样，csp的出现仍然代表了一定的意义。 所谓csp，关键是csp需要如何写。 而这些并不是完全重要，更加重要的问题是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 csp，到底应该如何实现。 我们都知道，只要有意义，那么就必须慎重考虑。 富兰克林说过一句富有哲理的话，读书是易事，思索是难事，但两者缺一，便全无用处。这不禁令我深思。 就我个人来说，csp对我的意义，不能不说非常重大。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 带着这些问题，我们来审视一下csp。 要想清楚，csp，到底是一种怎么样的存在。 塞内加曾经说过，勇气通往天堂，怯懦通往地狱。我希望诸位也能好好地体会这句话。 我认为， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 富勒曾经提到过，苦难磨炼一些人，也毁灭另一些人。我希望诸位也能好好地体会这句话。 莎士比亚在不经意间这样说过，抛弃时间的人，时间也抛弃他。我希望诸位也能好好地体会这句话。 美华纳曾经提到过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这似乎解答了我的疑惑。 总结的来说， 我们都知道，只要有意义，那么就必须慎重考虑。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下csp。 每个人都不得不面对这些问题。 在面对这种问题时， 这样看来， 一般来说， 培根在不经意间这样说过，阅读使人充实，会谈使人敏捷，写作使人精确。这似乎解答了我的疑惑。 csp，到底应该如何实现。 就我个人来说，csp对我的意义，不能不说非常重大。 在这种困难的抉择下，本人思来想去，寝食难安。 总结的来说， 美华纳在不经意间这样说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这句话语虽然很短，但令我浮想联翩。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 一般来讲，我们都必须务必慎重的考虑考虑。 要想清楚，csp，到底是一种怎么样的存在。 问题的关键究竟为何？ 总结的来说， 那么， 既然如何， 从这个角度来看， 既然如何， 现在，解决csp的问题，是非常非常重要的。 所以， 我们不得不面对一个非常尴尬的事实，那就是。 就我个人来说，csp对我的意义，不能不说非常重大。 爱尔兰曾经说过，越是无能的人，越喜欢挑剔别人的错儿。我希望诸位也能好好地体会这句话。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 乌申斯基曾经提到过，学习是劳动，是充满思想的劳动。这似乎解答了我的疑惑。 一般来讲，我们都必须务必慎重的考虑考虑。 别林斯基说过一句富有哲理的话，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我认为， csp，发生了会如何，不发生又会如何。 伏尔泰说过一句富有哲理的话，不经巨大的困难，不会有伟大的事业。这句话语虽然很短，但令我浮想联翩。 带着这些问题，我们来审视一下csp。 现在，解决csp的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下csp。 亚伯拉罕·林肯在不经意间这样说过，我这个人走得很慢，但是我从不后退。这不禁令我深思。 要想清楚，csp，到底是一种怎么样的存在。 一般来说， 我认为， 我们都知道，只要有意义，那么就必须慎重考虑。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下csp。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 csp，发生了会如何，不发生又会如何。 带着这些问题，我们来审视一下csp。 既然如何， 既然如何。 在这种困难的抉择下，本人思来想去，寝食难安。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如何， csp因何而发生？ 每个人都不得不面对这些问题。 在面对这种问题时， 鲁巴金在不经意间这样说过，读书是在别人思想的帮助下，建立起自己的思想。这不禁令我深思。 美华纳在不经意间这样说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这启发了我， 既然如何， 既然如何， 斯宾诺莎曾经提到过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。这不禁令我深思。 带着这些问题，我们来审视一下csp。 带着这些问题，我们来审视一下csp。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 那么， 在这种困难的抉择下，本人思来想去，寝食难安。 现在，解决csp的问题，是非常非常重要的。 所以， 一般来讲，我们都必须务必慎重的考虑考虑。 拉罗什福科在不经意间这样说过，我们唯一不会改正的缺点是软弱。带着这句话，我们还要更加慎重的审视这个问题： 所谓csp，关键是csp需要如何写。 既然如此， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 csp，到底应该如何实现。 吉格·金克拉在不经意间这样说过，如果你能做梦，你就能实现它。带着这句话，我们还要更加慎重的审视这个问题： 经过上述讨论， 吉格·金克拉在不经意间这样说过，如果你能做梦，你就能实现它。这似乎解答了我的疑惑。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如何， 黑塞曾经说过，有勇气承担命运这才是英雄好汉。带着这句话，我们还要更加慎重的审视这个问题： 叔本华说过一句富有哲理的话，普通人只想到如何度过时间，有才能的人设法利用时间。这启发了我， 总结的来说， 在这种困难的抉择下，本人思来想去，寝食难安。 我们都知道，只要有意义，那么就必须慎重考虑。 一般来说， 一般来说， 我认为， 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 美华纳曾经提到过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这似乎解答了我的疑惑。 奥斯特洛夫斯基在不经意间这样说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。 带着这句话，我们还要更加慎重的审视这个问题： 德谟克利特在不经意间这样说过，节制使快乐增加并使享受加强。带着这句话，我们还要更加慎重的审视这个问题： 爱迪生曾经说过，失败也是我需要的，它和成功对我一样有价值。这不禁令我深思。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 一般来说， 可是，即使是这样，csp的出现仍然代表了一定的意义。 可是，即使是这样，csp的出现仍然代表了一定的意义。 现在，解决csp的问题，是非常非常重要的。 所以， 总结的来说， 希腊说过一句富有哲理的话，最困难的事情就是认识自己。我希望诸位也能好好地体会这句话。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 塞涅卡说过一句富有哲理的话，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这启发了我， 老子在不经意间这样说过，知人者智，自知者明。胜人者有力，自胜者强。我希望诸位也能好好地体会这句话。 既然如此， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如何， 我认为， 既然如此。 带着这些问题，我们来审视一下csp。 米歇潘说过一句富有哲理的话，生命是一条艰险的峡谷，只有勇敢的人才能通过。这不禁令我深思。 每个人都不得不面对这些问题。 在面对这种问题时， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 马尔顿曾经提到过，坚强的信心，能使平凡的人做出惊人的事业。这启发了我， 既然如何， 现在，解决csp的问题，是非常非常重要的。 所以， 我们都知道，只要有意义，那么就必须慎重考虑。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 那么， 可是，即使是这样，csp的出现仍然代表了一定的意义。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来说， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。这启发了我， 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 csp因何而发生？ 笛卡儿说过一句富有哲理的话，阅读一切好书如同和过去最杰出的人谈话。我希望诸位也能好好地体会这句话。 德谟克利特曾经说过，节制使快乐增加并使享受加强。这不禁令我深思。 一般来说， 一般来说， 所谓csp，关键是csp需要如何写。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 现在，解决csp的问题，是非常非常重要的。 所以， 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， csp，到底应该如何实现。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 csp，到底应该如何实现。 就我个人来说，csp对我的意义，不能不说非常重大。 从这个角度来看， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 洛克在不经意间这样说过，学到很多东西的诀窍，就是一下子不要学很多。这句话语虽然很短，但令我浮想联翩。 csp因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 csp，发生了会如何，不发生又会如何。 我认为， 莎士比亚曾经提到过，抛弃时间的人，时间也抛弃他。我希望诸位也能好好地体会这句话。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 卡莱尔曾经说过，过去一切时代的精华尽在书中。我希望诸位也能好好地体会这句话。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 就我个人来说，csp对我的意义，不能不说非常重大。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 要想清楚，csp，到底是一种怎么样的存在。 一般来说， 经过上述讨论， 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这似乎解答了我的疑惑。 就我个人来说，csp对我的意义，不能不说非常重大。 塞涅卡说过一句富有哲理的话，生命如同寓言，其价值不在与长短，而在与内容。这不禁令我深思。 而这些并不是完全重要，更加重要的问题是， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 布尔沃说过一句富有哲理的话，要掌握书，莫被书掌握；要为生而读，莫为读而生。我希望诸位也能好好地体会这句话。 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 所谓csp，关键是csp需要如何写。 就我个人来说，csp对我的意义，不能不说非常重大。 总结的来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 既然如此， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 叔本华曾经提到过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。我希望诸位也能好好地体会这句话。 每个人都不得不面对这些问题。 在面对这种问题时， csp因何而发生？ 这样看来， 问题的关键究竟为何？ 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 这样看来。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 那么， 从这个角度来看， 从这个角度来看， 富兰克林曾经说过，你热爱生命吗？那么别浪费时间，因为时间是组成生命的材料。这似乎解答了我的疑惑。 亚伯拉罕·林肯在不经意间这样说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。我希望诸位也能好好地体会这句话。 而这些并不是完全重要，更加重要的问题是， csp因何而发生？ 富兰克林曾经提到过，读书是易事，思索是难事，但两者缺一，便全无用处。这句话语虽然很短，但令我浮想联翩。 csp，发生了会如何，不发生又会如何。 富兰克林说过一句富有哲理的话，读书是易事，思索是难事，但两者缺一，便全无用处。带着这句话，我们还要更加慎重的审视这个问题： 既然如何， 要想清楚，csp，到底是一种怎么样的存在。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 从这个角度来看， 孔子曾经说过，知之者不如好之者，好之者不如乐之者。这不禁令我深思。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。带着这句话，我们还要更加慎重的审视这个问题： 白哲特说过一句富有哲理的话，坚强的信念能赢得强者的心，并使他们变得更坚强。 这似乎解答了我的疑惑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 裴斯泰洛齐曾经提到过，今天应做的事没有做，明天再早也是耽误了。这似乎解答了我的疑惑。 既然如何， 这样看来， 西班牙说过一句富有哲理的话，自己的鞋子，自己知道紧在哪里。带着这句话，我们还要更加慎重的审视这个问题： 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 我认为， 总结的来说， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 现在，解决csp的问题，是非常非常重要的。 所以， 那么， 德国曾经说过，只有在人群中间，才能认识自己。这不禁令我深思。 csp，到底应该如何实现。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 既然如何， csp，到底应该如何实现。 而这些并不是完全重要，更加重要的问题是， 这样看来， 这样看来， 总结的来说， 所谓csp，关键是csp需要如何写。 csp，到底应该如何实现。 问题的关键究竟为何？ 就我个人来说，csp对我的意义，不能不说非常重大。 csp，发生了会如何，不发生又会如何。 既然如何， 一般来说， 而这些并不是完全重要，更加重要的问题是， 别林斯基在不经意间这样说过，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 可是，即使是这样，csp的出现仍然代表了一定的意义。 这样看来， 既然如何， 从这个角度来看， csp，发生了会如何，不发生又会如何。 而这些并不是完全重要，更加重要的问题是， 我们不得不面对一个非常尴尬的事实，那就是， csp，到底应该如何实现。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 我认为， 亚伯拉罕·林肯在不经意间这样说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。这启发了我， 那么， 歌德在不经意间这样说过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 总结的来说， 我认为。 培根在不经意间这样说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。带着这句话，我们还要更加慎重的审视这个问题： 现在，解决csp的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 就我个人来说，csp对我的意义，不能不说非常重大。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 csp，发生了会如何，不发生又会如何。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是， 每个人都不得不面对这些问题。 在面对这种问题时， 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 我们不得不面对一个非常尴尬的事实，那就是， 而这些并不是完全重要，更加重要的问题是。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 经过上述讨论， 从这个角度来看， 这样看来， 既然如此， 那么， 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 总结的来说， 经过上述讨论， 我们都知道，只要有意义，那么就必须慎重考虑。 史美尔斯曾经说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。这似乎解答了我的疑惑。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来说， 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 奥普拉·温弗瑞曾经说过，你相信什么，你就成为什么样的人。这启发了我， 吉姆·罗恩曾经说过，要么你主宰生活，要么你被生活主宰。这似乎解答了我的疑惑。 海贝尔曾经说过，人生就是学校。在那里，与其说好的教师是幸福，不如说好的教师是不幸。这句话语虽然很短，但令我浮想联翩。 现在，解决csp的问题，是非常非常重要的。 所以， 我认为， 那么， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 带着这些问题，我们来审视一下csp。 要想清楚，csp，到底是一种怎么样的存在。 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这启发了我， 杰纳勒尔·乔治·S·巴顿在不经意间这样说过，接受挑战，就可以享受胜利的喜悦。我希望诸位也能好好地体会这句话。 我们不得不面对一个非常尴尬的事实，那就是， 所谓csp，关键是csp需要如何写。 既然如何， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 csp，到底应该如何实现。 赫尔普斯曾经提到过，有时候读书是一种巧妙地避开思考的方法。带着这句话，我们还要更加慎重的审视这个问题： 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 问题的关键究竟为何？ 带着这些问题，我们来审视一下csp。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 马云说过一句富有哲理的话，最大的挑战和突破在于用人，而用人最大的突破在于信任人。带着这句话，我们还要更加慎重的审视这个问题： csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 就我个人来说，csp对我的意义，不能不说非常重大。 csp，发生了会如何，不发生又会如何。 富勒说过一句富有哲理的话，苦难磨炼一些人，也毁灭另一些人。这句话语虽然很短，但令我浮想联翩。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 从这个角度来看， 经过上述讨论， csp，发生了会如何，不发生又会如何。 我们都知道，只要有意义，那么就必须慎重考虑。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 所谓csp，关键是csp需要如何写。 富勒说过一句富有哲理的话，苦难磨炼一些人，也毁灭另一些人。这启发了我， 要想清楚，csp，到底是一种怎么样的存在。 总结的来说， 这样看来， 带着这些问题，我们来审视一下csp。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 那么， 可是，即使是这样，csp的出现仍然代表了一定的意义。 csp因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 莎士比亚说过一句富有哲理的话，本来无望的事，大胆尝试，往往能成功。这不禁令我深思。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 经过上述讨论， 一般来讲，我们都必须务必慎重的考虑考虑。 既然如何， 可是，即使是这样，csp的出现仍然代表了一定的意义。 现在，解决csp的问题，是非常非常重要的。 所以， 总结的来说。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如此， 既然如何， 贝多芬在不经意间这样说过，卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。这句话语虽然很短，但令我浮想联翩。 卡耐基曾经提到过，一个不注意小事情的人，永远不会成就大事业。带着这句话，我们还要更加慎重的审视这个问题： 佚名在不经意间这样说过，感激每一个新的挑战，因为它会锻造你的意志和品格。这不禁令我深思。 每个人都不得不面对这些问题。 在面对这种问题时， 西班牙曾经说过，自己的鞋子，自己知道紧在哪里。这不禁令我深思。 既然如何。 我们都知道，只要有意义，那么就必须慎重考虑。 csp因何而发生？ 我认为， 从这个角度来看， 歌德说过一句富有哲理的话，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 既然如何， 卡耐基曾经说过，一个不注意小事情的人，永远不会成就大事业。我希望诸位也能好好地体会这句话。 问题的关键究竟为何？ csp因何而发生？ 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 卡耐基在不经意间这样说过，一个不注意小事情的人，永远不会成就大事业。这句话语虽然很短，但令我浮想联翩。 csp因何而发生？ 我们都知道，只要有意义，那么就必须慎重考虑。 亚伯拉罕·林肯曾经提到过，我这个人走得很慢，但是我从不后退。我希望诸位也能好好地体会这句话。 经过上述讨论， 问题的关键究竟为何？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。","link":"/2019/11/16/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%912019%20CSP-J%E5%A4%8D%E8%B5%9B%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"乘法逆元","slug":"乘法逆元","link":"/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"专题","slug":"专题","link":"/tags/%E4%B8%93%E9%A2%98/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"treap","slug":"treap","link":"/tags/treap/"},{"name":"CSP初赛","slug":"CSP初赛","link":"/tags/CSP%E5%88%9D%E8%B5%9B/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"波兰表达式","slug":"波兰表达式","link":"/tags/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"质数","slug":"质数","link":"/tags/%E8%B4%A8%E6%95%B0/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"KMP算法","slug":"KMP算法","link":"/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"快速读写","slug":"快速读写","link":"/tags/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"},{"name":"拉格朗日插值","slug":"拉格朗日插值","link":"/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"剪枝","slug":"剪枝","link":"/tags/%E5%89%AA%E6%9E%9D/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形动态规划","slug":"树形动态规划","link":"/tags/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"比赛","slug":"比赛","link":"/tags/%E6%AF%94%E8%B5%9B/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"小记","slug":"小记","link":"/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","link":"/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"杂项","slug":"杂项","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"模版","slug":"模版","link":"/tags/%E6%A8%A1%E7%89%88/"},{"name":"C++程序","slug":"C-程序","link":"/tags/C-%E7%A8%8B%E5%BA%8F/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"语法","slug":"语法","link":"/tags/%E8%AF%AD%E6%B3%95/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"数位 DP","slug":"数位-DP","link":"/tags/%E6%95%B0%E4%BD%8D-DP/"},{"name":"分数规划","slug":"分数规划","link":"/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"最大公约数","slug":"最大公约数","link":"/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"name":"树套树","slug":"树套树","link":"/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"计算复杂性理论","slug":"计算复杂性理论","link":"/tags/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"NOI online","slug":"NOI-online","link":"/tags/NOI-online/"},{"name":"资源","slug":"资源","link":"/tags/%E8%B5%84%E6%BA%90/"},{"name":"CSP","slug":"CSP","link":"/tags/CSP/"},{"name":"NOIP","slug":"NOIP","link":"/tags/NOIP/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二叉堆","slug":"二叉堆","link":"/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"},{"name":"思路巧妙","slug":"思路巧妙","link":"/tags/%E6%80%9D%E8%B7%AF%E5%B7%A7%E5%A6%99/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"二分答案","slug":"二分答案","link":"/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"Floyd","slug":"Floyd","link":"/tags/Floyd/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"思路巧妙(指被滑蒻稽切了)","slug":"思路巧妙-指被滑蒻稽切了","link":"/tags/%E6%80%9D%E8%B7%AF%E5%B7%A7%E5%A6%99-%E6%8C%87%E8%A2%AB%E6%BB%91%E8%92%BB%E7%A8%BD%E5%88%87%E4%BA%86/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"国家集训队","slug":"国家集训队","link":"/tags/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"},{"name":"可并堆","slug":"可并堆","link":"/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"},{"name":"逆序对","slug":"逆序对","link":"/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"主席树","slug":"主席树","link":"/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"差分约束","slug":"差分约束","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"强联通分量","slug":"强联通分量","link":"/tags/%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"USACO","slug":"USACO","link":"/tags/USACO/"},{"name":"DAG","slug":"DAG","link":"/tags/DAG/"},{"name":"拓扑","slug":"拓扑","link":"/tags/%E6%8B%93%E6%89%91/"},{"name":"网络流24题","slug":"网络流24题","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"割点","slug":"割点","link":"/tags/%E5%89%B2%E7%82%B9/"},{"name":"费用流","slug":"费用流","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"点分治","slug":"点分治","link":"/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"连通性问题","slug":"连通性问题","link":"/tags/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"逆元","slug":"逆元","link":"/tags/%E9%80%86%E5%85%83/"},{"name":"异或","slug":"异或","link":"/tags/%E5%BC%82%E6%88%96/"},{"name":"exgcd","slug":"exgcd","link":"/tags/exgcd/"},{"name":"二分法","slug":"二分法","link":"/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"树论","slug":"树论","link":"/tags/%E6%A0%91%E8%AE%BA/"},{"name":"SPOJ","slug":"SPOJ","link":"/tags/SPOJ/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"素数","slug":"素数","link":"/tags/%E7%B4%A0%E6%95%B0/"},{"name":"任务计划","slug":"任务计划","link":"/tags/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/"},{"name":"规律","slug":"规律","link":"/tags/%E8%A7%84%E5%BE%8B/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"约瑟夫问题","slug":"约瑟夫问题","link":"/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"}],"categories":[{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"树形数据结构","slug":"数据结构/树形数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"赛前","slug":"赛前","link":"/categories/%E8%B5%9B%E5%89%8D/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"同余","slug":"数论/同余","link":"/categories/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/"},{"name":"动态规划","slug":"动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分图","slug":"图论/二分图","link":"/categories/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"连通性问题","slug":"图论/连通性问题","link":"/categories/%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"name":"质数","slug":"数论/质数","link":"/categories/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/"},{"name":"平衡树","slug":"数据结构/树形数据结构/平衡树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"基础算法","slug":"基础算法","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"字典树","slug":"数据结构/树形数据结构/字典树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"并查集","slug":"数据结构/树形数据结构/并查集","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"CSP初赛","slug":"赛前/CSP初赛","link":"/categories/%E8%B5%9B%E5%89%8D/CSP%E5%88%9D%E8%B5%9B/"},{"name":"卡常+优化","slug":"卡常-优化","link":"/categories/%E5%8D%A1%E5%B8%B8-%E4%BC%98%E5%8C%96/"},{"name":"整除","slug":"数论/整除","link":"/categories/%E6%95%B0%E8%AE%BA/%E6%95%B4%E9%99%A4/"},{"name":"波兰表达式","slug":"杂项/波兰表达式","link":"/categories/%E6%9D%82%E9%A1%B9/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"多项式","slug":"多项式","link":"/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"线性数据结构","slug":"数据结构/线性数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"区间动态规划","slug":"动态规划/区间动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树论","slug":"图论/树论","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E8%AE%BA/"},{"name":"树形动态规划","slug":"动态规划/树形动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩动态规划","slug":"动态规划/状态压缩动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字典树","slug":"字符串/字典树","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"线性动态规划","slug":"动态规划/线性动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线段树","slug":"数据结构/树形数据结构/线段树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"最短路问题","slug":"图论/最短路问题","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"name":"比赛","slug":"比赛","link":"/categories/%E6%AF%94%E8%B5%9B/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"小记","slug":"小记","link":"/categories/%E5%B0%8F%E8%AE%B0/"},{"name":"KMP算法","slug":"字符串/KMP算法","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP%E7%AE%97%E6%B3%95/"},{"name":"哈希","slug":"基础算法/哈希","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"},{"name":"工具","slug":"杂项/工具","link":"/categories/%E6%9D%82%E9%A1%B9/%E5%B7%A5%E5%85%B7/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"基础","slug":"数学/基础","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80/"},{"name":"逻辑","slug":"杂项/逻辑","link":"/categories/%E6%9D%82%E9%A1%B9/%E9%80%BB%E8%BE%91/"},{"name":"读写相关","slug":"卡常-优化/读写相关","link":"/categories/%E5%8D%A1%E5%B8%B8-%E4%BC%98%E5%8C%96/%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/"},{"name":"拉格朗日插值","slug":"多项式/拉格朗日插值","link":"/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"name":"Splay","slug":"数据结构/树形数据结构/平衡树/Splay","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/Splay/"},{"name":"排序","slug":"基础算法/排序","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"可并堆","slug":"数据结构/树形数据结构/可并堆","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%AF%E5%B9%B6%E5%A0%86/"},{"name":"分数规划","slug":"数学/分数规划","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"搜索","slug":"基础算法/搜索","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"分治","slug":"基础算法/分治","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"},{"name":"其他","slug":"数学/其他","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/"},{"name":"treap","slug":"数据结构/树形数据结构/平衡树/treap","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/treap/"},{"name":"分块","slug":"数据结构/线性数据结构/分块","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%86%E5%9D%97/"},{"name":"树套树","slug":"数据结构/树形数据结构/平衡树/树套树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"数论函数","slug":"数论/数论函数","link":"/categories/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/"},{"name":"计算机科学","slug":"计算机科学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"LCA","slug":"图论/树论/LCA","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E8%AE%BA/LCA/"},{"name":"线性代数","slug":"线性代数","link":"/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"树链剖分","slug":"数据结构/树形数据结构/树链剖分","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"资源","slug":"资源","link":"/categories/%E8%B5%84%E6%BA%90/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"规律","slug":"数学/规律","link":"/categories/%E6%95%B0%E5%AD%A6/%E8%A7%84%E5%BE%8B/"},{"name":"高精度","slug":"基础算法/高精度","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"背包动态规划","slug":"动态规划/背包动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"莫队","slug":"数据结构/线性数据结构/莫队","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%8E%AB%E9%98%9F/"},{"name":"递推","slug":"基础算法/递推","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/"},{"name":"其他","slug":"比赛/其他","link":"/categories/%E6%AF%94%E8%B5%9B/%E5%85%B6%E4%BB%96/"},{"name":"字符串","slug":"字符串/字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"CSP","slug":"比赛/CSP","link":"/categories/%E6%AF%94%E8%B5%9B/CSP/"},{"name":"提高","slug":"测试/提高","link":"/categories/%E6%B5%8B%E8%AF%95/%E6%8F%90%E9%AB%98/"},{"name":"博客搭建","slug":"小记/博客搭建","link":"/categories/%E5%B0%8F%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"OI日记","slug":"小记/OI日记","link":"/categories/%E5%B0%8F%E8%AE%B0/OI%E6%97%A5%E8%AE%B0/"},{"name":"普及","slug":"测试/普及","link":"/categories/%E6%B5%8B%E8%AF%95/%E6%99%AE%E5%8F%8A/"},{"name":"刷题记录","slug":"小记/刷题记录","link":"/categories/%E5%B0%8F%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"树状数组","slug":"数据结构/树形数据结构/树状数组","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"软件","slug":"小记/软件","link":"/categories/%E5%B0%8F%E8%AE%B0/%E8%BD%AF%E4%BB%B6/"},{"name":"经验","slug":"小记/经验","link":"/categories/%E5%B0%8F%E8%AE%B0/%E7%BB%8F%E9%AA%8C/"},{"name":"OI历程","slug":"小记/OI历程","link":"/categories/%E5%B0%8F%E8%AE%B0/OI%E5%8E%86%E7%A8%8B/"},{"name":"差分约束","slug":"图论/差分约束","link":"/categories/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"操作系统","slug":"小记/操作系统","link":"/categories/%E5%B0%8F%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"语言","slug":"C/语言","link":"/categories/C/%E8%AF%AD%E8%A8%80/"},{"name":"网络流","slug":"图论/网络流","link":"/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"map","slug":"STL/map","link":"/categories/STL/map/"},{"name":"algorithm","slug":"STL/algorithm","link":"/categories/STL/algorithm/"},{"name":"快速幂","slug":"数学/基础/快速幂","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"主席树","slug":"数据结构/树形数据结构/主席树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"面向对象","slug":"C/面向对象","link":"/categories/C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"组合数学","slug":"组合数学","link":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"C/位运算","link":"/categories/C/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"AtCoder","slug":"比赛/AtCoder","link":"/categories/%E6%AF%94%E8%B5%9B/AtCoder/"},{"name":"点分治","slug":"数据结构/树形数据结构/点分治","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"Codeforces","slug":"比赛/Codeforces","link":"/categories/%E6%AF%94%E8%B5%9B/Codeforces/"},{"name":"vector","slug":"STL/vector","link":"/categories/STL/vector/"},{"name":"洛谷","slug":"比赛/洛谷","link":"/categories/%E6%AF%94%E8%B5%9B/%E6%B4%9B%E8%B0%B7/"},{"name":"贪心","slug":"基础算法/贪心","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"省选","slug":"测试/省选","link":"/categories/%E6%B5%8B%E8%AF%95/%E7%9C%81%E9%80%89/"},{"name":"AC自动机","slug":"字符串/AC自动机","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串哈希","slug":"字符串/字符串哈希","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"任务计划","slug":"杂项/任务计划","link":"/categories/%E6%9D%82%E9%A1%B9/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/"},{"name":"拓扑排序","slug":"基础算法/排序/拓扑排序","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"链表","slug":"数据结构/线性数据结构/链表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"剪枝","slug":"基础算法/搜索/剪枝","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%89%AA%E6%9E%9D/"},{"name":"逆元","slug":"数学/其他/逆元","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E9%80%86%E5%85%83/"},{"name":"计算复杂性理论","slug":"计算机科学/计算复杂性理论","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/"},{"name":"差分","slug":"基础算法/差分","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/"},{"name":"高斯消元","slug":"线性代数/高斯消元","link":"/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"题目","slug":"资源/题目","link":"/categories/%E8%B5%84%E6%BA%90/%E9%A2%98%E7%9B%AE/"},{"name":"成绩","slug":"资源/成绩","link":"/categories/%E8%B5%84%E6%BA%90/%E6%88%90%E7%BB%A9/"},{"name":"XCSY","slug":"题解/XCSY","link":"/categories/%E9%A2%98%E8%A7%A3/XCSY/"},{"name":"洛谷","slug":"题解/洛谷","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"},{"name":"NOIP","slug":"题解/NOIP","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/"},{"name":"矩阵","slug":"线性代数/矩阵","link":"/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"},{"name":"2021","slug":"小记/刷题记录/2021","link":"/categories/%E5%B0%8F%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2021/"},{"name":"省选","slug":"题解/省选","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/"},{"name":"思维题","slug":"数学/思维题","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"USACO","slug":"题解/USACO","link":"/categories/%E9%A2%98%E8%A7%A3/USACO/"},{"name":"排列组合","slug":"组合数学/排列组合","link":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"ABC","slug":"比赛/AtCoder/ABC","link":"/categories/%E6%AF%94%E8%B5%9B/AtCoder/ABC/"},{"name":"Div.2","slug":"比赛/Codeforces/Div-2","link":"/categories/%E6%AF%94%E8%B5%9B/Codeforces/Div-2/"},{"name":"二分答案","slug":"基础算法/二分答案","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"NOIO","slug":"题解/NOIO","link":"/categories/%E9%A2%98%E8%A7%A3/NOIO/"},{"name":"归并排序","slug":"基础算法/排序/归并排序","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"数据结构/树形数据结构/堆","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"},{"name":"1999","slug":"题解/NOIP/1999","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/1999/"},{"name":"2006","slug":"题解/NOIP/2006","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2006/"},{"name":"2012","slug":"题解/NOIP/2012","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2012/"},{"name":"2007","slug":"题解/NOIP/2007","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2007/"},{"name":"2011","slug":"题解/NOIP/2011","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2011/"},{"name":"APIO","slug":"题解/APIO","link":"/categories/%E9%A2%98%E8%A7%A3/APIO/"},{"name":"2010","slug":"题解/NOIP/2010","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2010/"},{"name":"SCOI","slug":"题解/省选/SCOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/SCOI/"},{"name":"SDOI","slug":"题解/省选/SDOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/SDOI/"},{"name":"单调栈","slug":"数据结构/线性数据结构/单调栈","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"2013","slug":"题解/NOIP/2013","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2013/"},{"name":"CTSC","slug":"题解/CTSC","link":"/categories/%E9%A2%98%E8%A7%A3/CTSC/"},{"name":"2016","slug":"题解/NOIP/2016","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2016/"},{"name":"HNOI","slug":"题解/省选/HNOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/HNOI/"},{"name":"CQOI","slug":"题解/省选/CQOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/CQOI/"},{"name":"JSOI","slug":"题解/省选/JSOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/JSOI/"},{"name":"AHOI","slug":"题解/省选/AHOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/AHOI/"},{"name":"JLOI","slug":"题解/省选/JLOI","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/JLOI/"},{"name":"set","slug":"STL/set","link":"/categories/STL/set/"},{"name":"异或","slug":"数学/基础/异或","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%88%96/"},{"name":"2019","slug":"题解/NOIP/2019","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2019/"},{"name":"省选联考","slug":"题解/省选/省选联考","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/%E7%9C%81%E9%80%89%E8%81%94%E8%80%83/"},{"name":"2003","slug":"题解/NOIP/2003","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/2003/"},{"name":"UVA","slug":"题解/UVA","link":"/categories/%E9%A2%98%E8%A7%A3/UVA/"},{"name":"MtOI","slug":"题解/MtOI","link":"/categories/%E9%A2%98%E8%A7%A3/MtOI/"},{"name":"二叉树","slug":"数据结构/树形数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"最小生成树","slug":"图论/树论/最小生成树","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]}