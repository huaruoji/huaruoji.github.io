{"pages":[{"title":"友链","text":"这里还没有友链~ 请在下方留言,我一定会回复的!","link":"/%E5%8F%8B%E9%93%BE/index.html"},{"title":"关于","text":"关于我 My luogu My codforces My AtCoder 关于文章 文章分为\"题解\",\"小记\",\"专题\"和\"杂项\"四种类型.特别说明,\"专题\"中如果出现了例题,一定是在撰写该文章前后2天做到的题(也就是入门题目).其余的题目会发到\"题解\". 所有的文章,如果过长,会加上&lt;!--more--&gt;标签,即\"阅读更多\"效果. 关于本博客 使用Github Pages+Hexo搭建, 主题是iracus. 使用了AlphaLxy提供的个性化配置方案! 本站无盈利性目的,仅为自己学习所用.如果能帮助到大家,那就更好了.","link":"/about/index.html"}],"posts":[{"title":"【专题】Trie树（基本无用）","text":"pz:Trie树-&gt;字典树 就是查字典用到的树! 具体来说就是一颗26叉树,代表璎文26个字母,这样查询单词起来就变得10分的快速了. build函数,建立Trie树 s(search)函数,查找该使用前缀的单词出现次数 记录一下偶滴辞典 http://acm.hdu.edu.cn/showproblem.php?pid=1251模版题 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; char str[20]; int trie[1000005][26]; int cnt[1000005]; int tot; void build() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) trie[p][str[i]-'a']=++tot; p=trie[p][str[i]-'a']; cnt[p]++; } } int s() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) return 0; p=trie[p][str[i]-'a']; } return cnt[p]; } int main() { ios::sync_with_stdio(false); while\\(gets\\(str\\) \\&amp;\\&amp; str\\[0\\]\\!='\\\\0'\\) \\{ build\\(\\); \\} while\\(scanf\\(&quot;\\%s&quot;,str\\)\\!=EOF\\) \\{ cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​ ​ return 0; } 前缀统计 题目描述 给定N个字符串S1,S2...SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。 输入字符串的总长度不超过10^6，仅包含小写字母。 输入格式 第一行两个整数N，M； 接下来N行每行一个字符串Si ； 接下来M行每行一个字符串表示询问。 输出格式 对于每个询问，输出一个整数表示答案 输入输出样例 输入 #1复制 3 2 ab bc abc abc efg 输出 #1复制 2 0 pz:和模版反了过来,但是代码cbd 修改如下: 1. tot只记录Si尾部字母 2. 询问出现次数 返回值累加 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; char str[1000005]; int trie[1000005][26]; int cnt[1000005]; int tot,n,m; void build() { int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) trie[p][str[i]-'a']=++tot; p=trie[p][str[i]-'a']; } cnt[p]++; } int s() { int p=0,ans=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-'a']==0) return ans; p=trie[p][str[i]-'a']; ans+=cnt[p]; } return ans; } int main() { ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;str; build\\(\\); \\} for\\(int j=1;j\\&lt;=m;j++\\) \\{ cin&gt;&gt;str; cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​ ​ return 0; } 2020/3/28 20:39","link":"/2020/03/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91Trie%E6%A0%91/"},{"title":"【专题】乘法逆元","text":"乘法逆元,一般用于将模意义下的除法转换为乘法.本文介绍了乘法逆元,并给出了算法实现. 前言: 乘法逆元,一般用于将模意义下的除法转换为乘法 求解普通逆元(\\(ax\\equiv 1(mod\\ m)\\)) 拓展欧几里得 首先我们看看逆元的定义:若\\(ax\\equiv 1(mod \\ m)\\),且a与m互质,则\\(x\\)为\\(a\\)在\\(mod \\ m\\)意义下的乘法逆元,记作\\(a^{-1}\\). 根据这个同余式,我们可以得到\\(ax+km=1\\),且a和m是互质的,那么就满足贝祖等式\\(ax+by=gcd(a,b)\\),可以用拓欧求解. 1234567891011ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)//ax+by{ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y),t=x; x=y,y=t-(a/b)*x; return ret;} 这个板子虽然稍长,但返回值是gcd,用处更广泛 另外,由于gcd求得负数和1最大公约数是-1,exgcd不能用来求解a为负数的情况 快速幂 观察乘法逆元的形式:\\(ax \\equiv1(mod \\ m)\\). 考虑到欧拉定理:\\(a^{\\varphi (m)} \\equiv 1(mod\\ m)\\). 由于洛谷模版题中给出m为质数,则有: \\[ ax \\equiv a^{m-1}(mod\\ m)\\\\a \\equiv a^{m-2}(mod \\ m) \\] \\(那么,a在mod \\ m意义下的乘法逆元即为a^{m-2} mod \\ m\\),满足快速幂形式,可使用快速幂求解. 12345678910111213ll fpm(ll x, ll power, ll mod) { x%=mod; ll ans=1; for (;power;power&gt;&gt;=1,(x*=x)%=mod) if(power&amp;1)(ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);} 代码中的(ans*=x)%=mod即为(ans=ans*x)=(ans=ans*x)%mod.ns*x)%mod`.","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"【专题】二分图","text":"二分图的判定 定理：一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。 利用 DFS 进行染色。如果环的长度为偶数，不会出现颜色相同的冲突，反之则会。 1234567891011bool dfs(int u,int col) { int len=g[u].size(); color[u]=col; for(int i=0;i&lt;len;i++) { int&amp; v=g[u][i]; if(color[v]==color[u]) return false; else if(color[v]==0 &amp;&amp; dfs(v,-col)==false) return false; } return true;}//color[i]为-1,0或1 -1,1表示颜色 0表示是否访问 二分图最大匹配 匈牙利算法 二分图的增广路：增广路是二分图中的一条路径。增广路的起点和终点都是未匹配点。增广路由已选择路径和未选择路径交替组成，也就是说，增广路含有的原本两部之间路径数量为奇数。 将增广路中的所有已选择路径改为未选择路径，未选择路径改为已选择路径，匹配数量就增加了 1 。 匈牙利算法（Hungarian Algorithm）不断寻找增广路，直到找到二分图的最大匹配。 特性：当一个节点成为匹配节点，就不会再变成未匹配节点。（可以用来输出匹配方案） 时间复杂度：\\(O(NM)\\) 1234567891011bool dfs(int u) { int len=g[u].size(); for(int i=0;i&lt;len;i++) { int &amp;v=g[u][i]; if(!vis[v]) { vis[v]=true; if(!mat[v] || dfs(mat[v])) {mat[v]=u;return true;} } } return false;} 其中，vis 数组的作用仅仅是避免单次寻找增广路时的重复搜索，所以每次执行 dfs 前都要清零。 二分图带权最大匹配 等我学了网络流再说 二分图最大独立集 选最多的点，满足两两之间没有边相连。 二分图中，最大独立集 = \\(n\\) - 最大匹配。 二分图最小点覆盖 对于一个二分图，求出一个最小的点集 \\(S\\)，使得图中任意一条边都至少有一个端点属于 \\(S\\)。\\(S\\) 就是这个二分图的最小点覆盖。 König定理：二分图最小点覆盖包含的点数等于二分图最大匹配包含的边数。 构造点覆盖的方法： 求出二分图最大匹配 从左部每个匹配点出发，再执行一次 DFS 寻找增广路的过程，标记访问过的节点。 取左部未被标记的点，右部被标记了点，就得到了二分图的最小点覆盖。","link":"/2021/03/31/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"【专题】二叉搜索树","text":"前言 二叉搜索树的右节点","link":"/2021/04/16/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"【专题】初赛位运算","text":"以下摘自洛谷日报 “&lt;&lt;” “&gt;&gt;” 运算 首先，在这里这东西跟 cin cout 没有什么关系。 在二进制运算中，这东西叫做“左移”“右移”运算，顾名思义，就是将一个二进制数向左或向右移动 k 位，就是给一个数乘 2^k 或者除 2^k (末尾1不计)。 那么这东西有什么用呢？这东西快啊 “~”运算 又称取反运算，就是对一个二进制数按位取反。 对于 int 来说， ~ x=-x-1 那么这东西有什么用呢？我也不知道 “&amp;”运算 “&amp;”运算，即“and” 运算，也是一种逻辑运算符，对于二进制运算来说，“&amp;”运算的意义是对于两个二进制数的每一位，如果这一位都是 1 ，那么这一位为 1 ，否则这一位为 0 。 举个例子 10101(21) &amp; 11100(28) = 10100{20} 我们可以用 &amp; 运算判断一个数是奇数还是偶数，当 x 为奇数时， x 二进制下的第 0 位一定是 1 ，否则为 0 。我们让 x &amp; 1 ，就可以知道 x 的奇偶性了。 “|” 运算 即 “or” 运算，也是一种逻辑运算符，对于二进制运算来说，“|” 运算的意义是对于两个二进制数的每一位，如果这两个数此位有一个 1 那么此位就是 1 ，否则为 0 。 举个例子 10101(21) | 11100(28) = 11101(29) 通过对这两个运算的观察，我们可以发现一个规律 x &amp; y&lt;=xx | y&gt;=x 根据二进制的性质很容易就可以得出这些结论吧 “^”运算 “^”运算，又称“xor”运算，异或运算。定义是对于两个二进制数的每一位，如果相同则为 0 ，否则为 1 。 举个例子 10101(21) ^ 11100(28) = 1001(9) 异或是一个非常神奇的东东 首先显而易见的是一个数异或他自己肯定是得 0 的 其次对于一个形如 2n 的数 x ， x ^ 1 =x+1 ,而对于一个形如 2n+1 的数 x ， x ^ 1 =x-1 然后异或运算满足以下交换律 如果 x ^ y=z 那么 y ^ z=x ， x ^ z=y 异或运算还是比较常用到的，简单举两个例子 例题一 给你 n 个数，其中只有一个数出现过一次，其余都成对出现，问只出现过一次的那个数是那个数。 原题 P1469 找筷子（https://www.luogu.org/problemnew/show/P1469） 利用异或的性质 x ^ x=0 ，将所有数异或起来，最后剩下来的那个数就是答案了。 例题二 计算 1 ^ 2 ^ 3 ^ 4 ^ … ^ n 的值 原题 P3908 异或之和（https://www.luogu.org/problemnew/show/P3908） 首先最开始是 1 ，根据异或的性质，我们可以知道 (2n) ^ 1 是等于 2n+1 的 于是我们又回到了 1 ，所以可以得出答案是以 4 为周期循环的。 ------------ 接下来厉害的来了，这三种运算是可以互相转换的 x|y= ~ (( ~ x) &amp; ( ~ y)) x &amp; y= ~ (( ~ x)|( ~ y)) x ^ y=(x|y)-(x &amp; y)=x+y-((x &amp; y)&lt;&lt;1) 但这东西似乎除了能让你感受到位运算的博大精深以外似乎什么用都没有 洛谷日报结束 位运算大部分人都知道，看一道18年初赛题： 14. 为了统计一个非负整数的二进制形式中 1 的个数，代码如下: int CountBit(int x) { int ret = 0; while (x) { ret++; ___________; } return ret; } 则空格内要填入的语句是( )。 A. x &gt;&gt;= 1 B. x &amp;= x - 1 C. x |= x &gt;&gt; 1 D. x &lt;&lt;= 1 答案为B 这种题思路就是先举1个数，再一个一个代入。 如9 二进制为 1001 A选项只会一次删掉一位 1001 100 10 1 答案为4，排除 B选项 1001 &amp; 1000 = 1000 1000 &amp; 0111 = 0 答案为2，正确 C选项 错 D选项 死循环，与A类似","link":"/2019/10/18/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%88%9D%E8%B5%9B%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"【专题】前缀，后缀表达式求值","text":"前缀表达式 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从右至左，遇数压1，遇符弹2，再来计算。 后缀表达式 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从左至右，遇数压1，遇符弹2，再来计算。 例题 https://www.luogu.org/problem/P1449 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; int a[1005],p,top,t; char c; int main() { while(c=getchar()) { if(c=='@') break; if(isdigit(c)) t=t*10+c-'0'; if(c=='.') { a[++top]=t; t=0; } if(c=='+') { a[top-1]=a[top]+a[top-1]; top--; } if(c=='-') { a[top-1]=a[top-1]-a[top]; top--; } if(c=='*') { a[top-1]=a[top]*a[top-1]; top--; } if(c=='/') { a[top-1]=a[top-1]/a[top]; top--; } } cout&lt;&lt;a[top]; return 0; } 注意事项： 1.有除法，并且就按c++里的整除运算 2.getchar()在cstdio里面","link":"/2019/10/19/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%89%8D%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"title":"【专题】区间动态规划","text":"区间动态规划的特征 不同于线性动态规划将一个\"点\"的位置作为状态信息,比如LIS(f[i]表示前i个数的最优解),LCS(\\(f[i][j]\\)表示A串前i个数,B串前j个数的最优解).区间动态规划往往将\"区间\"作为状态信息存储,比如\\(f[l][r]\\)表示区间\\([l,r]\\)的最优解.实际上,线性动态规划可以看做左端点或右端点固定的区间动态规划. 虽然状态信息变了,但是动态规划的本质没有变.在区间动态规划中,一个小区间的最优解满足无后效性,这让它可以扩展到大区间.在解题确定状态时一定要满足这个规则. 例题 P1880 [NOI1995] 石子合并 Des 在一个圆形操场的四周摆放 N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。 Sol 如果不是在圆形操场上摆放,而仅仅是在一条直线跑道上摆放石子的话,本题可能不足以被打上普及+/提高的标签.这种区间在环上的问题也被称作环形动态规划,大佬们已经研究出了套路:变环为链.将样例中环4 5 9 4扩展成链4 5 9 4 9 5 4,这样虽然增加了数据规模,但是降低了状态转移方程算法实现的难度. 将\\(f[i][j]\\)定义为区间\\([i,j]\\)的最优解.显然\\(f[i][j]\\)可以从任意\\(f[i][k],f[k+1][j](i&lt;k&lt;j)\\)转移得到(即两堆合并好的石子).要求出长度为\\(l\\)的区间最优解,必须知道长度为\\(l-1\\)的区间最优解.所以先枚举长度\\(l\\),再枚举左端点\\(i\\),然后计算区间的右端点(\\(i+l-1\\)).最后枚举\\(k\\). 这个时候,变环为链的优越性就体现出来了,无论你怎么取i,j,链中的状态都可以对应到环上去,不会出现答案比原来大或者小的情况.这里要注意,枚举的i的上界必须到\\(2n-1\\).比如\\(f[4][6]\\)的值需要从\\(f[5][6]\\)更新,但\\(f[5][6]\\)没计算怎么行呢? 这种解法的代码可以参考洛谷题解,但我由于是第一次做,使用了自己的方法.我的方法就是将\\(f[i][j]\\)定义为从i开始长度为j的区间的最优解.这样不用变环为链,但下标涉及到取模,容易写错.具体看我的代码吧. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//环形DP #include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,a[N],add[N][N],f[N][N],ans=2e9;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; add[i][1]=a[i]; } for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;=n;i++) { f[i][j]=2e9; int cur=(i+j-1)%n; if(cur==0) cur=n; add[i][j]=add[i][j-1]+a[cur]; for(int k=1;k&lt;j;k++) { cur=(i+k-1)%n; int p2=(i+k)%n; if(p2==0) p2=n;//坑点 f[i][j]=min(f[i][j],f[i][k]+f[p2][j-k]+add[i][j]); } } } for(int i=1;i&lt;=n;i++) { ans=min(ans,f[i][n]); } cout&lt;&lt;ans&lt;&lt;endl; memset(f,0,sizeof(f)); for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;=n;i++) { int cur=(i+j-1)%n; if(cur==0) cur=n; add[i][j]=add[i][j-1]+a[cur]; for(int k=1;k&lt;j;k++) { cur=(i+k-1)%n; int p2=(i+k)%n; if(p2==0) p2=n; f[i][j]=max(f[i][j],f[i][k]+f[p2][j-k]+add[i][j]); } } } for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i][n]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} P1063 [NOIP2006 提高组] 能量项链 Des 在\\(Mars\\)星球上，每个\\(Mars\\)人都随身佩带着一串能量项链。在项链上有\\(N\\)颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是\\(Mars\\)人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为\\(m\\)，尾标记为\\(r\\)，后一颗能量珠的头标记为r，尾标记为\\(n\\)，则聚合后释放的能量为\\(m \\times r \\times n\\)（\\(Mars\\)单位），新产生的珠子的头标记为\\(m\\)，尾标记为\\(n\\)。 需要时，\\(Mars\\)人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设\\(N=4\\)，\\(4\\)颗珠子的头标记与尾标记依次为\\((2,3) (3,5) (5,10) (10,2)\\)。我们用记号⊕表示两颗珠子的聚合操作，(\\(j\\)⊕\\(k\\))表示第\\(j,k\\)两颗珠子聚合后所释放的能量。则第\\(4\\)、\\(1\\)两颗珠子聚合后释放的能量为： (\\(4\\)⊕\\(1\\))\\(=10 \\times 2 \\times 3=60\\)。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为： ((\\(4\\)⊕\\(1\\))⊕\\(2\\))⊕\\(3\\)）=\\(10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710\\)。 Sol 和石子合并简直是一个模子里出来的,这次我换了变环为链的做法. My code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N=505;int n,a[N],hd[N],tl[N],f[N][N],ans;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;hd[i]; for(int i=1;i&lt;n;i++) tl[i]=hd[i+1]; tl[n]=hd[1]; for(int i=n+1;i&lt;n+n;i++) hd[i]=hd[i-n],tl[i]=tl[i-n]; for(int j=2;j&lt;=n;j++) { for(int i=1;i&lt;n+n;i++)//注意到2n-1 { int r=i+j-1; for(int k=i;k&lt;r;k++) { f[i][r]=max(f[i][r],f[i][k]+f[k+1][r]+hd[i]*hd[k+1]*tl[r]); } } } for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i][i+n-1]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Note 初始化数据的部分我写得不太简洁,但我觉得在不是核心步骤的地方浪费脑力写得简洁没有用,不如把代码写得清晰易懂一点,间接加强鲁棒性. P3146 [USACO16OPEN]248 G Des 给定一个1*n的地图，在里面玩2048，每次可以合并相邻两个（数值范围1-40），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是+1，例如2与2合并后的数值为3。 Sol 说句实话,这道题没做出来,以后做出来了再写.我的程序有一个点WA了,AC的记录是特判直接输出正解的.对于这道题的数据增强版,则有6个点WA了,暂时推测全是因为一个bug.","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】图的连通性问题","text":"本文参考: https://byvoid.com/zhs/blog/scc-tarjan/ https://oi-wiki.org/graph/bcc/ https://www.cnblogs.com/justPassBy/p/4678192.html 求强连通分量 强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图。 Tarjan 算法 有向图的 DFS 生成树 scc1.png 有向图的DFS生成树有4种边 树枝边(图中绿色):每次从一个访问过的节点到一个未访问过的节点,就形成了树枝边(也就是最后生成树上的边). 返祖边(图中黄色):指向已经访问过的节点,且是祖先节点的边. 横叉边(图中红色):指向已经访问过的节点,但不是祖先节点的边. 前向边(图中蓝色):指向子树节点的边. Tarjan 算法求强连通分量解析 Tarjan 算法利用深度优先搜索,和 DFS 生成树并无直接练习.但介绍 DFS 生成树中的概念有利于讲解 Tarjan 算法. 定义:DFN(u) 为搜索到 u 节点的时间戳,Low(u) 为 u 节点或 u 的子树上的节点通过最多一条前向边或返祖边到达的节点的最小的 DFN(u).当 Low(u) = DFN(u) 时,以 u 为根的搜索子树上的所有节点是一个强连通分量. 由于采用深度优先搜索,可以用栈记录搜索子树. 根据定义,我们可以得出: 123456Low(u)=min{ DFN(u), Low(v),//(u,v)为树枝边,u是v的父节点 DFN(v);//(u,v)为前向边或返祖边} 然后就是图解过程. 首先依 DFS 序搜索,搜到 6 号节点,没有树枝边,前向边,返祖边.Low(6) = DFN(6) = 4,弹出栈中元素直到 6 号节点出栈(实际上也只能弹出 1 个元素,就是 6 号节点).已经弹出的元素即为一个强连通分量.然后回溯. 5 号节点也没有前向边或返祖边,Low(5) = min (Low(6),DFN(5)) = 3.执行输出强连通分量操作,然后回溯. 正常搜索到 4 号节点.有返祖边指向 1 号节点,Low(4) = min(DFN(1),DFN(4)) = 1.然后回溯到 3 号节点,Low(3) = min(DFN(3),Low(4)) = 1. 搜索到 2 号节点,有前向边指向 4 号节点,Low(2) = min(DFN(2),DFN(4)) = 5.然后回溯. 回溯到1号节点,发现 DFN(1) = Low(1),执行输出强连通分量操作(这次可以弹出4个). 至此,所有节点已搜索完. 其实,Tarjan 算法至始至终都在完成一件事:判断当前节点能否与 已经判断连通的节点 连通.对于所有搜索时间戳小于 DFN(u) ,且不在栈中的节点,它们组成了一个强连通子图.如果 u 节点能够到达之前的任意一个节点,那它就可以加入这个强连通子图了. 所谓\"连通\"只需要从时间戳靠前的点到达时间戳靠后的点,而强连通则需要互相到达.从这个角度看, Tarjan 算法其实很质朴.但同时,DFN 和 Low 的思想也极其美妙. Tarjan 算法的时间复杂度 不难发现,每个节点和每条边恰好经过一次.时间复杂度为\\(O(n+m)\\). Tarjan 算法的实现 例题:P3387 【模板】缩点 由于强连通分量内任意2个点互相可达.到达了一个强连通分量内的任意1个点,强连通分量内的所有点都可以产生贡献,并且最后可以从任意一个点出去.那么可以将一个强连通分量看作一个点,入边集为原来所有点的入边(且源点不是强连通分量内的点)的并,出边集同理.该点的权值为所有点的权值和. 使用 Tarjan 算法求出所有强连通分量.给每个节点记录上所在强连通分量的序号,并完成记录权值,入边,出边的操作. 新建的图是 DAG,进行动态规划即可(参考算法竞赛入门经典). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*- 答案最大1e7,用int - 输入1e5,不用快读 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=1e5+5; int n,m,ans;int pointVal[N];vector&lt;int&gt; g1[N],g2[N]; int dfn[N],low[N],scc[N],sccVal[N],idx,tot; bool ins[N];stack&lt;int&gt; s;void tarjan(int u){ dfn[u]=low[u]=++idx; s.push(u),ins[u]=true; int len=g1[u].size(); for(int i=0;i&lt;len;i++) { int v=g1[u][i]; if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { ++tot; int top; do { top=s.top(); scc[top]=tot,sccVal[tot]+=pointVal[top],ins[top]=false; s.pop(); }while(top!=u); }}int vis[N],f[N];int dp(int u){ if(f[u]&gt;0) return f[u]; f[u]=sccVal[u]; int len=g2[u].size(); for(int i=0;i&lt;len;i++) { f[u]=max(f[u],sccVal[u]+dp(g2[u][i])); } return f[u];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;pointVal[i]); } for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); g1[u].push_back(v); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) tarjan(i); } for(int i=1;i&lt;=n;i++) { int len=g1[i].size(),u=scc[i]; for(int j=0;j&lt;len;j++) { int v=scc[g1[i][j]]; if(u!=v) g2[u].push_back(v); } } for(int i=1;i&lt;=tot;i++) { ans=max(ans,dp(i)); } printf(&quot;%d\\n&quot;,ans); return 0;} 其实之前我在补图论基础的时候就做过 DAG DP 问题,但写的实在是惨不忍睹...... kosaraju 算法 kosaraju 前置知识: DFS 记录访问节点的顺序. 前序排列. 在访问节点前将节点加入队列. 后序排列. 在访问节点后将节点加入队列. 逆后序排列. 在访问节点后将节点压入栈. kosaraju算法描述: 先对图进行 DFS ,得到每个节点的逆后序排列的标号(reversPost).按照reversePost从大到小的顺序对原图的逆图进行 DFS 搜索.每次搜索得到的子图就是一个强连通分量. 点双连通分量 无向点双连通图指不存在割点的无向连通图,无向图的极大点双连通子图称为点双连通分量(v-DCC,vertex double connected component). 点双连通图满足以下两个条件中的一个: 点数不超过2 任意2点包含在一个简单图中. 点双连通分量的求解与缩点 一个割点可能属于多个 v-DCC. 在满足割点判定法则后,将栈中元素出栈,与割点共同形成一个 v-DCC(割点不出栈). 将所有割点和所有点双连通分量看作新图中的点,并把每个割点和包含它的 v-DCC 连边,就完成了 v-DCC 的缩点.缩点后的图是一棵树(或森林). 边双连通分量 无向边双连通图指不存在割割边的无向连通图,无向图的极大边双连通子图称为边双连通分量(e-DCC,edge double connected component). 边双连通图满足条件: 任意一条边被包含在一个简单环中. 边双连通分量的求解与缩点 求解边双连通分量需要先找出割边,然后将割边删除.用 DFS 求连通块,每个连通块就是一个边双连通分量.缩点方法与强连通分量缩点类似.缩点后的图是一棵树(或森林). 有向图向强连通图的转化 1. 原有向图是连通图 其实就是P2746 [USACO5.3]校园网Network of Schools. 将连通图中的强联通分量缩点.统计缩点后入度为0,出度为0的点的个数.连边数量取max(in0,out0). 2. 原有向图是非连通图 对每个连通子图进行上面的处理.再把处理好的强联通分量串成一条链.设强联通分量的数量为\\(n\\),则连边树为\\(2\\times (n-1)\\). 无向图向 v-DCC, e-DCC 的转化 1.原无向图是连通图 已知把 v-DCC 或 e-DCC 缩点后整张图变成了一棵树.设树的叶子节点数量为\\(x\\),那么在叶子节点间的连边数量为\\(\\lfloor (x+1)/2\\rfloor\\)(比如,a 向 b 连,c 向 d连).可以归纳证明这样连边是正确的.而且连边数应该就是最少的. 2. 原无向图是非连通图 对每个连通子图进行上面的处理.再把处理好的双联通分量串成一条链.设强联通分量的数量为\\(n\\),则连边树为\\(2\\times (n-1)\\). 例题 P2860 [USACO06JAN]Redundant Paths G Des 为了从F(1≤F≤5000)个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择． 每对草场之间已经有至少一条路径．给出所有R(F-1≤R≤10000)条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量, 路径由若干道路首尾相连而成．两条路径相互分离，是指两条路径没有一条重合的道路．但是，两条分离的路径上可以有一些相同的草场． 对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路． Sol 即无向图转 e-DCC . My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5005,M=10005;int n,m,size=1;//size从2开始 int first[N],out[N];struct node{ int v,next;}edge[M];void addEdge(int u,int v){ edge[++size].v=v; edge[size].next=first[u]; first[u]=size;}int idx;int dfn[N],low[N],cut[M];void tarjan(int u,int fa){ dfn[u]=low[u]=++idx; for(int i=first[u];i;i=edge[i].next) { int v=edge[i].v; if(v==fa) continue; if(!dfn[v]) { tarjan(v,u); low[u]=min(low[u],low[v]); if(dfn[u]&lt;low[v]) cut[i]=cut[i^1]=true; } else low[u]=min(low[u],dfn[v]); }} int vis[N],dccCnt,dcc[N];void dfs(int u){ vis[u]=true; dcc[u]=dccCnt; for(int i=first[u];i;i=edge[i].next) { int v=edge[i].v; if(!vis[v] &amp;&amp; cut[i]==false) dfs(v); }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addEdge(u,v); addEdge(v,u); } tarjan(1,0);//已经是连通图 for(int i=1;i&lt;=n;i++) { if(!vis[i]) { dccCnt++; dfs(i); } } for(int i=1;i&lt;=n;i++) { for(int j=first[i];j;j=edge[j].next) { if(dcc[i]!=dcc[edge[j].v]) out[dcc[i]]++; //一定要判断是否属于同一个连通块! } } int leaf=0; for(int i=1;i&lt;=dccCnt;i++) { if(out[i]==1) leaf++; } if(dccCnt&lt;=2) printf(&quot;0\\n&quot;);//e-DCC 判定法则 else printf(&quot;%d\\n&quot;,(leaf+1)/2); return 0;} Note 这种可用异或求反向边的邻接表,size 一定要从2开始,否则会造成数值混淆. 不能用vector了TAT 记录 DCC 的出度时要记得判断2个点是否在同一个 DCC !","link":"/2021/03/16/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"title":"【专题】埃氏素数筛法(Eratosthenes)","text":"埃氏筛法: 对于每一个小于n的非负整数p,删去2p,3p,4p......,当处理完所有数后,还没有删除的就是素数. 想法:用a记录素数表,a[i]=1表示不是素数,a[i]=0表示是素数. #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int n,m,a[10000005],t; int main() { a[1]=1; cin&gt;&gt;n&gt;&gt;m; int pd=sqrt(n+0.5); for(int i=2;i&lt;=pd;i++) if(!a[i]) for(int j=i*i;j&lt;=n;j+=i) a[j]=1; // for(int i=1;i&lt;=100;i++) // cout&lt;&lt;a[i]&lt;&lt;endl; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;t; if(a[t]==0) cout&lt;&lt;\"Yes\\n\"; else cout&lt;&lt;\"No\\n\"; } return 0; } 注意:1不是素数,需要特判!","link":"/2019/10/20/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%9F%83%E6%B0%8F%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95(Eratosthenes)/"},{"title":"【专题】字符串匹配(KMP+普通算法)","text":"字符串匹配 定义母串为S,子串为T,在S中寻找到T,即为字符串匹配 普通匹配算法 12345678910k=0;for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;t.length();j++) { if(s[k]==t[j]) continue; else cout&lt;&lt;&quot;Fail&quot;,break; } k=i-j+2//此处最重要} 假设t串长度为5,第一次循环后k也为5","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D(KMP+%E6%99%AE%E9%80%9A%E7%AE%97%E6%B3%95)/"},{"title":"【专题】字典树(Trie)","text":"字典树用于解决 有多个长度短的字符串的问题 异或问题.本文包含了几道简单题. 前言: 字典树用于解决 有多个长度短的字符串的问题 异或问题 #2122 【模板】电话簿 处理每个电话号码时要输出NO有2种情况,一是某个已经处理的电话号码是它的前缀,二是它是某个已处理的电话号码的前缀,2种情况分别处理即可,注意trie[0]也需要清零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int t,n,trie[maxn][30],end[maxn],size;char str[15];bool insert(int v){ int now=0; for(int i=0;str[i]!='\\0';i++) { if(end[now]) return false; int son=str[i]-48; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=v; for(int i=0;i&lt;=9;i++) if(trie[now][i]) return false; return true;}void empty(){ memset(end,0,sizeof(end)); size=0; memset(trie[0],0,sizeof(trie[0]));}int main(){ cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; bool flag=false; for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;,str); if(insert(1)==false) { flag=true; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); empty(); } return 0;} #2204 秘密消息 与第一题类似,若密码可以匹配信息,有2种情况,一是信息是密码的前缀,二是密码是信息的前缀.且此题需要统计个数,则建立2个数组tot和end.tot统计当前节点向下有多少个单词,用于计算是密码是信息前缀的信息数量;end统计在当前节点有多少个单词结束,用于计算信息是密码前缀的信息数量. 将密码在字典树中匹配,将沿途的tot累加为ans,若密码长度大于可匹配长度,则ans可直接输出.若密码长度小于可匹配长度,则输出ans-end[now]+tot[now],即加上密码是信息前缀的信息数量(+tot[now),因为在now节点结束的信息对tot有贡献,需减去(-end[now]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,m,len,trie[maxn][30],tot[maxn],end[maxn],size;int key[maxn],info[maxn];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-') s=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s*x;}void insert(int v,int len){ int now=0; for(int i=1;i&lt;=len;i++) { int son=key[i]; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); trie[now][son]=size; } now=trie[now][son]; tot[now]++; } end[now]++;}int query(int len){ int now=0,ans=0; bool flag=false; for(int i=1;i&lt;=len;i++) { if(trie[now][info[i]]==0) { flag=true; break; } now=trie[now][info[i]]; ans+=end[now]; } if(flag==false) return ans-end[now]+tot[now]; else return ans; }int main(){ m=read(); n=read(); for(int i=1;i&lt;=m;i++) { len=read(); for(int j=1;j&lt;=len;j++) { key[j]=read(); } insert(1,len); } for(int i=1;i&lt;=n;i++) { len=read(); for(int j=1;j&lt;=len;j++) { info[j]=read(); } printf(&quot;%d\\n&quot;,query(len)); } return 0;} #3827 The XOR Largest Pair 将每个数按照二进制存进字典树,从最高位按\"先走不同,再走相同\"的贪心规则向下走. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*将每个数转为2进制,从高位开始建立trie树,按照贪心原则向下走,同时记录走过位数,最后还原 */#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,t,ans,trie[maxn][30],end[maxn],size;int pow_2[35];int to2(int x,int *a){ int p=-1; while(x) { a[++p]=x%2; x/=2; } return p;}int insert(int *a,int len){ int now=0,ret=0,xor_now=0; for(int i=30;i&gt;=0;i--)//共31位,最大是2^31-1,满足题目要求 { int son=a[i]; //下方操作只有在操作第一个数时不安全 if(trie[xor_now][!son])//和当前位相反的数是否有 { ret+=pow_2[i]; xor_now=trie[xor_now][!son]; } else { xor_now=trie[xor_now][son]; } if(trie[now][son]==0) { ++size; end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=1; return ret; }int main(){ //初始化打表 pow_2[0]=1; for(int i=1;i&lt;=30;i++) { pow_2[i]=pow_2[i-1]*2; } cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;t; int t_2[35]; memset(t_2,0,sizeof(t_2)); int now_ans=insert(t_2,to2(t,t_2)); if(now_ans&gt;ans &amp;&amp; i!=1) ans=now_ans; } cout&lt;&lt;ans; return 0;} 总结: 字典树大部分题目的核心操作是在添加单词时进行的,正确性涉及到字典树的特殊结构(添加一个单词,若与前面添加的单词有关系,则在此时就会被处理;若与后面添加的单词有关系,会在后面被处理). 字典树可很好的解决前缀/后缀问题 字典树可解决部分关于位运算操作的问题(将数转为01串,建立0-1 trie)","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E5%85%B8%E6%A0%91(Trie)/"},{"title":"【专题】字符串哈希(入门)","text":"前言: 本文介绍了字符串哈希,并带有几道入门题目. 字符串哈希 什么是字符串哈希 字符串哈希与一个数字建立对应关系,用于字符串的判重,效验. 在字符串哈希的过程中,如果字符串太长,可能出现多个字符串对应同一个数的情况,称作哈希冲突.为了避免哈希冲突,需要选择合适的模数与基数(通常为质数). 基础做法 实现方法:hash[i]=(hash[i-1]*base+s[i])%p 这里的base被称为基数,p被称为模数. 在这个过程中,hash[i]可能会超int范围,因此一般将其的数据类型设置为long long. 进阶做法 自然溢出法: 将hash[i]的设置类型设置为unsigned long long,利用无符号类型的自然溢出规则,省去%p的过程. 双哈希: 对一个字符串用2对不同的模数与基数操作,得到hash[1],hash[2].&lt;hash[1],hash[2]&gt;便是最终的哈希值. 防止生成数据卡哈希/哈希冲突 自然溢出法的模数(18446744073709551615)虽然不是质数,但够大,因此选用自然溢出法. 双哈希,冲突率可看作单哈希冲突率的平方. 随机base法 来自https://www.luogu.com.cn/problem/solution/P4503中lyyi03的题解. 设\\(pw_i=base^i\\)，则传统哈希的哈希值\\(hash=\\sum pw_i*s[i]\\)，但我这里的哈希是将\\(pw_i\\)换成一个long long范围内的随机数，这样就可以防卡哈希了． 题目 P3370 【模板】字符串哈希 My code: 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=1e4+5,mod=1e9+7,base=131;int n,ans;ll a[N];string s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; int len=s.length(); for(int j=0;j&lt;len;j++) { a[i]=(a[i]*base+(ll)s[j])%mod; } } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]==a[i+1]) ans++; } cout&lt;&lt;n-ans; return 0;} P4305 [JLOI2011]不重复数字 HINT: 使用vector判重 My code: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n,hash_num=50021,t,temp;vector&lt;int&gt; a[50022];int main(){ ios::sync_with_stdio(false); //快速读入 cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; memset(a,0,sizeof(a));//重置hash表 for(int j=1;j&lt;=n;j++) { cin&gt;&gt;temp;//输入当前数据 int hash=temp%hash_num;//hash过程 bool pd=false; if(a[hash].empty()==false) { for(int k=0;k&lt;a[hash].size();k++) { if(a[hash][k]==temp)//判断hash表中是否有当前元素 pd=true; } } else if(pd==false) { a[hash].push_back(temp);//如果hash表中没有,加入hash表并输出 printf(&quot;%d &quot;,temp); } } printf(&quot;\\n&quot;); }} P4503 [CTSC2014]企鹅QQ HINT: 不得不说hzwer的代码真是太强了,就借鉴了一下. 在他的代码中,使用了自然溢出法,并有类似双哈希的方法防止被卡. Bugs: #define ll unsigned long long后误打了分号 B1和B2过小(三十几),被hack掉了3个点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;const int N=3e4+5,B1=149,B2=137;int n,l,s,ans;ll H1[N][205],H2[N][205],t[N];char qq[205];void cal(int x){ for(int i=1;i&lt;=l;i++) H1[x][i]=H1[x][i-1]*B1+qq[i]; for(int i=l;i&gt;=1;i--) H2[x][i]=H2[x][i+1]*B2+qq[i];}int main(){ cin&gt;&gt;n&gt;&gt;l&gt;&gt;s; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,qq+1); cal(i); } for(int i=1;i&lt;=l;i++) { for(int j=1;j&lt;=n;j++) { t[j]=H1[j][i-1]*233+H2[j][i+1]*213; } sort(t+1,t+n+1); int now=1; for(int j=1;j&lt;n;j++) { if(t[j]!=t[j+1]) now=1; else { ans+=now; now++; } } } printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】并查集(入门)","text":"前言: 本文介绍了并查集及其优化(启发式合并和路径压缩),并提供了几道入门题目. 并查集 什么是并查集 并查集用于查询和合并多组关系,最常见的例子就是处理家族关系问题,需要查找成员关系和合并家族.并查集需要提供合并和查找操作. 简单实现 初始化 建立father[n]数组将father[i]初始化为i 查找操作 12345int find(int x){ if(father[x]==x) return x; else return find(father[x]);} 合并操作 12345void merge(int x,int y){ x=find(x),y=find(y); fa[x]=y;} 算法优化 路径压缩算法 用于优化并查集查找操作的时间复杂度 一个例子,若a,b,c,d满足这样的关系:a&lt;-b&lt;-c&lt;-d,&lt;-箭头表示左边的是右边的父亲.那么在每次find(d)的过程中将会经历4次递归.每次我们都找到了d的祖先是a,但没有将这个关系记录下来.由于只需要查找一个元素的祖先,将father[d]设为a也未尝不可.将查找路径上的每个节点直接连接到根上,这就是路径压缩算法.如下面的代码. 12345int find(x){ if(father[x]!=x) father[x]=find(father[x]);//if中的条件用于处理根节点,后面的语句包含了递归和优化的操作 return father[x];} 启发式合并(按秩合并) 用于优化并查集合并操作的时间复杂度 滑稽村庄和阴险村庄要被拆迁了,政府告诉它们两个村庄拆迁二选一.由于滑稽村庄的人数远大于阴险村庄,两村的村长协商后,决定让阴险村庄的居民暂时在滑稽村庄居住. 你已经发现了,对于两组关系的合并来说,数量少的合并到数量大的似乎要方便些.事实上在并查集的操作中也是这样的.我们便有了算法: 123456789int father[n],size[n];//初始化时新增了size数组void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];//不需要处理size[x]} 这种受到人类经验启发的算法称作启发式算法. 时间复杂度 路径压缩 启发式合并 时间复杂度 批注 × √ \\(O(m\\ log\\ n)\\) 最坏 √ × \\(O(m\\ log_{1+m/n}\\ n)\\),\\(O(m\\alpha (m,n))\\) 最坏,平均 √ √ \\(O(m\\alpha(m,n))\\) 最坏 其中,m表示find操作次数,n表示合并操作次数.\\(\\alpha()\\)函数为Ackermann函数的反函数,在OI中你可以认为是一个小于4的常数. 对于一般的题,使用路径压缩和启发式合并即可.有些题目不能使用路径压缩,因此学习启发式合并还是很有必要的. 题目 P3367 【模板】并查集 - 洛谷 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,z,x,y,father[10005],size[10005];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];} int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { father[i]=i,size[i]=1; } for(int i=1;i&lt;=m;i++) { z=read(),x=read(),y=read(); if(z==1) merge(x,y); else { x=find(x),y=find(y); if(x==y) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } } return 0;} P2758 村村通 Sol 将有公路连接的两个城市合并,最后输出连通块个数. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int INF=1e9,N=1e3+5;int n,m,fa[N],size[N],num;int find(int x){ if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];}void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; num--; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; fa[x]=y;}int main(){ while(cin&gt;&gt;n&amp;&amp;n) { cin&gt;&gt;m; for(int i=1;i&lt;=n;i++) { fa[i]=i; size[i]=1; } num=n; for(int i=1;i&lt;=m;i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; merge(x,y); } cout&lt;&lt;num-1&lt;&lt;endl; } return 0;} P1111 修复公路 - 洛谷 Sol 初始化num为n,代表现存集合个数.显然若只存在一个集合,所有村庄都可通车. 在merge时,如果x和y所在集合不同,将num--.直到num=1时输出t. Note 到这道题才发现之前的板子有点问题...在merge时如果x和y已经在同一个集合了,就不用合并. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005,M=1e5+5;int n,m,father[N],size[N],num;//num表示现存集合个数 struct relation{ int x,y,t; bool operator &lt; (const relation &amp;b) const //如果要结构体排序,也可使用这种方法,注意是重载小于运算符 { if(t&lt;b.t) return true; else return false; }}a[M];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x]; }void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; num--; father[x]=y;}int main(){ n=read(),m=read(); num=n; for(int i=1;i&lt;=n;i++) father[i]=i,size[i]=1; for(int i=1;i&lt;=m;i++) { a[i].x=read(),a[i].y=read(),a[i].t=read(); } sort(a+1,a+m+1); for(int i=1;i&lt;=m;i++) { merge(a[i].x,a[i].y); if(num==1) { printf(&quot;%d\\n&quot;,a[i].t); return 0; } } printf(&quot;-1\\n&quot;); return 0;} [P3958 NOIP2017 提高组] 奶酪 - 洛谷 Sol 首先判断2个球的位置的方法很容易推出来,如果(dist(a,b)&lt;=2r),那么2个球相交或相切. 暴力两两判断球是否连通,若连通则合并,最后判断每个集合是否能到达顶和底即可.时间复杂度复杂度为\\(O(Tn^2\\alpha (n))\\). Note 点坐标的绝对值不超过\\(10^9\\)计算2点距离过程会爆int. 12345double dist(int x,int y){ int m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z;//应把int改为long long return sqrt(m1*m1+m2*m2+m3*m3);} 另外,dist(i,j)&lt;=2*r涉及到了隐式转换,复习一下(来自cnblogs) C语言自动转换不同类型的行为称之为隐式类型转换 ，转换的基本原则是：低精度类型向高精度类型转换，具体是： int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; long long -&gt; unsigned long long -&gt; float -&gt; double -&gt; long double 也就是说,long long类型和double比较,long long会被提升至double My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define R registerusing namespace std;const int N=1005;int t,n,h,r,father[N],size[N];bool top[N],flo[N],flag[N][2];struct ball{ int x,y,z;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } double dist(int x,int y){ long long m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z; return sqrt(m1*m1+m2*m2+m3*m3);}int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y;}int main(){ t=read(); for(R int i=1;i&lt;=t;i++) { n=read(),h=read(),r=read(); memset(top,0,sizeof(top)); memset(flo,0,sizeof(flo)); for(R int j=1;j&lt;=n;j++) { father[j]=j;size[j]=1; a[j].x=read(),a[j].y=read(),a[j].z=read(); if(a[j].z+r&gt;=h) top[j]=true;//判断元素是否通顶 if(a[j].z-r&lt;=0) flo[j]=true;//判断元素是否通底 } for(R int j=1;j&lt;=n;j++) { for(R int k=j+1;k&lt;=n;k++) { if(dist(j,k)&lt;=2*r) { merge(j,k); } } } memset(flag,0,sizeof flag); for(R int j=1;j&lt;=n;j++) { int fa=find(j); if(top[j]) flag[fa][0]=true; if(flo[j]) flag[fa][1]=true; } bool yes=false; for(R int j=1;j&lt;=n;j++) { if(flag[j][0]&amp;&amp;flag[j][1]) { printf(&quot;Yes\\n&quot;); yes=true; break; } } if(!yes) printf(&quot;No\\n&quot;); } return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】快速幂(含矩阵快速幂)","text":"本文介绍了快速幂与矩阵快速幂,并实现了简单运用. 前言: 矩阵快速幂就是缝合怪 快速幂 这篇文章写的真心好啊,%%%.其实在理解其它的算法时,用纸笔推导每一步在干什么,也能达到差不多的理解程度,所以一定要耐心. 首先给一个幂运算: a p a^p ap 在代码实现中,实现p次方的复杂度为 O ( p ) O(p) O(p).我们考虑缩减指数,若p是偶数,则 a p = ( a ∗ a ) p 2 a^p=(a*a)^{\\frac p 2} ap=(a∗a)2p​.只进行了一次乘法运算,却将指数缩减到了原来的二分之一(这也是为什么快速幂的复杂度是 l o g n log\\ n logn). 有了想法,我们再看能不能实现.由唯一分解定理得:整数 m = ∏ a i p i = ∏ a i 2 k + n = ∏ ( a i 2 k ) 1 ( a i n ) 1 m=\\prod a_i^{p_i}=\\prod a_i^{2k+n}=\\prod (a_i^{2k})^1(a_i^{n})^1 m=∏aipi​​=∏ai2k+n​=∏(ai2k​)1(ain​)1,也就是说,m可分解为若干个幂次为1的数的乘积(好像是废话),那么,在缩减指数的时候,若 p m o d 2 = = 1 p\\ mod \\ 2==1 pmod2==1,ans*=a即可. 初步代码： 123456789101112131415ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;1) { if(p%2==1) { ans=(ans*a)%mod; } p/=2; a=(a*a)%mod; } ans=(ans*a)%mod; return ans;} 优化代码: 1234567891011ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;=1) { if(p&amp;1) (ans*=a)%=mod; p&gt;&gt;=1; (a*=a)%=mod; } return ans%mod;} 分析while循环,每次做的事为p&gt;&gt;=1和(a*=a)%=mod,结束条件为p&gt;=1,可将其改写为for循环节省行数 1234567ll fpm(ll a,ll p,ll mod){ ll ans=1; for(;p;p&gt;&gt;=1,(a*=a)%=mod) if(p&amp;1) (ans*=a)%=mod; return ans%mod;} 注意(a*=a)%=mod)是在if(p&amp;1) (ans*=a)%=mod;后执行的. 矩阵快速幂 矩阵乘法已经在线性代数中提到了.顾名思义,矩阵快速幂用于解决诸如 A p A^p Ap的问题,为什么会用到一个矩阵的幂呢?我们先来回顾斐波那契数列 f n = f n − 1 + f n − 2 f_n=f_{n-1}+f_{n-2} fn​=fn−1​+fn−2​,这个简单的递推式在数据规模为1e7时能轻松通过,但到了1e8便很危险了.这时候矩阵便派上用场了. 斐波那契数列的第n项有通项公式 F n = ( 5 + 1 2 ) n − ( 5 − 1 2 ) n 5 F_n= \\frac {(\\frac {\\sqrt{5}+1} {2})^n-(\\frac{\\sqrt{5}-1}{2})^n } {\\sqrt 5} Fn​=5 ​(25 ​+1​)n−(25 ​−1​)n​,但对精度要求极高,不适用.但我们能不能构造一个类似的通项公式,只不过求出的是一个矩阵呢? 可能你会疑惑,为什么要求一个矩阵呢?请看 [ f n f n − 1 ] \\begin{bmatrix}f_n\\\\f_{n-1}\\end{bmatrix} [fn​fn−1​​],这是不是一个矩阵?求出的是不是斐波那契数列?这样,我们的矩阵、快速幂与递推便有机统一了.现在到了在做题时最有思维难度的部分:构造矩阵. 思考: [ f [ i ] f [ i − 1 ] ] = [ a b c d ] × [ f [ i − 1 ] f [ i − 2 ] ] \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}a&amp;b\\\\c&amp;d\\end{bmatrix}\\times\\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[ac​bd​]×[f[i−1]f[i−2]​] 第一个矩阵该填什么?首先它肯定是长这个样子的,也就是要找出a,b,c,d满足 a × f [ i − 1 ] + b × f [ i − 2 ] = f [ i ] a\\times f[i-1]+b\\times f[i-2]=f[i] a×f[i−1]+b×f[i−2]=f[i] c × f [ i − 1 ] + d × f [ i − 2 ] = f [ i − 1 ] c\\times f[i-1]+d\\times f[i-2]=f[i-1] c×f[i−1]+d×f[i−2]=f[i−1] c=1,d=2是显然的,a和b等于多少呢?但观察形式,它不就是最基本的斐波那契递推式吗? 于是就有了: f [ i ] = 1 × f [ i − 1 ] + 1 × f [ i − 2 ] (1) \\tag 1f[i]=1\\times f[i-1]+1\\times f[i-2] f[i]=1×f[i−1]+1×f[i−2](1) f [ i − 1 ] = 1 × f [ i − 1 ] + 0 × f [ i − 2 ] (2) \\tag 2f[i-1]=1\\times f[i-1]+0\\times f[i-2] f[i−1]=1×f[i−1]+0×f[i−2](2) 由(1)(2)发现式(3) [ f [ i ] f [ i − 1 ] ] = [ 1 1 1 0 ] × [ f [ i − 1 ] f [ i − 2 ] ] (3) \\tag 3 \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}\\times \\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[11​10​]×[f[i−1]f[i−2]​](3) ohhhhhhh!构造出来了!剩下的不就简单多了吗,根据式(3)归纳出式(4) [ f [ n + 1 ] f [ n ] ] = [ 1 1 1 0 ] n − 1 × [ f [ 2 ] f [ 1 ] ] (4) \\tag 4 \\begin{bmatrix}f[n+1]\\\\f[n]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}^{n-1}\\times \\begin{bmatrix}f[2]\\\\f[1]\\end{bmatrix} [f[n+1]f[n]​]=[11​10​]n−1×[f[2]f[1]​](4) 至此,我们已经完成了\"构造一个矩阵的通项公式\"的任务了,可以编写代码了. 接下来该考虑的事情是如何将矩阵乘法运算套入快速幂,在快速幂的求解中,即将 a p a^p ap拆分成若干个幂次为1的数的乘积,只用到了结合律,显然其对矩阵乘法的运算也是成立的.(其实在这里也满足交换律,毕竟全都是同一个矩阵A).那么我们直接将快速幂中涉及到乘法的部分换为矩阵乘法即可. 12345void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);} 封装了一个矩阵板子,支持乘法操作(我居然自己造了一个板子,太不可思议了) 123456789101112131415161718struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }}; P3390 【模板】矩阵快速幂 索然无味的AC代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);}int main(){ cin&gt;&gt;n&gt;&gt;k; matrix a; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;a.g[i][j]; } } matrix ans; //构造单位矩阵 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i==j) ans.g[i][j]=1; else ans.g[i][j]=0; } } fpm_mat(ans,a,k); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cout&lt;&lt;ans.g[i][j]&lt;&lt;' '; } cout&lt;&lt;endl; } return 0;} 这里涉及到一个叫做单位矩阵(identity matrix)的东西,就是主对角线上元素全为1的矩阵. I × A = A I\\times A=A I×A=A. 好了,回到我们的斐波那契数列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt() { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a,2,2)) if(p&amp;1) ans.mul(a,2,2);}int main(){ cin&gt;&gt;n; if(n==1) { cout&lt;&lt;1; return 0; } matrix a,idt; idt.idt(); a.g[1][1]=1,a.g[1][2]=1,a.g[2][1]=1,a.g[2][2]=0; fpm_mat(idt,a,n);//结果存在idt里 matrix f; f.g[1][1]=1,f.g[2][1]=1; idt.mul(f,2,1); cout&lt;&lt;idt.g[2][1]; return 0;} 代码虽然AC了,但是因为状态不好,写的极度糟糕. 改进了一下板子,增加了idt构造单位矩阵功能: 1234567891011121314151617181920212223242526struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt(int n) { for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};","link":"/2021/02/03/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82(%E5%90%AB%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82)/"},{"title":"【专题】快速读写相关","text":"快速读入 最基础版本，主要思想是一个一个读入 12345678910111213141516int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v1 这个版本很好理解,可以加上inline快一点 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v2 最后加上位运算以及手写isdigit函数 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if(c=='-') s=-s; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { a=(a&lt;&lt;1)+(a&lt;&lt;3)+(ch^48); c=getchar(); } return s*a;}//v3","link":"/2020/05/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/"},{"title":"【专题】扩展欧几里得算法(exgcd)","text":"前言：本文介绍了扩展欧几里德算法，并给出了算法模版 欧几里得算法 首先我们来回顾一下求解2个数的最大公约数(gcd,Greatest Common Divisor)的欧几里得算法: 这个算法的核心是\\(gcd(a,b)=gcd(b,a \\ mod \\ b)\\),即\\(a\\)和\\(b\\)的公约数等于\\(b\\)和\\(a \\ mod \\ b\\)的公约数. 至于为什么,oi-wiki上有,我们就不证了,但为了理解这个公式,我们举个例子 \\[ gcd(3,5)=gcd(5,3)=gcd(2,3)=gcd(3,2)=\\\\gcd(1,2)=gcd(2,1)=gcd(1,1)=gcd(0,1)=gcd(1,0) \\] 然后你会发现,我们将要用1去模0了,但这显然是没有意义的*(a模b的定义为a除以b的余数).并且,1和0是没有公约数的(0没有任何约数),那么我们的程序好像就无法继续进行了.我们又观察到,5和3因为互质,最大公约数是1,恰好是当b=0的时候a的值.那么,其他的数进行gcd操作也会有这样的性质吗? 再来个例子 \\[ gcd(4,2)=gcd(0,2)=gcd(2,0) \\] 好像确实是这样的!我们只需输出当b等于0时a的值即可! 实际上,当b=0时,就代表着前一步的a%b==0,也就是\\(b|a\\),那么我们的最大公约数显然就是b(下一步的a)了. *如果你编译运行1%0这段代码,编译器报错[Warning] division by zero [-Wdiv-by-zero],程序RE 这样就可以写出代码: 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); } 在进入下一部分前,我们先来分析一下这个算法的复杂度.细心的读者已经发现了,上面的例子中有些操作是无效的,他们仅仅交换了a和b的位置,但对于程序运行来说,这是必需的.但他们的数量显然小于等于有效操作的数量,对于时间复杂度的分析来说可以略去. 回顾到取模这个运算,在正数意义下它的代码可以写成这样(你是否知道负数的取模运算?可以参考这篇文章): 1while(a&gt;b) a-=b//=a%b 实际上,G++中实现的取模不是这么简单.具体来说,若\\(a=qb+r\\),则\\(a \\ mod \\ b=r\\)(例:7%(-3)=1 -7%(-3)=-1 -7%3=-1).并且,G++的原则是使商尽可能大 有点扯远了,最重要的是知道上面在正数意义下的代码!我们再来举几个例感性理解一下复杂度 不用感性理解了,请读者们自己思考吧,我直接说结论好了,gcd中的有效操作至少能让a减半. 那么,gcd的复杂度就为\\(log \\ n\\) 补充知识: 多个数的最大公约数/最小公倍数求法:每次取出2个数求得最大公约数/最小公倍数后将最大公约数/最小公倍数放回去 算数基本定理(用于求lcm,Least Common Multiple,最小公倍数):\\(gcd(a,b) \\times lcm(a,b)=a \\times b\\) 扩展欧几里德算法(exgcd) 恶心gcd 扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求\\(ax+by=gcd(a,b)\\)的一组可行解。 P.S 原来extra指额外,extend才是扩展... 定理:\\(x_1=y_2,y_1=x_2-\\lfloor \\frac a b \\rfloor\\) 证明(摘自oi-wiki,但手写一遍才能更好的弄懂): &gt;设 &gt; \\(ax_1+by_1=\\gcd(a,b)\\) &gt; \\(bx_2+(a\\bmod b)y_2=\\gcd(b,a\\bmod b)\\) &gt;由欧几里得定理可知： \\(\\gcd(a,b)=\\gcd(b,a\\bmod b)\\) &gt;所以 \\(ax_1+by_1=bx_2+(a\\bmod b)y_2\\) &gt;又因为 \\(a\\bmod b=a-(\\lfloor\\frac{a}{b}\\rfloor\\times b)\\) &gt;所以 \\(ax_1+by_1=bx_2+(a-(\\lfloor\\frac{a}{b}\\rfloor\\times b))y_2\\) &gt; \\(ax_1+by_1=ay_2+bx_2-\\lfloor\\frac{a}{b}\\rfloor\\times by_2=ay_2+b(x_2-\\lfloor\\frac{a}{b}\\rfloor y_2)\\) &gt;因为 \\(a=a,b=b\\) ，所以 \\(x_1=y_2,y_1=x_2-\\lfloor\\frac{a}{b}\\rfloor y_2\\) 证明中比较重要的就是这个式子(其实就是取模运算的数学表达式): \\[ a \\ mod \\ b=a-\\lfloor \\frac a b \\rfloor \\times b \\] 知道了\\(x\\)和\\(y\\)的递归表达式,我们就可以进行程序设计了. 既然是递归,就一定有最底层的\\(x\\)和\\(y\\)能够让我们轻易求出值,回到基础gcd算法的递归结束位置,\\(a_{now}=gcd(a,b),b_{now}=0\\),带入\\(ax+by=gcd(a,b)\\),得\\({gcd(a,b)} \\times x +0 \\times y=gcd(a,b)\\) 那么显然\\(x\\)取1,\\(y\\)取任意值即可(我们选择取0). 考虑到在源代码上修改,我们仍然返回gcd的值,在过程中计算x和y即可. 代码: 12345678910111213int exgcd(int a,int b,int &amp;x,int &amp;y){ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y); int temp=x; x=y; y=temp-(a/b)*y; return ret; }","link":"/2021/01/31/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95(exgcd)/"},{"title":"【专题】拉格朗日插值(入门)","text":"本文介绍了拉格朗日插值法,并给出了模版代码. 拉格朗日插值法可构造一个经过任意n个点的函数f \\(拉格朗日插值法可构造一个经过任意n个点(a_1,b_1),(a_2,b_2),(a_3,b_3),\\dots,(a_n,b_n)的函数f,设f=f_1+f_2+\\dots+f_n,需要让f_1,f_2,\\dots,f_n均经过这n个点,且当x=a_i时,f_i=b_i;当x=a_j(j \\ne i)时,f_i=0.\\) \\(那么显然,由f_1,f_2,\\dots,f_n相加得到的的f,恰好经过了a_1,a_2,\\dots,a_n.\\) \\(f_1,f_2,\\dots,f_n被称为拉格朗日基函数,表达式为:f_i=b_i\\prod_{j\\ne i} \\frac {x-x_j} {x_i-x_j}\\) \\(那么,由拉格朗日插值法得到的函数f的表达式为:\\sum_{i=1}^{n}b_i\\prod_{j\\ne i} \\frac{x-x_j} {x_i-x_j},时间复杂度为O(n^2).\\) \\(若在程序实现中,每一次计算x_i-x_j值时都求一次其的乘法逆元,时间复杂度将乘上log\\ n,我们选择先计算所有x_i-x_j的乘积,再求逆元.\\) 另外,此处求逆元必须选择快速幂方法,否则你将陷入深深的迷惑中.为什么呢?在此题中,可能会需要求负数的逆元,但根据辗转相除法求负数和-1的最大公约数时,求得的最大公约数为-1(在cmath库函数__gcd中计算也会得到-1,可见其运用的是辗转相除法).可是在数学定义上,gcd(a,b)=gcd(|a|,|b|),也就是说负数和-1的最大公约数为1.贝祖等式ax+by=gcd(a,b)的gcd(a,b)显然是数学定义上的.那么便不能得到ax+by=1,或者说我们算的其实是ax+by=-1,完全错误了.(我在这个问题上困扰了接近1个小时TAT) 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,k,x[2005],y[2005],mod=998244353,ans;//998244353是个题目常用取模质数 ll fpm(ll x,ll power,ll mod) { x %= mod; ll ans = 1; for (; power; power &gt;&gt;= 1,(x*=x)%=mod) if(power&amp;1) (ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x[i]&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++) { ll ans_up=y[i],ans_down=1; for(int j=1;j&lt;=n;j++) { if(j==i) continue; ans_up=(ans_up*(k-x[j]))%mod; ans_down=(ans_down*(x[i]-x[j]))%mod; } ans=(ans+(ans_up*inv(ans_down)))%mod; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0;}","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】拓扑排序","text":"拓扑排序 拓扑排序是指对一个DAG(有向无环图)进行一个线性排列.对于任何一个点对(u,v),即u到v有一条边,u在线性序列中必须比v先出现. 代码实现 Des 给任务排序 Sol 使用拓扑排序,邻接矩阵存储关系.输入完毕时统计一次入度,将入度为0的点加入队列中.然后将队列中的点依次删除(删点,删边,删相连的点得入度).在这个过程中也要将更新后入度为0的点加入队列中.直到队列中所有点输出后结束程序. My code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,m,u,v,g[N][N],in[N];queue&lt;int&gt; q;int main(){ while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; (n||m)) { memset(g,0,sizeof g); memset(in,0,sizeof in); while(!q.empty()) { q.pop(); } for(int i=1;i&lt;=m;i++) { cin&gt;&gt;u&gt;&gt;v; g[u][v]=true; in[v]++; } for(int i=1;i&lt;=n;i++) { if(in[i]==0) { q.push(i); in[i]=-1; } } while(!q.empty()) { int i=q.front(); q.pop(); printf(&quot;%d &quot;,i); for(int j=1;j&lt;=n;j++) { if(g[i][j]) { in[j]--; g[i][j]=false; if(in[j]==0) { in[j]=-1; q.push(j); } } } } cout&lt;&lt;endl; } return 0;} Note 这里因为把cin&gt;&gt;n&gt;&gt;m &amp;&amp; (n||m)写成cin&gt;&gt;n&gt;&gt;m &amp;&amp; &amp;&amp; n &amp;&amp; mWA了一次,也就是说m可能等于0.不得不说UVA的题真是严谨. 时间复杂度 设边数为e,点数为n.不难看出建边复杂度为\\(O(e)\\),第一次统计入度为0的点复杂度为\\(O(n)\\).每个点都会进入队列一次,并操作一次,还是\\(O(n)\\).如果用邻接矩阵存储数据(如上面的代码),每次遍历每个点相连的点需要\\(O(n)\\).合起来就是\\(O(n^2)\\)(当然,这是最坏情况).所以用邻接矩阵存储数据的拓扑排序算法的时间复杂度为\\(O(n^2+e)\\). 如果用邻接表存储,遍历每个点相连的点得复杂度之和为\\(O(e)\\),总复杂度为\\(O(n+e)\\).所以知道该用哪个了吧. 例题 P1983 [NOIP2013 普及组] 车站分级 Sol 从题意不难看出,对于一趟车次的运行情况,停靠站的等级大于未停靠站的等级.那么,建立DAG,边关系为(停靠站,未停靠站)即可.这样的时间复杂度为\\(O(n^2m)\\),在洛谷上能够通过.但理论复杂度超过限制的算法显然不是我们想要的. 我们将每个停靠站连向一个虚拟节点,再将虚拟节点连向每个未停靠站.这样,扩大了n的规模(最多2000),但时间复杂度为\\(O(nm)\\).比前面的方案更优. 另外,这道题由于题意的特殊性,不需要邻接矩阵存边. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt; using namespace std;const int N=1005;int n,m,s,stop[N],g[2005][2005],st,ed,in[2005],ans;int ne[N],p;//not_existinline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ n=read(),m=read(); for(int i=1;i&lt;=m;i++) { s=read(); memset(stop,0,sizeof stop); ++p; ne[p]=n+p; for(int j=1;j&lt;=s;j++) { int t=read(); stop[t]=true; if(j==1) st=t; if(j==s) ed=t; } for(int j=st;j&lt;=ed;j++) { if(stop[j]) { g[j][ne[p]]=true; in[ne[p]]++; } else { g[ne[p]][j]=true; in[j]++; } } } int cnt=n+p;//普通车站和虚拟节点的个数和 while(cnt!=0) { bool all_ne=true; for(int i=1;i&lt;=n+p;i++) { if(in[i]==0) { cnt--; for(int j=1;j&lt;=n+p;j++) { if(g[i][j]) { g[i][j]=0; in[j]--; } } in[i]=-1; if(i&lt;=n) all_ne=false; } } if(all_ne==false) ans++; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} P1038 [NOIP2003 提高组] 神经网络 Sol 按照拓扑排序的步骤一层一层的模拟.每一层的点都必须删,但是否激发就要按照题意进行了. My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N=105,INF=1e9+7;int n,p,u[N],f[N],s[N],in[N],c[N],ans[N],g[N][N];queue&lt;int&gt; q;int main(){ cin&gt;&gt;n&gt;&gt;p; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]&gt;&gt;u[i]; if(s[i]) { q.push(i); } fill(g[i],g[i]+N-1,INF); } int out,to; for(int i=1;i&lt;=p;i++) { cin&gt;&gt;out&gt;&gt;to; cin&gt;&gt;g[out][to]; in[to]++; } while(!q.empty()) { out=q.front(); q.pop(); if(s[out]==0) { c[out]=f[out]-u[out]; } else { c[out]=s[out]; } bool out_layer=true; for(int i=1;i&lt;=n;i++) { if(g[out][i]!=INF) { in[i]--; if(c[out]&gt;0) f[i]+=c[out]*g[out][i]; if(in[i]==0) { q.push(i); } out_layer=false; } } if(out_layer)//是否是输出层 { ans[out]=c[out]; } } bool all0=true; for(int i=1;i&lt;=n;i++) { if(ans[i]&gt;0) { cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ans[i]&lt;&lt;endl; all0=false; } } if(all0) cout&lt;&lt;&quot;NULL\\n&quot;; return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"【专题】数列分块","text":"资料: 「分块」数列分块入门1 – 9 by hzwer - 分块 - hzwer.com 均值不等式 - 知乎 (zhihu.com) 前置知识: 均值不等式 基本不等式的代数证明和几何证明 \\(\\cfrac {a_1+a_2+\\dots+a_n} n \\ge \\sqrt[n] {a_1+a_2+\\dots+a_n}\\). 复习一下: \\(2(a^2+b^2+c^2-ab-bc-ac)=(a-b)^2+(b-c)^2+(a-c)^2\\ge 0\\). 分块 分块感觉就是用 \\(\\sqrt n\\) 叉树实现的线段树, 所以很多题型都是线段树写过的. 那你会问: 我为什么要用这么一个复杂度高的算法呢? 正因为分块存储区间信息的节点数量少(只有 \\(\\sqrt n\\) 个,线段树是 \\(2+4+8+\\cdots\\)), 所以单节点维护起来方便. 可以在单节点内套上其他数据结构. hzwer 的分块九讲感觉难度排的不是很对...... 所以就按照我自己的喜好排了. 分块入门 1 by hzwer 区间加法, 单点求值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5; int n,SQN;int ans[N],tag[N],tot[N];void modify(int l,int r,int k) { while(l%SQN!=1) { ans[l++]+=k; if(l&gt;r) return; } while(r%SQN!=0) { ans[r--]+=k; if(l&gt;r) return; } for(;l&lt;=r;l+=SQN) { tag[l/SQN]+=k; }} int query(int l,int r) { int t=0; while(l%SQN!=1) { t+=ans[l]+tag[(l-1)/SQN]; ++l; if(l&gt;r) return t; } while(r%SQN!=0) { t+=ans[r]+tag[(r-1)/SQN]; --r; if(l&gt;r) return t; } for(;l&lt;=r;l+=SQN) { t+=tot[l/SQN]+tag[l/SQN]*SQN; } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;ans[i]); tot[i/SQN]+=ans[i]; } int opt,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;opt,&amp;l,&amp;r,&amp;c); if(opt) { printf(&quot;%d\\n&quot;,query(r,r)); } else { modify(l,r,c); } } return 0;} 分块入门 4 by hzwer 区间加, 区间询问. 不开 long long 见祖宗. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*tag表示区间都应加上的数a表示单点的值tot表示区间和对于区间,总和为 tot + tag*SQN对于单点,总和为 a + tag[] 对于加法操作,在区间上维护tag在单点上维护a和区间tot */#include &lt;bits/stdc++.h&gt; typedef long long ll;using namespace std;const int N=5e4+5;int n,SQN;ll a[N],tot[N],tag[N];void modify(int l,int r,ll c) { for(;l%SQN!=1;l++) { a[l]+=c; tot[(l-1)/SQN]+=c; if(l==r) return; } for(;r%SQN!=0;r--) { a[r]+=c; tot[(r-1)/SQN]+=c; if(l==r) return; } for(int i=l;i&lt;=r;i+=SQN) { tag[(i-1)/SQN]+=c; }}int query(int l,int r,int c) { ll t=0; for(;l%SQN!=1;l++) { t+=tag[(l-1)/SQN]+a[l]; t%=c; if(l==r) return t; } for(;r%SQN!=0;r--) { t+=tag[(r-1)/SQN]+a[r]; t%=c; if(l==r) return t; } for(int i=l;i&lt;=r;i+=SQN) { t+=tag[(i-1)/SQN]*SQN+tot[(i-1)/SQN]; t%=c; } return t;} int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;a[i]); tot[(i-1)/SQN]+=a[i]; } for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c+1)); } else { modify(l,r,c); } } return 0;} 分块入门 5 by hzwer 区间开方, 区间求和. 经典区间开方, 线段树也做过. 一个非零数连续开方变成 1 需要的开方次数其实很少. 所以在最开始的时候一个一个开方, 如果区间全部为 0 或 1 就跳过区间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,SQN;int a[N],tot[N],al0[N],bl[N];void modify(int l,int r) { bool ok=false; for(int i=l;i&lt;=r;i++) { tot[bl[i]]-=(a[i]-sqrt(a[i])); a[i]=sqrt(a[i]); if(i%SQN==1) { if(al0[bl[i]]) { i+=SQN-1; continue; } else ok=true; } if(a[i]!=1 &amp;&amp; a[i]!=0) ok=false; if(i%SQN==0 &amp;&amp; ok==true) { al0[bl[i]]=true; } }}int query(int l,int r) { int ans=0; for(;l%SQN!=1;l++) { ans+=a[l]; if(l==r) return ans; } for(;r%SQN!=0;r--) { ans+=a[r]; if(r==l) return ans; } for(;l&lt;=r;l+=SQN) { ans+=tot[bl[l]]; } return ans;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); bl[i]=(i-1)/SQN; tot[bl[i]]+=a[i]; } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op==0) { modify(l,r); } else if(op==1) { printf(&quot;%d\\n&quot;,query(l,r)); } } return 0;} P3870 [TJOI2009]开关 区间均为 0 或 1, 执行区间异或, 区间求和. 异或会修改整块的和, 但也就是 SQN-sum 和 sum 的区别. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1e5+5; int n,m,SQN;int ans[N],tag[N],tot[N];void modify(int l,int r) { while(l%SQN!=1) { tot[(l-1)/SQN]+=(ans[l]==0)?(1):(-1); ans[l++]^=1; if(l&gt;r) return; } while(r%SQN!=0) { tot[(r-1)/SQN]+=(ans[r]==0)?(1):(-1); ans[r--]^=1; if(l&gt;r) return; } for(;l&lt;=r;l+=SQN) { tag[l/SQN]^=1; }} int query(int l,int r) { int t=0; while(l%SQN!=1) { t+=ans[l]^tag[(l-1)/SQN]; ++l; if(l&gt;r) return t; } while(r%SQN!=0) { t+=ans[r]^tag[(r-1)/SQN]; --r; if(l&gt;r) return t; } for(;l&lt;=r;l+=SQN) { int id=l/SQN; t+=(tag[id]==1)?(SQN-tot[id]):tot[id]; } return t;}int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); SQN=sqrt(n); int opt,l,r; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;l,&amp;r); if(opt) { printf(&quot;%d\\n&quot;,query(l,r)); } else { modify(l,r); } } return 0;} 分块入门 2 by hzwer 区间加法, 区间求小于 k 的数 a数组存储排序好的数组, b数组表示原始数组, tag 存储在区间上的加法 对于加法操作: 在区间上修改 tag 在单点上修改原始数组, 并对修改过的散块重新排序 对于求小于的操作 在区间上二分排序好的数组, 但二分的值要减去 tag 在单点上判断是否 a[x]+tag[x]&lt;k . 这道题真的调了超久. 一开始我甚至没有 rebuild ,意识到后这一点后, rebuild 的情况也没考虑全. 我拿一个讨论区里的暴力踩标算的程序来对拍, 然后发现始终不对. 我真的是想不出哪里还有问题了, 就抱着侥幸心理交了一发, 没想到对了! 我能说我最开始不知道黄学长那篇博客下面是有标程的吗? 导致我一开始就没有用 vector 写. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,SQN;int a[N],b[N],tag[N];void rebuild(int id) { int st=max(1,id*SQN+1),ed=min((id+1)*SQN,n); for(int i=st;i&lt;=ed;i++) a[i]=b[i]; sort(a+st,a+ed+1);}void modify(int l,int r,int k) { int led=-1,rst=-1; for(;l%SQN!=1;l++) { b[l]+=k; if(l%SQN==0) led=l; if(l==r) { rebuild((l-1)/SQN); return; } } if(led!=-1) rebuild((led-1)/SQN); for(;r%SQN!=0;r--) { b[r]+=k; if(r%SQN==1) rst=r; if(r==l) { rebuild((r-1)/SQN); return; } } if(rst!=-1) rebuild((rst-1)/SQN); for(;l&lt;=r;l+=SQN) { tag[(l-1)/SQN]+=k; }}int query(int l,int r,int k) { int t=0; for(;l%SQN!=1;l++) { if(b[l]+tag[(l-1)/SQN]&lt;k) ++t; if(l==r) return t; } for(;r%SQN!=0;r--) { if(b[r]+tag[(r-1)/SQN]&lt;k) ++t; if(l==r) return t; } for(;l&lt;r;l+=SQN) { t+=lower_bound(a+l,a+l+SQN,k-tag[(l-1)/SQN])-a-l; } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); b[i]=a[i]; } for(int i=1;i&lt;=n;i+=SQN) { sort(a+i,min(a+n+1,a+i+SQN)); } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c*c)); } else { modify(l,r,c); } } return 0;} 分块入门 3 by hzwer 区间加, 区间求前驱 把上一题的代码改一改就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,SQN;int a[N],b[N],tag[N];void rebuild(int id) { int st=max(1,id*SQN+1),ed=min((id+1)*SQN,n); for(int i=st;i&lt;=ed;i++) a[i]=b[i]; sort(a+st,a+ed+1);}void modify(int l,int r,int k) { int led=-1,rst=-1; for(;l%SQN!=1;l++) { b[l]+=k; if(l%SQN==0) led=l; if(l==r) { rebuild((l-1)/SQN); return; } } if(led!=-1) rebuild((led-1)/SQN); for(;r%SQN!=0;r--) { b[r]+=k; if(r%SQN==1) rst=r; if(r==l) { rebuild((r-1)/SQN); return; } } if(rst!=-1) rebuild((rst-1)/SQN); for(;l&lt;=r;l+=SQN) { tag[(l-1)/SQN]+=k; }}int query(int l,int r,int k) { int t=-1; for(;l%SQN!=1;l++) { int rec=b[l]+tag[(l-1)/SQN]; if(rec&lt;k) t=max(t,rec); if(l==r) return t; } for(;r%SQN!=0;r--) { int rec=b[r]+tag[(r-1)/SQN]; if(rec&lt;k) t=max(t,rec); if(l==r) return t; } for(;l&lt;r;l+=SQN) { int id=lower_bound(a+l,a+min(l+SQN,n+1),k-tag[(l-1)/SQN])-a; if(id==l) continue; else t=max(t,a[id-1]+tag[(id-1)/SQN]); } return t;}int main() { scanf(&quot;%d&quot;,&amp;n); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); b[i]=a[i]; } for(int i=1;i&lt;=n;i+=SQN) { sort(a+i,min(a+n+1,a+i+SQN)); } int op,l,r,c; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;l,&amp;r,&amp;c); if(op) { printf(&quot;%d\\n&quot;,query(l,r,c)); } else { modify(l,r,c); } } return 0;} 分块入门 6 by hzwer 单点插入, 单点查询. 在块内插入, 可以把所有元素暴力向后移. 但如果块过大, 就得把一个块分裂开或者重新分块. 此处我选择第一种, 时间复杂度小. 下面的程序是 hzwer 标程用时的二分之一. 把块裂开, 实际上就是新建一个 vector ,然后改一下顺序访问用到的单向链表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,SQN,cnt;int nxt[N];vector&lt;int&gt; a[3000];void rebuild(int x) { vector&lt;int&gt; t=a[x]; a[x].clear(); int ed=t.size(),mid=ed/2; ++cnt; for(int i=0;i&lt;=mid;i++) a[x].push_back(t[i]); for(int i=mid+1;i&lt;ed;i++) a[cnt].push_back(t[i]); nxt[cnt]=nxt[x],nxt[x]=cnt;}void insert(int l,int k) { int p=0; for(int i=0;i!=-1;i=nxt[i]) { int len=a[i].size(); if(p+len&gt;=l) { a[i].push_back(*(a[i].end()-1)); for(int j=len-1;j&gt;l-p-1;j--) { a[i][j]=a[i][j-1]; } a[i][l-p-1]=k; if(a[i].size()&gt;(unsigned int)(10*SQN)) { rebuild(i); i=nxt[i]; } break; } else p+=len; }}int query(int x) { int p=0; for(int i=0;i!=-1;i=nxt[i]) { int len=a[i].size(); if(p+len&gt;=x) { return a[i][x-p-1]; } else p+=len; } return -1;}inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}int main() { n=read(); SQN=sqrt(n); cnt=-1; int op,l,r,c; for(int i=0;i&lt;=SQN;i++) a[i].reserve(300); for(int i=1;i&lt;=n;i++) { if(i%SQN==1) ++cnt; c=read(); a[cnt].push_back(c); } for(int i=0;i&lt;cnt;i++) nxt[i]=i+1; nxt[cnt]=-1; for(int i=1;i&lt;=n;i++) { op=read(),l=read(),r=read(),c=read(); if(op==0) insert(l,r); else printf(&quot;%d\\n&quot;,query(r)); } return 0;} 分块入门 7 by hzwer 区间加法, 区间乘法, 单点求值. 分别维护加法和乘法的 tag. 其实区间求值也可以, 但是较难写. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,P=10007;int n,SQN;int a[N],tagm[N],taga[N],bl[N];inline int read() { int s=1,x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0') {if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') {x=x*10+c-48;c=getchar();} return s?x:-x;}void reset(int x) { int st=x*SQN+1,ed=(x+1)*SQN; for(int i=max(1,st);i&lt;=min(n,ed);i++) a[i]=(a[i]*tagm[x]+taga[x])%P; tagm[x]=1,taga[x]=0;}void modify(int l,int r,int k,int op) { reset(bl[l]),reset(bl[r]); for(;l%SQN!=1;l++) { if(op==0) a[l]=(a[l]+k)%P; else a[l]=(a[l]*k)%P; if(l==r) return; } for(;r%SQN!=0;r--) { if(op==0) a[r]=(a[r]+k)%P; else a[r]=(a[r]*k)%P; if(l==r) return; } for(int i=bl[l];i&lt;=bl[r];i++) { if(op==0) taga[i]=(taga[i]+k)%P; else { taga[i]=(taga[i]*k)%P; tagm[i]=(tagm[i]*k)%P; } }}inline int query(int x) { return ((a[x]*tagm[bl[x]])+taga[bl[x]])%P;}int main() { n=read(); SQN=sqrt(n); for(int i=1;i&lt;=n;i++) { a[i]=read(); bl[i]=(i-1)/SQN; } for(int i=0;i&lt;=bl[n];i++) tagm[i]=1; int op,l,r,c; for(int i=1;i&lt;=n;i++) { op=read(),l=read(),r=read(),c=read(); if(op==2) { printf(&quot;%d\\n&quot;,query(r)); } else { modify(l,r,c,op); } } return 0;}","link":"/2021/04/13/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97/"},{"title":"【专题】最近公共祖先(LCA)&amp;树上差分","text":"LCA算法介绍 LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 本文下方的N为点个数,M为询问次数.u和v为被询问的2个节点编号. LCA算法实现 普通实现 如果询问LCA(u,v),分别从u和v开始向上遍历,直到遇到LCA. 时间复杂度\\(O(NM)\\). 倍增实现 不难发现,普通实现的时间主要耗费在向上遍历这个过程.有些点对的LCA离它们自己很远,一个一个的向上走实在太浪费时间.考虑任何一个整数都可以拆分成2的幂的和,如果能利用这个拆分,能将单次查询的时间复杂度优化到\\(O(\\log n)\\). 为了判断探测到的节点是不是LCA,我们可以先计算每个节点向上走\\(2^k\\)层走到的节点编号,这一步可以用DFS实现(后面代码有).用\\(f[x][k]\\)表示从x开始向上走\\(2^k\\)层走到的节点编号.先令\\(f[x][0]\\)等于\\(father(x)\\).然后循环计算\\(f[x][i]=f[f[x][i-1]][i-1]\\)(循环次数取决于节点深度). 要优化寻找过程其实是比较困难的.普通人(比如我)听到倍增都会想到类似\\(1,2,4,8,\\dots\\)这样增加步数.但倍增探测步数后,很可能就跳过了LCA,找到了另一个公共祖先.这是需要撤销步骤,减小探测步数,再次尝试.但这种实现对时间复杂度和编程复杂度的增加都不是我们想要的. 先贤们给出了一种很好的实现.就是把探测步数的变化过程变成从大到小(\\(2^k,2^{k-1},2^{k-1},\\dots,1\\)).考虑将普通整数拆分成2次的幂的和过程,我们就是从大到小减少幂次的(5=4+1).设已经算好的幂的和为\\(m\\),下一次准备增加的幂的幂次为\\(k\\),如果\\(m+2^k&lt;n\\),那么\\(m+=2^{k-1}\\),否则\\(k--\\),发现没有!我们只利用了\"\\(&gt;n\\)\"这个限制条件,就很好的实现了从大到小减小幂次.在倍增求LCA中,这个限制是\\(father[u]!=father[v]\\).这样不断逼近后,求得的\\(father[u]\\)是LCA的儿子,再获取它的父亲即可. LCA(u,v)的结果有2种情况,第一种是等于u或v,也就是1个点是另一个点的祖先;第二种是不等于u或v.第一种情况是不能用上述的方法计算的. 在开始计算LCA时,算一下\\(depth[u]\\)和\\(depth[v]\\),如果不等,就提升深度小的节点(设其为\\(u\\),使其重新赋值为它的深度与\\(v\\)相等的祖先).如果此时\\(u=v\\),说明\\(u\\)是\\(v\\)的祖先.如果不等,就执行下面的操作. 令探测步数\\(k\\)等于\\(log2(depth[x])\\)下取整,如果\\(f[x][k]!=f[y][k]\\),执行\\(x=f[x][k],y=f[y][k]\\),否则执行\\(k--\\).是不是和拆分整数很像?由于步数是够了的,我们最后一定可以到达LCA(u,v)的下一层.return\\(f[x][0]\\)即可. 计算log2(x) 先把log2(x)打出来,节省时间. 12for(int i=1;i&lt;=19;i++) lg[1&lt;&lt;i]++;for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1]; dfs求\\(f[x][k]\\) 12345678910111213void dfs(int x,int fa)//当前节点和father节点 { f[x][0]=fa,depth[x]=depth[fa]+1; int len=g[x].size(); for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1];//和求ST表有异曲同工之妙 } for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) dfs(g[x][i],x);//注意是树,存了father节点 }} 屑LCA 123456789101112int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v);//保证v的深度更大 while(depth[v]&gt;depth[u]) { v=f[v][lg[depth[v]-depth[u]]];//此步的时间复杂度为log(depth[v]-depth[u]) } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; return f[u][0];} 不重要的总代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5,LG=19;int n,m,s;int lg[N&lt;&lt;1],depth[N];int f[N][20];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void dfs(int x,int fa)//当前节点和father节点 { f[x][0]=fa,depth[x]=depth[fa]+1; int len=g[x].size(); for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1];//和求ST表有异曲同工之妙 } for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) dfs(g[x][i],x);//注意是树,存了father节点 }}int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v);//保证v的深度更大 while(depth[v]&gt;depth[u]) { v=f[v][lg[depth[v]-depth[u]]];//此步的时间复杂度为log(depth[v]-depth[u]) } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; return f[u][0];}int main(){ n=read(),m=read(),s=read(); for(int i=1;i&lt;n;i++) { int x,y; x=read(),y=read(); g[x].push_back(y),g[y].push_back(x); } for(int i=1;i&lt;=19;i++) lg[1&lt;&lt;i]++; for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1];//log2(1)=1,log2(2)=2,log2(3)=2,log2(4)=3... dfs(s,0); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(); printf(&quot;%d\\n&quot;,LCA(u,v)); } return 0;} 记得把lg数组开大一点,不然会像我一样RE LCA例题 题型 queryPlus 在得到答案的步骤上下功夫,比如\"寻找中点\".这类问题直接求LCA然后处理即可. getPlus 在寻找LCA的函数中下功夫,比如P1967 [NOIP2013 提高组] 货车运输),问的是路径上最小值,需要更改LCA函数. P3379 【模板】最近公共祖先（LCA） 总不可能还没拿经验吧XD P3938 斐波那契 Des 小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。 小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。 如果我们把这种关系用图画下来，前六个月大概就是这样的： (去洛谷看图,我还没弄好图床) 其中，一个箭头 A → B 表示 A 是 B 的祖先，相同的颜色表示同一个月出生的兔子。 为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 m 个 问题：她想知道关于每两对兔子 \\(a_i\\) 和 \\(b_i\\) ，他们的最近公共祖先是谁。你能帮帮小 C 吗？ 一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，5 和 7 的最近公共祖 先是 2，1 和 2 的最近公共祖先是 1，6 和 6 的最近公共祖先是 6。 Sol 看完了才发现这和上面那道传统意义上的LCA根本不同!不过都看出来做法了就切了它吧! 记得小学看某本趣味数学讲斐波那契就提到了这个经典的兔子问题,规律就是,每个月出生的兔子数量的序列是斐波那契数列.这道题稍有不同,是(1,1,1,2,3,5...). 设兔子的id是\\(x_i\\),有\\(x_i=x_p+x_q(p&lt;q&lt;i,且x_p和x_q在上一个月出生)\\).根据题目的定义,\\(x_i\\)的父亲是\\(p\\)最小的\\(x_p\\).要找到这个\\(x_p\\),只需要知道\\(q\\)最大的\\(x_q\\),也就是上一个月出生的编号最大的那个兔子.而这群兔子的编号序列就是斐波那契数列(1,2,3,5,8,13...).将每个被询问兔子所有的祖先加入数组中,最后从同一深度开始匹配即可.注意查询编号对应的\\(x_q\\)需要用二分查找. 至于斐波那契数列的个数,我计算了一下,大概在第60项的时候到达了\\(10^{13}\\).所以本算法的时间复杂度为\\(O(a[i]\\log a[i]*m)\\)(其实就是常数大亿点的\\(O(m)\\)). My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define min(a,b) ((a)&lt;(b)?(a):(b))using namespace std;const int N=1e2+5;long long fib[N],sub[N],s1[N],s2[N];long long m,p1,p2,u,v,p;inline long long read(){ long long x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return x;} inline long long search(const long long &amp;x){ return sub[lower_bound(fib+1,fib+70,x)-fib];}int main(){ sub[2]=1,sub[3]=2; for(int i=4;i&lt;=70;i++) sub[i]=sub[i-1]+sub[i-2]; fib[1]=1,fib[2]=2; for(int i=3;i&lt;=70;i++) fib[i]=fib[i-1]+fib[i-2]; //这2个数组可要好好推一推。。。 m=read(); for(int i=1;i&lt;=m;i++) { u=read(),v=read(),p1=p2=0; s1[++p1]=u; do { u=u-search(u); s1[++p1]=u; }while(u!=1); s2[++p2]=v; do { v-=search(v); s2[++p2]=v; }while(v!=1); p=min(p1,p2); for(int i=1;i&lt;=p;i++) { if(s1[p1-p+i]==s2[p2-p+i]) { printf(&quot;%lld\\n&quot;,s1[p1-p+i]); break; } } } return 0;} T70138 寻找中点 Des Windy和Zero居住在同一个国家，该国家有N个城市。Windy居住在X城市，Zero居住在Y城市。任意两个城市之间有且只有一条路径相通（中间可能经过其它城市）。有一天，Windy和Zero想见面，他们想把见面的地点定在城市X和城市Y的中间。现在请你告诉他们会见地点应该在哪里？ Sol 先计算2点间的路径(通过计算LCA实现),然后可以把中点城市的深度算出来,遍历到中点城市即可.(仍然需要倍增). My code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/*- 首先输出离城市X近的城市的编号*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=1e5+5;int n,m;int lg[N&lt;&lt;2],depth[N];int f[N][20];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct lowestCommonAncestor{ void lg2() { for(int i=1;i&lt;=15;i++) lg[1&lt;&lt;i]++; for(int i=1;i&lt;=n;i++) lg[i]+=lg[i-1]; } void pre(int x,int father) { int len=g[x].size(); depth[x]=depth[father]+1; f[x][0]=father; for(int i=1;i&lt;=lg[depth[x]];i++) { f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i&lt;len;i++) { if(g[x][i]!=father) { pre(g[x][i],x); } } } int getLca(int x,int y) { if(depth[x]&gt;depth[y]) swap(x,y); for(int i=lg[depth[y]-depth[x]];i&gt;=0;i--) { if(depth[f[y][i]]&gt;=depth[x]) y=f[y][i]; } if(x==y) return x; for(int i=lg[depth[x]];i&gt;=0;i--) { if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; } return f[x][0]; } void solve(int x,int y) { if(x==y) { printf(&quot;%d\\n&quot;,x); return; } if(f[x][0]==y || f[y][0]==x) { printf(&quot;%d %d\\n&quot;,x,y); return; } int flag=true; if(depth[x]&lt;depth[y]) { flag=false; swap(x,y); } int anc=getLca(x,y); int dis=depth[x]+depth[y]-depth[anc]*2; int midDis=depth[x]-dis/2; for(int i=lg[depth[x]-midDis];i&gt;=0;i--) { if(depth[f[x][i]]&gt;=midDis) x=f[x][i]; } if(dis%2==1) { if(flag) printf(&quot;%d %d\\n&quot;,x,f[x][0]); else printf(&quot;%d %d\\n&quot;,f[x][0],x); } else printf(&quot;%d\\n&quot;,x); }}lca;int main(){ n=read(); for(int i=1;i&lt;n;i++) { int u=read(),v=read(); g[u].push_back(v); g[v].push_back(u); } lca.lg2(); lca.pre(1,0); m=read(); for(int i=1;i&lt;=m;i++) { int u=read(),v=read(); lca.solve(u,v); } return 0;} Note 本来f数组开成了f[N][N],MLE了.结果以为是vector存邻接表的问题.呵呵. 树上差分算法介绍 给你一颗树,每次将路径\\((s,t)\\)上的所有点值加1,问最后最大点值是多少. 在树上运用差分思想即可解决. 树上差分算法实现 从根节点向下dfs,在回溯的时候加上差分标记.合理设置差分标记保证当前节点的点值正确即可. 设需要添加路径\\((u,v)\\),\\(LCA(u,v)=lca\\). 对于对点值进行更新的点查分,执行\\(sub[u]++,sub[v]++,sub[lca]--,sub[father[lca]]--\\). 对于对边值进行更新的边差分,将边值下移到对应点.执行\\(sub[u]++,sub[v]++,sub[lca]-=2\\). 树上差分例题 P3128 [USACO15DEC]Max Flow P Des FJ给他的牛棚的N(2≤N≤50,000)个隔间之间安装了N-1根管道，隔间编号从1到N。所有隔间都被管道连通了。 FJ有K(1≤K≤100,000)条运输牛奶的路线，第i条路线从隔间si运输到隔间ti。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 Sol 板子题. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5,K=1e5+5,LG=17;int n,k,now,ans;int sub[N],depth[N],lg[N];int f[N][LG];vector&lt;int&gt; g[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } void pref(int x,int fa)//pretreat f[][]{ f[x][0]=fa,depth[x]=depth[fa]+1; for(int k=1;k&lt;=lg[depth[x]];k++) { f[x][k]=f[f[x][k-1]][k-1]; } int len=g[x].size(); for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) pref(g[x][i],x); }}int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v); while(depth[u]&lt;depth[v]) { v=f[v][lg[depth[v]-depth[u]]]; } if(u==v) return u; for(int k=lg[depth[u]];k&gt;=0;k--) { if(f[u][k]!=f[v][k]) u=f[u][k],v=f[v][k]; } return f[u][0];}void getAns(int x,int fa){ int len=g[x].size(); for(int i=0;i&lt;len;i++) { if(g[x][i]!=fa) { getAns(g[x][i],x); sub[x]+=sub[g[x][i]]; } ans=max(ans,sub[x]); }}int main(){ n=read(),k=read(); for(int i=1;i&lt;=LG;i++) lg[1&lt;&lt;i]++; for(int i=2;i&lt;=n;i++) lg[i]+=lg[i-1]; for(int i=1;i&lt;n;i++) { int u=read(),v=read(); g[u].push_back(v); g[v].push_back(u); } pref(1,0);//无根树可将任何一个节点作为根 for(int i=1;i&lt;=k;i++) { int u=read(),v=read(); int lca=LCA(u,v); sub[u]++,sub[v]++,sub[lca]--,sub[f[lca][0]]--; } getAns(1,0); printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(LCA)/"},{"title":"【专题】树形动态规划","text":"简介 树形动态规划就是在树上进行的动态规划! 由于树的性质,父节点蕴含的信息肯定比子节点多.所以树形 DP 一般递归进行.在求解了子节点对应的子问题后,合并出父节点的信息. 能有树形 DP 解决的问题仍然具有动态规划的一般性质: 最优子结构 子问题的重叠性 无后效性 题目仍然具有一般动态规划的特征: 要求输出的信息是所有可能用到信息的一部分 具有不同的约束条件 根据约束条件确定转移状态,状态对应的值是答案信息. 类型 基础类型(约束条件为父亲/儿子) 本类问题很接近树形动态规划的本质.父子节点间相互有联系(其实就是状态).如果你第一次接触树形 DP,想要合适地转移或记录状态,其实比较困难.但好在本类问题的解法比较固定. P1352 没有上司的舞会 父节点选了子节点就不能选,父节点不选子节点就可以选或不选.是否意味着子节点的状态需要由父节点来确定呢? 回顾以前的动态规划,从来就没有这个道理! 其实.每个节点只有2种状态,选,或不选.父节点的状态完全可以从子节点转移过来.所以就有了方程 \\(f[u][0]=r[u]+\\sum_{edge(u,v)}f[v][1],f[u][1]=\\sum _{edge(u,v)}max(f[v][1],f[v][0])\\) 最后答案取\\(max(f[root][0],f[root][1])\\). SP1437 PT07Z - Longest path in a tree 设从根向下遍历的最长长度为\\(d1\\),次长长度为\\(d2\\),那么\\(ans=d1+d2\\).对于每个子树也是这样.满足无后效性(父节点的\\(d1\\)和\\(d2\\)必然从子节点的\\(d1\\)转移得到(可以归纳证明)). 如果\\(son.d1+son.d2+1&gt;father.d1\\),那么\\(father.d2=father.d1,father.d1=son.d1+son.d2+1\\). 否则,如果\\(son.d1+son.d2+1&gt;father.d2\\).那么\\(father.d2=son.d1+son.d2+1\\). P2016 战略游戏 约束条件为每个节点自己或儿子至少有一个放了士兵.自己放不放完全取决于儿子放没有. \\(f[u][0]=\\sum f[v][1]\\\\f[u][1]=1+\\sum min(f[v][1],f[v][0])\\) #10157. 「一本通 5.2 例 5」皇宫看守 上一题的升级版. 本题的约束条件为每个节点的父亲,儿子或自己必须有一个安排了警卫.我们总是首先考虑子节点向父节点的转移方式.不难发现,和子节点被谁看到有关.设\\(f[u][0],f[u][1],f[u][2]\\)分别表示节点被父亲,自己,儿子看到. 那么 \\(f[u][0]=\\sum_{edge(u,v)}min(f[v][1],f[v][2]),\\) \\(f[u][1]=c[u]+\\sum_{edge(u,v)}min(f[v][0],f[v][1],f[v][2]),\\) \\(f[u][2]=\\sum_{edge(u,v)}min(f[v][1],f[v][2])+d.\\) 其中\\(d=min(f[v][2]-min(f[v][1],f[v][2]))\\),保证至少有一个儿子看到. 结合背包(约束条件为选择根/枝条个数) P2015 二叉苹果树 子节点对父节点的依赖在于剩下能保留的枝条数量.但如果运用背包思想加维,就可去除这个依赖,即算出所有子节点可能的状态(不同的保留数量). 本题树为二叉树,具有特殊性质,所以可以用更简单的方法求解(给子节点分配数量). P2014 [CTSC1997]选课 与上一题相似,不在赘述.DP 方程为\\(f[u][sz]=max(f[u][sz],f[u][sz-k]+f[v][k])\\). P1273 有线电视网 其实这道题没有约束条件,把每个节点的信息保留好即可. DP 方程:\\(f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w)\\).","link":"/2021/03/22/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】状压 DP","text":"前言 前置知识: 位运算,基础动态规划 位运算的实际运用 判断第 i 位是否为 0 1S&amp;(1&lt;&lt;(i-1))==0 将第 i 位置为 1 1S|(1&lt;&lt;(i-1)) 将第 i 位置为 0 1S&amp;~(1&lt;&lt;(i-1)) 例题 POJ2411 Mondriaan's Dream Des Squares and rectangles fascinated the famous Dutch painter Piet Mondriaan. One night, after producing the drawings in his 'toilet series' (where he had to use his toilet paper to draw on, for all of his paper was filled with squares and rectangles), he dreamt of filling a large rectangle with small rectangles of width 2 and height 1 in varying ways. Expert as he was in this material, he saw at a glance that he'll need a computer to calculate the number of ways to fill the large rectangle whose dimensions were integer values, as well. Help him, so that his dream won't turn into a nightmare! 给出一个W行H列的广场,用1*2小砖铺盖,小砖之间互相不能重叠,问有多少种不同的铺法？ 1&lt;=W，H&lt;=11 Sol 每一行的状态只影响下一行,于是我们可以枚举状态来确定下一行怎么放.具体的操作看其他的题解吧. 这里用的 DFS 其实更适合入门. My code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;typedef long long ll;using namespace std;const int N=20,S=1&lt;&lt;13;int w,h,s;ll f[N][S];//第i行状态为s1,第i+1行状态为s2,当前在第d列 void dfs(int i,int s1,int s2,int d) { //不同的s1可能推出相同的s2 //列在d-1结束 if(d==w) {f[i+1][s2]+=f[i][s1];return;} if((s1&amp;(1&lt;&lt;d))==0) { //如果s1第d位是0 dfs(i,s1,s2|(1&lt;&lt;d),d+1);//将s2的第d位置为1 if(d&lt;w-1 &amp;&amp; (s1&amp;(1&lt;&lt;(d+1)))==0) { //如果第d+1位也是0 dfs(i,s1,s2,d+2); //横着放,不用管 } } else dfs(i,s1,s2,d+1); //放不了,也不用管 }int main() { while(cin&gt;&gt;w&gt;&gt;h &amp;&amp; w) { s=1&lt;&lt;w; memset(f,0,sizeof f); f[1][0]=1,dfs(1,0,0,0); for(int i=2;i&lt;=h;i++) { for(int j=0;j&lt;s;j++) { if(f[i][j]) dfs(i,j,0,0); } } cout&lt;&lt;f[h+1][0]&lt;&lt;endl; } return 0;}","link":"/2021/03/26/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%8A%B6%E5%8E%8B-DP/"},{"title":"【专题】算法正确性的证明-分治","text":"假设我们希望证明整个一系列无穷多个数学命题 A1，A2，A3，…， （它们合起来成为一般命题A）．假设a）通过某些数学论证证明了：如果r是任意正整数，且如果命题Ar已知是真的，则可推出命题Ar＋1也真；b）第一个命题A1已知是真的．那么，序列的所有命题必然都是真的，从而A得证． 摘自《什么是数学》。 前言 本文的大部分内容都受到《算法图解》的启发. 快速排序的正确性 基线条件:快速排序对只有一个元素或没有元素的数组管用(直接返回) 归纳条件: 快速排序对有2个元素的数组管用(会分成2个子数组,左边小于基准值,右边大于基准值). 快速排序对有3个元素的数组管用(分成2个子数组,一个元素数量为2,一个元素数量为1). 快速排序对有4个元素的数组管用(分成2个子数组,一个元素数量为2,另一个元素数量也为2). ...... 快速排序对有n个元素的数组管用. 基线条件+归纳条件,我们已经归纳证明了快速排序的正确性.","link":"/2021/03/13/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E-%E5%88%86%E6%B2%BB/"},{"title":"【专题】线性动态规划","text":"前言: 本文介绍了基础的线性动态规划,并给出了例题. 最长上升(不下降)子序列(LIS) 做法 \\(O(n^2)\\) 如果是不下降只用把f[i]&lt;f[j]改成f[i]&lt;=f[j] 方程:f[i]=max(f[j]+1) j∈i+1~n了 ps:每个位置的初始长度都是1!!!! 1234567891011121314151617181920212223242526272829303132333435363738//最长上升序列#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std;int n,a[5005],f[5005]; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; f[i]=1; }// f[n]=1;每个位置都是1 for(int i=n-1;i&gt;=1;i--) { for(int j=i+1;j&lt;=n;j++) { if(a[i]&lt;a[j]) f[i]=max(f[i],f[j]+1); } } int ans=0; for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i]); } cout&lt;&lt;ans; return 0;} \\(O(n\\ log\\ n)\\) O(n*logn)的进阶算法,主要思想是贪心和二分 导弹拦截 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100005],p,f[100005],k=0;int main(){ while(cin&gt;&gt;a[p]) { p++; } f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&lt;=f[k]) { f[++k]=a[i]; } else { int x=upper_bound(f,f+k,a[i],greater&lt;int&gt;())-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; k=0; memset(f,0,sizeof(f)); f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&gt;f[k]) { f[++k]=a[i]; } else { int x=lower_bound(f,f+k,a[i])-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; return 0; } 主要是贪心思想,对于每个a[i],如果a[i]&gt;f[end],a[i]就接在f[end]; 反之,替换掉f数组中大于a[i]的最小的(upper_bound(f.begin,f.end,a[i])) 不好严格证明,如下为示例: 样例: 121413 7 9 16 38 24 37 18 4 19 21 22 63 15 过程: 1234567891377 97 9 16 387 9 16 247 9 16 187 9 16 18 197 9 16 18 19 21 22 637 9 15 18 19 21 22 63 最长公共子序列(LCS) 描述 给定一个序列X=&lt;x1,x2,x3,x4...,xm&gt;，另一个序列Z=&lt;z1,z2,z3,z4...,zk&gt;，若存在一个严格递增的X的下标序列&lt;i1,i2,i3,...,ik&gt;对所有的1,2,3,...,k，都满足x(ik)=zk，则称Z是X的子序列 比如Z=&lt;B,C,D,B&gt;是X=&lt;A,B,C,B,D,A,B&gt;的子序列 做法 \\(O(n^2)\\) 方程:f(i,j)={f[i-1,j-1](a[i]=a[j]),max(f[i-1][j],f[i][j-1])(a[i]≠a[j]} 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;char a[205],b[205];int f[205][205]; int main(){// ios::sync_with_stdio(false); scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); strlen() int lena=strlen(a+1),lenb=strlen(b+1);//从下标1开始计算长度 size t cdecl strlen (const char Str) for(int i=1;i&lt;=lena;i++) { for(int j=1;j&lt;=lenb;j++) { if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); } } cout&lt;&lt;f[lena][lenb]; return 0;} 最经典的是这个图 img \\(O(n\\ log\\ n)\\) 具体看【题解】P1439 【模板】最长公共子序列.将LCS转化为LIS. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,t,f[N],r;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } struct line{ int x,y;}a[N];bool cmp(const line &amp;a,const line &amp;b){ return a.x&lt;b.x;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { t=read(); a[t].x=i; } for(int i=1;i&lt;=n;i++) { t=read(); a[t].y=i; } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(a[i].y&gt;f[r]) f[++r]=a[i].y; else *upper_bound(f+1,f+r,a[i].y)=a[i].y; } printf(&quot;%d\\n&quot;,r); return 0;}","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【专题】线段树-进阶(含主席树)","text":"概览 介绍了标记永久化线段树和主席树. 标记永久化线段树 例题:P1083 [NOIP2012 提高组] 借教室 Des 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来\\(n\\)天的借教室信息，其中第\\(i\\)天学校有\\(r_i\\)个教室可供租借。共有\\(m\\)份订单，每份订单用三个正整数描述，分别为\\(d_j,s_j,t_j\\)，表示某租借者需要从第\\(s_j\\)天到第\\(t_j\\)天租借教室（包括第\\(s_j\\)天和第\\(t_j\\)天），每天需要租借\\(d_j\\)个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供\\(d_j\\)个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第\\(s_j\\)天到第\\(t_j\\)天中有至少一天剩余的教室数量不足\\(d_j\\)个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 Sol 这道题很容易相当直接用线段树做区间减法,过程中判断教室还够不够.但是,许多同学的线段树被卡了时间.我们就来看看如何写线段树才能过这道题. 1234567void pdown(int l,int r,int p){ ll mid=(l+r)&gt;&gt;1; tag[ls[p]]+=tag[p],ans[ls[p]]+=(mid-l+1)*tag[p]; tag[rs[p]]+=tag[p],ans[rs[p]]+=(r-mid)*tag[p]; tag[p]=0;} 在普通的push_down函数中,需要执行2次乘法,2次加法,还要将tag[p]赋值为0.粗略的看,这样延迟下传的好处是能减少一次update的时间.但如果数据满足一定条件,再执行几次update,每次都会执行多次push_down,花费的时间甚至可能更多.","link":"/2021/03/12/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91-%E8%BF%9B%E9%98%B6(%E5%90%AB%E4%B8%BB%E5%B8%AD%E6%A0%91)/"},{"title":"【专题】递推","text":"水水水水水 问题 A: 铺瓷砖 题目描述 用红色的 1×1 和黑色的 2×2 两种规格的瓷砖不重叠地铺满 n×3 的路面，求出有多少种不同的铺设方案。 输入 一行一个整数 n，0&lt;n&lt;1000。 输出 一行一个整数，为铺设方案的数量模12345的结果。 1:1 2:3 4:5 5:11 也就是2n+1,2n-1滴规律 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,ans=1; int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; if\\(n==1\\) cout\\&lt;\\&lt;ans; else \\{ for\\(int j=2;j\\&lt;=n;j++\\) \\{ if\\(j\\%2==0\\) \\{ ans=ans\\*2+1; \\} else \\{ ans=ans\\*2-1; \\} ans\\%=12345; \\} \\} cout\\&lt;\\&lt;ans; return 0; } 问题 B: 彩带 题目描述 一中 90 周年校庆，小林准备用一些白色、蓝色和红色的彩带来装饰学校超市的橱窗，他希望满足以下两个条件： (1) 相同颜色的彩带不能放在相邻的位置； (2) 一条蓝色的彩带必须放在一条白色的彩带和一条红色的彩带中间。 现在，他想知道满足要求的放置彩带的方案数有多少种。例如，如图 所示为橱窗宽度n=3 的所有放置方案，共 4 种。 输入 一行一个整数 n，表示橱窗宽度(或者说彩带数目)。 输出 一行一个整数，表示装饰橱窗的彩带放置方案数。 样例输入 Copy 3 样例输出 Copy 4 提示 对 30% 的数据满足：1≤n≤15。 对 100% 的数据满足：1≤n≤45。 斐波那契数列,但前两项都是2 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,f[50]; int main() { ios::sync_with_stdio(false); f\\[1\\]=f\\[2\\]=2; cin&gt;&gt;n; for\\(int j=3;j\\&lt;=n;j++\\) \\{ f\\[j\\]=f\\[j-1\\]+f\\[j-2\\]; \\} cout\\&lt;\\&lt;f\\[n\\]; return 0; } 1389: 城市路径 题目描述 地图上有 n 个城市，一只奶牛要从 1 号城市开始依次经过这些城市，最终到达 n 号城市。但是这只奶牛觉得这样太无聊了，所以它决定跳过其中的一个城市(但是不能跳过 1 号和 n 号城市)，使得它从 1 号城市开始，到达 n 号城市所经过的总距离最小。假设每一个城市 i 都有一个坐标(x i ，y i )，从 (x 1 ，y 1 ) 的城市 1 到 (x 2 ，y 2 ) 的城市 2 之间的距离为 | x 1 -x 2 | + | y 1 -y 2 | 。 输入 第 1 行 1 个正整数 n，表示城市个数。 接下来的 n 行，每行 2 个数 x i 和 y i ，表示城市 i 的坐标。 输出 一行一个数，使得它从1号城市开始，跳过某一个城市，到达n号城市所经过的最小总距离。 样例输入 Copy 4 0 0 8 3 11 -1 10 0 样例输出 Copy 14 提示 【样例说明】 跳过 2 号城市。 【数据规模】 对于 40% 的数据满足：n≤1000。 对于 100% 的数据满足：3≤n≤100000，-1000≤x i ，y i ≤1000。 pz:这不是枚举吗? #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int n,x[100005],y[100005],maxx,tot; int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=2;i&lt;=n;i++) { tot+=abs(x[i-1]-x[i])+abs(y[i-1]-y[i]); } for(int i=2;i&lt;n;i++) { int save=(abs(x[i-1]-x[i])+abs(y[i-1]-y[i])+abs(x[i+1]-x[i])+abs(y[i+1]-y[i]))-(abs(x[i-1]-x[i+1])+abs(y[i-1]-y[i+1])); if(save&gt;0&amp;&amp;save&gt;maxx) maxx=save; } cout&lt;&lt;