{"pages":[{"title":"about","text":"Hi, 我是huaruoji,一个现役OIer! 关于本博客 使用Github Pages+Hexo搭建, 主题是iracus 特别感谢AlphaLxy 提供的个性化配置方案!","link":"/about/index.html"}],"posts":[{"title":"【专题】乘法逆元","text":"乘法逆元,一般用于将模意义下的除法转换为乘法.本文介绍了乘法逆元,并给出了算法实现. 前言: 乘法逆元,一般用于将模意义下的除法转换为乘法 求解普通逆元($ax\\equiv 1(mod\\ m)$)拓展欧几里得首先我们看看逆元的定义:若$ax\\equiv 1(mod \\ m)$,且a与m互质,则$x$为$a$在$mod \\ m$意义下的乘法逆元,记作$a^{-1}$. 根据这个同余式,我们可以得到$ax+km=1$,且a和m是互质的,那么就满足贝祖等式$ax+by=gcd(a,b)$,可以用拓欧求解. 1234567891011ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)//ax+by{ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y),t=x; x=y,y=t-(a/b)*x; return ret;} 这个板子虽然稍长,但返回值是gcd,用处更广泛 另外,由于gcd求得负数和1最大公约数是-1,exgcd不能用来求解a为负数的情况 快速幂观察乘法逆元的形式:$ax \\equiv1(mod \\ m)$. 考虑到欧拉定理:$a^{\\varphi (m)} \\equiv 1(mod\\ m)$. 由于洛谷模版题中给出m为质数,则有:$$ax \\equiv a^{m-1}(mod\\ m)\\a \\equiv a^{m-2}(mod \\ m)$$$那么,a在mod \\ m意义下的乘法逆元即为a^{m-2} mod \\ m$,满足快速幂形式,可使用快速幂求解. 12345678910111213ll fpm(ll x, ll power, ll mod) { x%=mod; ll ans=1; for (;power;power&gt;&gt;=1,(x*=x)%=mod) if(power&amp;1)(ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);} 代码中的(ans*=x)%=mod即为(ans=ans*x)=(ans=ans*x)%mod.ns*x)%mod`.","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"【专题】Trie树（基本无用）","text":"pz:Trie树-&gt;字典树 就是查字典用到的树! 具体来说就是一颗26叉树,代表璎文26个字母,这样查询单词起来就变得10分的快速了. build函数,建立Trie树 s(search)函数,查找该使用前缀的单词出现次数 记录一下偶滴辞典 http://acm.hdu.edu.cn/showproblem.php?pid=1251模版题#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;char str[20];int trie[1000005][26];int cnt[1000005];int tot; void build(){ int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-‘a’]==0) trie[p][str[i]-‘a’]=++tot; p=trie[p][str[i]-‘a’]; cnt[p]++; }} int s(){ int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-‘a’]==0) return 0; p=trie[p][str[i]-‘a’]; } return cnt[p];} int main(){ ios::sync_with_stdio(false); while\\(gets\\(str\\) \\&amp;\\&amp; str\\[0\\]\\!='\\\\0'\\) \\{ build\\(\\); \\} while\\(scanf\\(&quot;\\%s&quot;,str\\)\\!=EOF\\) \\{ cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​​ return 0;} 前缀统计题目描述给定N个字符串S1,S2…SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。 输入字符串的总长度不超过10^6，仅包含小写字母。 输入格式第一行两个整数N，M； 接下来N行每行一个字符串Si ； 接下来M行每行一个字符串表示询问。 输出格式对于每个询问，输出一个整数表示答案 输入输出样例输入 #1复制 3 2abbcabcabcefg 输出 #1复制 20 pz:和模版反了过来,但是代码cbd修改如下:1. tot只记录Si尾部字母2. 询问出现次数 返回值累加 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;char str[1000005];int trie[1000005][26];int cnt[1000005];int tot,n,m; void build(){ int p=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-‘a’]==0) trie[p][str[i]-‘a’]=++tot; p=trie[p][str[i]-‘a’]; } cnt[p]++;} int s(){ int p=0,ans=0; int len=strlen(str); for(int i=0;i&lt;len;i++) { if(trie[p][str[i]-‘a’]==0) return ans; p=trie[p][str[i]-‘a’]; ans+=cnt[p]; } return ans;} int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;str; build\\(\\); \\} for\\(int j=1;j\\&lt;=m;j++\\) \\{ cin&gt;&gt;str; cout\\&lt;\\&lt;s\\(\\)\\&lt;\\&lt;endl; \\} ​​ return 0;} 2020/3/28 20:39","link":"/2020/03/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91Trie%E6%A0%91/"},{"title":"【专题】初赛位运算","text":"以下摘自洛谷日报 “&lt;&lt;” “&gt;&gt;” 运算 首先，在这里这东西跟 cin cout 没有什么关系。 在二进制运算中，这东西叫做“左移”“右移”运算，顾名思义，就是将一个二进制数向左或向右移动 k 位，就是给一个数乘 2^k 或者除 2^k (末尾1不计)。 那么这东西有什么用呢？这东西快啊 “~”运算 又称取反运算，就是对一个二进制数按位取反。 对于 int 来说， ~ x=-x-1 那么这东西有什么用呢？我也不知道 “&amp;”运算 “&amp;”运算，即“and” 运算，也是一种逻辑运算符，对于二进制运算来说，“&amp;”运算的意义是对于两个二进制数的每一位，如果这一位都是 1 ，那么这一位为 1 ，否则这一位为 0 。 举个例子 10101(21) &amp; 11100(28) = 10100{20} 我们可以用 &amp; 运算判断一个数是奇数还是偶数，当 x 为奇数时， x 二进制下的第 0 位一定是 1 ，否则为 0 。我们让 x &amp; 1 ，就可以知道 x 的奇偶性了。 “|” 运算 即 “or” 运算，也是一种逻辑运算符，对于二进制运算来说，“|” 运算的意义是对于两个二进制数的每一位，如果这两个数此位有一个 1 那么此位就是 1 ，否则为 0 。 举个例子 10101(21) | 11100(28) = 11101(29) 通过对这两个运算的观察，我们可以发现一个规律 x &amp; y&lt;=xx | y&gt;=x 根据二进制的性质很容易就可以得出这些结论吧 “^”运算 “^”运算，又称“xor”运算，异或运算。定义是对于两个二进制数的每一位，如果相同则为 0 ，否则为 1 。 举个例子 10101(21) ^ 11100(28) = 1001(9) 异或是一个非常神奇的东东 首先显而易见的是一个数异或他自己肯定是得 0 的 其次对于一个形如 2n 的数 x ， x ^ 1 =x+1 ,而对于一个形如 2n+1 的数 x ， x ^ 1 =x-1 然后异或运算满足以下交换律 如果 x ^ y=z 那么 y ^ z=x ， x ^ z=y 异或运算还是比较常用到的，简单举两个例子 例题一 给你 n 个数，其中只有一个数出现过一次，其余都成对出现，问只出现过一次的那个数是那个数。 原题 P1469 找筷子（https://www.luogu.org/problemnew/show/P1469） 利用异或的性质 x ^ x=0 ，将所有数异或起来，最后剩下来的那个数就是答案了。 例题二 计算 1 ^ 2 ^ 3 ^ 4 ^ … ^ n 的值 原题 P3908 异或之和（https://www.luogu.org/problemnew/show/P3908） 首先最开始是 1 ，根据异或的性质，我们可以知道 (2n) ^ 1 是等于 2n+1 的 于是我们又回到了 1 ，所以可以得出答案是以 4 为周期循环的。 -———– 接下来厉害的来了，这三种运算是可以互相转换的 x|y= ~ (( ~ x) &amp; ( ~ y)) x &amp; y= ~ (( ~ x)|( ~ y)) x ^ y=(x|y)-(x &amp; y)=x+y-((x &amp; y)&lt;&lt;1) 但这东西似乎除了能让你感受到位运算的博大精深以外似乎什么用都没有 洛谷日报结束 位运算大部分人都知道，看一道18年初赛题： 14. 为了统计一个非负整数的二进制形式中 1 的个数，代码如下: int CountBit(int x) { int ret = 0; while (x) { ret++; ___________; } return ret; } 则空格内要填入的语句是( )。 A. x &gt;&gt;= 1 B. x &amp;= x - 1 C. x |= x &gt;&gt; 1 D. x &lt;&lt;= 1 答案为B 这种题思路就是先举1个数，再一个一个代入。 如9 二进制为 1001 A选项只会一次删掉一位 1001 100 10 1 答案为4，排除 B选项 1001 &amp; 1000 = 1000 1000 &amp; 0111 = 0 答案为2，正确 C选项 错 D选项 死循环，与A类似","link":"/2019/10/18/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%88%9D%E8%B5%9B%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"【专题】前缀，后缀表达式求值","text":"前缀表达式 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从右至左，遇数压1，遇符弹2，再来计算。 后缀表达式 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 从左至右，遇数压1，遇符弹2，再来计算。 例题 https://www.luogu.org/problem/P1449 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt;using namespace std; int a[1005],p,top,t; char c; int main(){ while(c=getchar()) { if(c==’@‘) break; if(isdigit(c)) t=t*10+c-‘0’; if(c==’.’) { a[++top]=t; t=0; } if(c==’+’) { a[top-1]=a[top]+a[top-1]; top--; } if(c==’-‘) { a[top-1]=a[top-1]-a[top]; top--; } if(c==’*‘) { a[top-1]=a[top]*a[top-1]; top--; } if(c==’/‘) { a[top-1]=a[top-1]/a[top]; top--; } } cout&lt;&lt;a[top]; return 0;} 注意事项： 1.有除法，并且就按c++里的整除运算 2.getchar()在cstdio里面","link":"/2019/10/19/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%89%8D%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"title":"【专题】埃氏素数筛法(Eratosthenes)","text":"埃氏筛法: 对于每一个小于n的非负整数p,删去2p,3p,4p……,当处理完所有数后,还没有删除的就是素数. 想法:用a记录素数表,a[i]=1表示不是素数,a[i]=0表示是素数. #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;int n,m,a[10000005],t; int main(){ a[1]=1; cin&gt;&gt;n&gt;&gt;m; int pd=sqrt(n+0.5); for(int i=2;i&lt;=pd;i++) if(!a[i]) for(int j=i*i;j&lt;=n;j+=i) a[j]=1; // for(int i=1;i&lt;=100;i++) // cout&lt;&lt;a[i]&lt;&lt;endl; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;t; if(a[t]==0) cout&lt;&lt;“Yes\\n”; else cout&lt;&lt;“No\\n”; } return 0;} 注意:1不是素数,需要特判!","link":"/2019/10/20/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%9F%83%E6%B0%8F%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95(Eratosthenes)/"},{"title":"【专题】字典树(Trie)","text":"字典树用于解决 有多个长度短的字符串的问题 异或问题.本文包含了几道简单题. 前言: 字典树用于解决 有多个长度短的字符串的问题 异或问题 #2122 【模板】电话簿 处理每个电话号码时要输出NO有2种情况,一是某个已经处理的电话号码是它的前缀,二是它是某个已处理的电话号码的前缀,2种情况分别处理即可,注意trie[0]也需要清零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int t,n,trie[maxn][30],end[maxn],size;char str[15];bool insert(int v){ int now=0; for(int i=0;str[i]!='\\0';i++) { if(end[now]) return false; int son=str[i]-48; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=v; for(int i=0;i&lt;=9;i++) if(trie[now][i]) return false; return true;}void empty(){ memset(end,0,sizeof(end)); size=0; memset(trie[0],0,sizeof(trie[0]));}int main(){ cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; bool flag=false; for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;,str); if(insert(1)==false) { flag=true; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); empty(); } return 0;} #2204 秘密消息 与第一题类似,若密码可以匹配信息,有2种情况,一是信息是密码的前缀,二是密码是信息的前缀.且此题需要统计个数,则建立2个数组tot和end.tot统计当前节点向下有多少个单词,用于计算是密码是信息前缀的信息数量;end统计在当前节点有多少个单词结束,用于计算信息是密码前缀的信息数量. 将密码在字典树中匹配,将沿途的tot累加为ans,若密码长度大于可匹配长度,则ans可直接输出.若密码长度小于可匹配长度,则输出ans-end[now]+tot[now],即加上密码是信息前缀的信息数量(+tot[now),因为在now节点结束的信息对tot有贡献,需减去(-end[now]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,m,len,trie[maxn][30],tot[maxn],end[maxn],size;int key[maxn],info[maxn];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-') s=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s*x;}void insert(int v,int len){ int now=0; for(int i=1;i&lt;=len;i++) { int son=key[i]; if(trie[now][son]==0) { memset(trie[++size],0,sizeof(trie[size])); trie[now][son]=size; } now=trie[now][son]; tot[now]++; } end[now]++;}int query(int len){ int now=0,ans=0; bool flag=false; for(int i=1;i&lt;=len;i++) { if(trie[now][info[i]]==0) { flag=true; break; } now=trie[now][info[i]]; ans+=end[now]; } if(flag==false) return ans-end[now]+tot[now]; else return ans; }int main(){ m=read(); n=read(); for(int i=1;i&lt;=m;i++) { len=read(); for(int j=1;j&lt;=len;j++) { key[j]=read(); } insert(1,len); } for(int i=1;i&lt;=n;i++) { len=read(); for(int j=1;j&lt;=len;j++) { info[j]=read(); } printf(&quot;%d\\n&quot;,query(len)); } return 0;} #3827 The XOR Largest Pair 将每个数按照二进制存进字典树,从最高位按”先走不同,再走相同”的贪心规则向下走. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*将每个数转为2进制,从高位开始建立trie树,按照贪心原则向下走,同时记录走过位数,最后还原 */#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+5;int n,t,ans,trie[maxn][30],end[maxn],size;int pow_2[35];int to2(int x,int *a){ int p=-1; while(x) { a[++p]=x%2; x/=2; } return p;}int insert(int *a,int len){ int now=0,ret=0,xor_now=0; for(int i=30;i&gt;=0;i--)//共31位,最大是2^31-1,满足题目要求 { int son=a[i]; //下方操作只有在操作第一个数时不安全 if(trie[xor_now][!son])//和当前位相反的数是否有 { ret+=pow_2[i]; xor_now=trie[xor_now][!son]; } else { xor_now=trie[xor_now][son]; } if(trie[now][son]==0) { ++size; end[size]=0; trie[now][son]=size; } now=trie[now][son]; } end[now]=1; return ret; }int main(){ //初始化打表 pow_2[0]=1; for(int i=1;i&lt;=30;i++) { pow_2[i]=pow_2[i-1]*2; } cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;t; int t_2[35]; memset(t_2,0,sizeof(t_2)); int now_ans=insert(t_2,to2(t,t_2)); if(now_ans&gt;ans &amp;&amp; i!=1) ans=now_ans; } cout&lt;&lt;ans; return 0;} 总结: 字典树大部分题目的核心操作是在添加单词时进行的,正确性涉及到字典树的特殊结构(添加一个单词,若与前面添加的单词有关系,则在此时就会被处理;若与后面添加的单词有关系,会在后面被处理). 字典树可很好的解决前缀/后缀问题 字典树可解决部分关于位运算操作的问题(将数转为01串,建立0-1 trie)","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E5%85%B8%E6%A0%91(Trie)/"},{"title":"【专题】字符串匹配(KMP+普通算法)","text":"字符串匹配定义母串为S,子串为T,在S中寻找到T,即为字符串匹配 普通匹配算法12345678910k=0;for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;t.length();j++) { if(s[k]==t[j]) continue; else cout&lt;&lt;&quot;Fail&quot;,break; } k=i-j+2//此处最重要} 假设t串长度为5,第一次循环后k也为5","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D(KMP+%E6%99%AE%E9%80%9A%E7%AE%97%E6%B3%95)/"},{"title":"【专题】并查集(入门)","text":"前言: 本文介绍了并查集及其优化(启发式合并和路径压缩),并提供了几道入门题目. 并查集什么是并查集并查集用于查询和合并多组关系,最常见的例子就是处理家族关系问题,需要查找成员关系和合并家族.并查集需要提供合并和查找操作. 简单实现初始化建立father[n]数组将father[i]初始化为i 查找操作12345int find(int x){ if(father[x]==x) return x; else return find(father[x]);} 合并操作12345void merge(int x,int y){ x=find(x),y=find(y); fa[x]=y;} 算法优化路径压缩算法用于优化并查集查找操作的时间复杂度 一个例子,若a,b,c,d满足这样的关系:a&lt;-b&lt;-c&lt;-d,&lt;-箭头表示左边的是右边的父亲.那么在每次find(d)的过程中将会经历4次递归.每次我们都找到了d的祖先是a,但没有将这个关系记录下来.由于只需要查找一个元素的祖先,将father[d]设为a也未尝不可.将查找路径上的每个节点直接连接到根上,这就是路径压缩算法.如下面的代码. 12345int find(x){ if(father[x]!=x) father[x]=find(father[x]);//if中的条件用于处理根节点,后面的语句包含了递归和优化的操作 return father[x];} 启发式合并(按秩合并)用于优化并查集合并操作的时间复杂度 滑稽村庄和阴险村庄要被拆迁了,政府告诉它们两个村庄拆迁二选一.由于滑稽村庄的人数远大于阴险村庄,两村的村长协商后,决定让阴险村庄的居民暂时在滑稽村庄居住. 你已经发现了,对于两组关系的合并来说,数量少的合并到数量大的似乎要方便些.事实上在并查集的操作中也是这样的.我们便有了算法: 123456789int father[n],size[n];//初始化时新增了size数组void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];//不需要处理size[x]} 这种受到人类经验启发的算法称作启发式算法. 时间复杂度 路径压缩 启发式合并 时间复杂度 批注 × √ $O(m\\ log\\ n)$ 最坏 √ × $O(m\\ log_{1+m/n}\\ n)$,$O(m\\alpha (m,n))$ 最坏,平均 √ √ $O(m\\alpha(m,n))$ 最坏 其中,m表示find操作次数,n表示合并操作次数.$\\alpha()$函数为Ackermann函数的反函数,在OI中你可以认为是一个小于4的常数. 对于一般的题,使用路径压缩和启发式合并即可.有些题目不能使用路径压缩,因此学习启发式合并还是很有必要的. 题目P3367 【模板】并查集 - 洛谷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,z,x,y,father[10005],size[10005];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(size[x]&gt;size[y]) swap(x,y); father[x]=y; size[y]+=size[x];} int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) { father[i]=i,size[i]=1; } for(int i=1;i&lt;=m;i++) { z=read(),x=read(),y=read(); if(z==1) merge(x,y); else { x=find(x),y=find(y); if(x==y) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } } return 0;} P1111 修复公路 - 洛谷Sol 初始化num为n,代表现存集合个数.显然若只存在一个集合,所有村庄都可通车. 在merge时,如果x和y所在集合不同,将num--.直到num=1时输出t. Note 到这道题才发现之前的板子有点问题…在merge时如果x和y已经在同一个集合了,就不用合并. My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005,M=1e5+5;int n,m,father[N],size[N],num;//num表示现存集合个数 struct relation{ int x,y,t; bool operator &lt; (const relation &amp;b) const //如果要结构体排序,也可使用这种方法,注意是重载小于运算符 { if(t&lt;b.t) return true; else return false; }}a[M];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x]; }void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; num--; father[x]=y;}int main(){ n=read(),m=read(); num=n; for(int i=1;i&lt;=n;i++) father[i]=i,size[i]=1; for(int i=1;i&lt;=m;i++) { a[i].x=read(),a[i].y=read(),a[i].t=read(); } sort(a+1,a+m+1); for(int i=1;i&lt;=m;i++) { merge(a[i].x,a[i].y); if(num==1) { printf(&quot;%d\\n&quot;,a[i].t); return 0; } } printf(&quot;-1\\n&quot;); return 0;} [P3958 NOIP2017 提高组] 奶酪 - 洛谷Sol 首先判断2个球的位置的方法很容易推出来,如果(dist(a,b)&lt;=2r),那么2个球相交或相切. 暴力两两判断球是否连通,若联通则合并,最后判断每个集合是否能到达顶和底即可.时间复杂度复杂度为$O(Tn^2\\alpha (n))$. Note 点坐标的绝对值不超过$10^9$计算2点距离过程会爆int. 12345double dist(int x,int y){ int m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z;//应把int改为long long return sqrt(m1*m1+m2*m2+m3*m3);} 另外,dist(i,j)&lt;=2*r涉及到了隐式转换,复习一下(来自cnblogs) C语言自动转换不同类型的行为称之为隐式类型转换 ，转换的基本原则是：低精度类型向高精度类型转换，具体是： int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; long long -&gt; unsigned long long -&gt; float -&gt; double -&gt; long double 也就是说,long long类型和double比较,long long会被提升至double My code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define R registerusing namespace std;const int N=1005;int t,n,h,r,father[N],size[N];bool top[N],flo[N],flag[N][2];struct ball{ int x,y,z;}a[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } double dist(int x,int y){ long long m1=a[x].x-a[y].x,m2=a[x].y-a[y].y,m3=a[x].z-a[y].z; return sqrt(m1*m1+m2*m2+m3*m3);}int find(int x){ if(father[x]!=x) father[x]=find(father[x]); return father[x];}void merge(int x,int y){ x=find(x),y=find(y); if(x==y) return; if(size[x]&gt;size[y]) swap(x,y); size[y]+=size[x]; father[x]=y;}int main(){ t=read(); for(R int i=1;i&lt;=t;i++) { n=read(),h=read(),r=read(); memset(top,0,sizeof(top)); memset(flo,0,sizeof(flo)); for(R int j=1;j&lt;=n;j++) { father[j]=j;size[j]=1; a[j].x=read(),a[j].y=read(),a[j].z=read(); if(a[j].z+r&gt;=h) top[j]=true;//判断元素是否通顶 if(a[j].z-r&lt;=0) flo[j]=true;//判断元素是否通底 } for(R int j=1;j&lt;=n;j++) { for(R int k=j+1;k&lt;=n;k++) { if(dist(j,k)&lt;=2*r) { merge(j,k); } } } memset(flag,0,sizeof flag); for(R int j=1;j&lt;=n;j++) { int fa=find(j); if(top[j]) flag[fa][0]=true; if(flo[j]) flag[fa][1]=true; } bool yes=false; for(R int j=1;j&lt;=n;j++) { if(flag[j][0]&amp;&amp;flag[j][1]) { printf(&quot;Yes\\n&quot;); yes=true; break; } } if(!yes) printf(&quot;No\\n&quot;); } return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】字符串哈希(入门)","text":"前言: 本文介绍了字符串哈希,并带有几道入门题目. 字符串哈希什么是字符串哈希字符串哈希与一个数字建立对应关系,用于字符串的判重,效验. 在字符串哈希的过程中,如果字符串太长,可能出现多个字符串对应同一个数的情况,称作哈希冲突.为了避免哈希冲突,需要选择合适的模数与基数(通常为质数). 基础做法实现方法:hash[i]=(hash[i-1]*base+s[i])%p 这里的base被称为基数,p被称为模数. 在这个过程中,hash[i]可能会超int范围,因此一般将其的数据类型设置为long long. 进阶做法自然溢出法: 将hash[i]的设置类型设置为unsigned long long,利用无符号类型的自然溢出规则,省去%p的过程. 双哈希: 对一个字符串用2对不同的模数与基数操作,得到hash[1],hash[2].&lt;hash[1],hash[2]&gt;便是最终的哈希值. 防止生成数据卡哈希/哈希冲突 自然溢出法的模数(18446744073709551615)虽然不是质数,但够大,因此选用自然溢出法. 双哈希,冲突率可看作单哈希冲突率的平方. 随机base法 来自https://www.luogu.com.cn/problem/solution/P4503中lyyi03的题解. 设$pw_i=base^i$，则传统哈希的哈希值$hash=\\sum pw_i*s[i]$，但我这里的哈希是将$pw_i$换成一个long long范围内的随机数，这样就可以防卡哈希了． 题目P3370 【模板】字符串哈希My code: 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=1e4+5,mod=1e9+7,base=131;int n,ans;ll a[N];string s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; int len=s.length(); for(int j=0;j&lt;len;j++) { a[i]=(a[i]*base+(ll)s[j])%mod; } } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]==a[i+1]) ans++; } cout&lt;&lt;n-ans; return 0;} P4305 [JLOI2011]不重复数字HINT: 使用vector判重 My code: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n,hash_num=50021,t,temp;vector&lt;int&gt; a[50022];int main(){ ios::sync_with_stdio(false); //快速读入 cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; memset(a,0,sizeof(a));//重置hash表 for(int j=1;j&lt;=n;j++) { cin&gt;&gt;temp;//输入当前数据 int hash=temp%hash_num;//hash过程 bool pd=false; if(a[hash].empty()==false) { for(int k=0;k&lt;a[hash].size();k++) { if(a[hash][k]==temp)//判断hash表中是否有当前元素 pd=true; } } else if(pd==false) { a[hash].push_back(temp);//如果hash表中没有,加入hash表并输出 printf(&quot;%d &quot;,temp); } } printf(&quot;\\n&quot;); }} P4503 [CTSC2014]企鹅QQHINT: 不得不说hzwer的代码真是太强了,就借鉴了一下. 在他的代码中,使用了自然溢出法,并有类似双哈希的方法防止被卡. Bugs: #define ll unsigned long long后误打了分号 B1和B2过小(三十几),被hack掉了3个点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;const int N=3e4+5,B1=149,B2=137;int n,l,s,ans;ll H1[N][205],H2[N][205],t[N];char qq[205];void cal(int x){ for(int i=1;i&lt;=l;i++) H1[x][i]=H1[x][i-1]*B1+qq[i]; for(int i=l;i&gt;=1;i--) H2[x][i]=H2[x][i+1]*B2+qq[i];}int main(){ cin&gt;&gt;n&gt;&gt;l&gt;&gt;s; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,qq+1); cal(i); } for(int i=1;i&lt;=l;i++) { for(int j=1;j&lt;=n;j++) { t[j]=H1[j][i-1]*233+H2[j][i+1]*213; } sort(t+1,t+n+1); int now=1; for(int j=1;j&lt;n;j++) { if(t[j]!=t[j+1]) now=1; else { ans+=now; now++; } } } printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/02/23/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】快速读写相关","text":"快速读入最基础版本，主要思想是一个一个读入12345678910111213141516int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v1 这个版本很好理解,可以加上inline快一点 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(!isdigit(c)) { if(c=='-') s=-s; c=getchar(); } while(isdigit(c)) { a=a*10+c-'0'; c=getchar(); } return s*a;}//v2 最后加上位运算以及手写isdigit函数 12345678910111213141516inline int read(){ int s=1,a=0; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if(c=='-') s=-s; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { a=(a&lt;&lt;1)+(a&lt;&lt;3)+(ch^48); c=getchar(); } return s*a;}//v3","link":"/2020/05/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/"},{"title":"【专题】快速幂(含矩阵快速幂)","text":"本文介绍了快速幂与矩阵快速幂,并实现了简单运用. 前言: 矩阵快速幂就是缝合怪 快速幂这篇文章写的真心好啊,%%%.其实在理解其它的算法时,用纸笔推导每一步在干什么,也能达到差不多的理解程度,所以一定要耐心. 首先给一个幂运算:a p a^p ap在代码实现中,实现p次方的复杂度为 O ( p ) O(p) O(p).我们考虑缩减指数,若p是偶数,则 a p = ( a ∗ a ) p 2 a^p=(a*a)^{\\frac p 2} ap=(a∗a)2p​.只进行了一次乘法运算,却将指数缩减到了原来的二分之一(这也是为什么快速幂的复杂度是 l o g n log\\ n logn). 有了想法,我们再看能不能实现.由唯一分解定理得:整数 m = ∏ a i p i = ∏ a i 2 k + n = ∏ ( a i 2 k ) 1 ( a i n ) 1 m=\\prod a_i^{p_i}=\\prod a_i^{2k+n}=\\prod (a_i^{2k})^1(a_i^{n})^1 m=∏aipi​​=∏ai2k+n​=∏(ai2k​)1(ain​)1,也就是说,m可分解为若干个幂次为1的数的乘积(好像是废话),那么,在缩减指数的时候,若 p m o d 2 = = 1 p\\ mod \\ 2==1 pmod2==1,ans*=a即可. 初步代码： 123456789101112131415ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;1) { if(p%2==1) { ans=(ans*a)%mod; } p/=2; a=(a*a)%mod; } ans=(ans*a)%mod; return ans;} 优化代码: 1234567891011ll fpm(ll a,ll p,ll mod){ ll ans=1; while(p&gt;=1) { if(p&amp;1) (ans*=a)%=mod; p&gt;&gt;=1; (a*=a)%=mod; } return ans;} 分析while循环,每次做的事为p&gt;&gt;=1和(a*=a)%=mod,结束条件为p&gt;=1,可将其改写为for循环节省行数 1234567ll fpm(ll a,ll p,ll mod){ ll ans=1; for(;p;p&gt;&gt;=1,(a*=a)%=mod) if(p&amp;1) (ans*=a)%=mod; return ans;} 注意(a*=a)%=mod)是在if(p&amp;1) (ans*=a)%=mod;后执行的. 矩阵快速幂矩阵乘法已经在线性代数中提到了.顾名思义,矩阵快速幂用于解决诸如 A p A^p Ap的问题,为什么会用到一个矩阵的幂呢?我们先来回顾斐波那契数列 f n = f n − 1 + f n − 2 f_n=f_{n-1}+f_{n-2} fn​=fn−1​+fn−2​,这个简单的递推式在数据规模为1e7时能轻松通过,但到了1e8便很危险了.这时候矩阵便派上用场了. 斐波那契数列的第n项有通项公式 F n = ( 5 + 1 2 ) n − ( 5 − 1 2 ) n 5 F_n= \\frac {(\\frac {\\sqrt{5}+1} {2})^n-(\\frac{\\sqrt{5}-1}{2})^n } {\\sqrt 5} Fn​=5 ​(25 ​+1​)n−(25 ​−1​)n​,但对精度要求极高,不适用.但我们能不能构造一个类似的通项公式,只不过求出的是一个矩阵呢? 可能你会疑惑,为什么要求一个矩阵呢?请看 [ f n f n − 1 ] \\begin{bmatrix}f_n\\\\f_{n-1}\\end{bmatrix} [fn​fn−1​​],这是不是一个矩阵?求出的是不是斐波那契数列?这样,我们的矩阵、快速幂与递推便有机统一了.现在到了在做题时最有思维难度的部分:构造矩阵.思考: [ f [ i ] f [ i − 1 ] ] = [ a b c d ] × [ f [ i − 1 ] f [ i − 2 ] ] \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}a&amp;b\\\\c&amp;d\\end{bmatrix}\\times\\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[ac​bd​]×[f[i−1]f[i−2]​]第一个矩阵该填什么?首先它肯定是长这个样子的,也就是要找出a,b,c,d满足a × f [ i − 1 ] + b × f [ i − 2 ] = f [ i ] a\\times f[i-1]+b\\times f[i-2]=f[i] a×f[i−1]+b×f[i−2]=f[i] c × f [ i − 1 ] + d × f [ i − 2 ] = f [ i − 1 ] c\\times f[i-1]+d\\times f[i-2]=f[i-1] c×f[i−1]+d×f[i−2]=f[i−1] c=1,d=2是显然的,a和b等于多少呢?但观察形式,它不就是最基本的斐波那契递推式吗? 于是就有了: f [ i ] = 1 × f [ i − 1 ] + 1 × f [ i − 2 ] (1) \\tag 1f[i]=1\\times f[i-1]+1\\times f[i-2] f[i]=1×f[i−1]+1×f[i−2](1) f [ i − 1 ] = 1 × f [ i − 1 ] + 0 × f [ i − 2 ] (2) \\tag 2f[i-1]=1\\times f[i-1]+0\\times f[i-2] f[i−1]=1×f[i−1]+0×f[i−2](2)由(1)(2)发现式(3)[ f [ i ] f [ i − 1 ] ] = [ 1 1 1 0 ] × [ f [ i − 1 ] f [ i − 2 ] ] (3) \\tag 3 \\begin{bmatrix}f[i]\\\\f[i-1]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}\\times \\begin{bmatrix}f[i-1]\\\\f[i-2]\\end{bmatrix} [f[i]f[i−1]​]=[11​10​]×[f[i−1]f[i−2]​](3)ohhhhhhh!构造出来了!剩下的不就简单多了吗,根据式(3)归纳出式(4)[ f [ n + 1 ] f [ n ] ] = [ 1 1 1 0 ] n − 1 × [ f [ 2 ] f [ 1 ] ] (4) \\tag 4 \\begin{bmatrix}f[n+1]\\\\f[n]\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}^{n-1}\\times \\begin{bmatrix}f[2]\\\\f[1]\\end{bmatrix} [f[n+1]f[n]​]=[11​10​]n−1×[f[2]f[1]​](4)至此,我们已经完成了”构造一个矩阵的通项公式”的任务了,可以编写代码了. 接下来该考虑的事情是如何将矩阵乘法运算套入快速幂,在快速幂的求解中,即将 a p a^p ap拆分成若干个幂次为1的数的乘积,只用到了结合律,显然其对矩阵乘法的运算也是成立的.(其实在这里也满足交换律,毕竟全都是同一个矩阵A).那么我们直接将快速幂中涉及到乘法的部分换为矩阵乘法即可. 12345void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);} 封装了一个矩阵板子,支持乘法操作(我居然自己造了一个板子,太不可思议了) 123456789101112131415161718struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }}; P3390 【模板】矩阵快速幂 索然无味的AC代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=n;j++) (g[i][j]+=s*b.g[k][j])%=mod; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a)) if(p&amp;1) ans.mul(a);}int main(){ cin&gt;&gt;n&gt;&gt;k; matrix a; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;a.g[i][j]; } } matrix ans; //构造单位矩阵 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i==j) ans.g[i][j]=1; else ans.g[i][j]=0; } } fpm_mat(ans,a,k); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { cout&lt;&lt;ans.g[i][j]&lt;&lt;' '; } cout&lt;&lt;endl; } return 0;} 这里涉及到一个叫做单位矩阵(identity matrix)的东西,就是主对角线上元素全为1的矩阵. I × A = A I\\times A=A I×A=A. 好了,回到我们的斐波那契数列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int N=105,mod=1e9+7;ll n,k;struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt() { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};void fpm_mat(matrix &amp;ans,matrix a,ll p){ for(;p;p&gt;&gt;=1,a.mul(a,2,2)) if(p&amp;1) ans.mul(a,2,2);}int main(){ cin&gt;&gt;n; if(n==1) { cout&lt;&lt;1; return 0; } matrix a,idt; idt.idt(); a.g[1][1]=1,a.g[1][2]=1,a.g[2][1]=1,a.g[2][2]=0; fpm_mat(idt,a,n);//结果存在idt里 matrix f; f.g[1][1]=1,f.g[2][1]=1; idt.mul(f,2,1); cout&lt;&lt;idt.g[2][1]; return 0;} 代码虽然AC了,但是因为状态不好,写的极度糟糕. 改进了一下板子,增加了idt构造单位矩阵功能: 1234567891011121314151617181920212223242526struct matrix{ ll g[N][N]; void mul(matrix b,int n,int m) { matrix a; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a.g[i][j]=g[i][j],g[i][j]=0; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=n;k++) { int s=a.g[i][k]; for(int j=1;j&lt;=m;j++) (g[i][j]+=s*b.g[k][j])%=mod; } } void idt(int n) { for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i==j) g[i][j]=1; else g[i][j]=0; }};","link":"/2021/02/03/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82(%E5%90%AB%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82)/"},{"title":"【专题】扩展欧几里得算法(exgcd)","text":"前言：本文介绍了扩展欧几里德算法，并给出了算法模版 欧几里得算法首先我们来回顾一下求解2个数的最大公约数(gcd,Greatest Common Divisor)的欧几里得算法:这个算法的核心是$gcd(a,b)=gcd(b,a \\ mod \\ b)$,即$a$和$b$的公约数等于$b$和$a \\ mod \\ b$的公约数.至于为什么,oi-wiki上有,我们就不证了,但为了理解这个公式,我们举个例子$$gcd(3,5)=gcd(5,3)=gcd(2,3)=gcd(3,2)=\\gcd(1,2)=gcd(2,1)=gcd(1,1)=gcd(0,1)=gcd(1,0)$$然后你会发现,我们将要用1去模0了,但这显然是没有意义的*(a模b的定义为a除以b的余数).并且,1和0是没有公约数的(0没有任何约数),那么我们的程序好像就无法继续进行了.我们又观察到,5和3因为互质,最大公约数是1,恰好是当b=0的时候a的值.那么,其他的数进行gcd操作也会有这样的性质吗? 再来个例子$$gcd(4,2)=gcd(0,2)=gcd(2,0)$$好像确实是这样的!我们只需输出当b等于0时a的值即可! 实际上,当b=0时,就代表着前一步的a%b==0,也就是$b|a$,那么我们的最大公约数显然就是b(下一步的a)了. *如果你编译运行1%0这段代码,编译器报错[Warning] division by zero [-Wdiv-by-zero],程序RE 这样就可以写出代码: 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); } 在进入下一部分前,我们先来分析一下这个算法的复杂度.细心的读者已经发现了,上面的例子中有些操作是无效的,他们仅仅交换了a和b的位置,但对于程序运行来说,这是必需的.但他们的数量显然小于等于有效操作的数量,对于时间复杂度的分析来说可以略去. 回顾到取模这个运算,在正数意义下它的代码可以写成这样(你是否知道负数的取模运算?可以参考这篇文章): 1while(a&gt;b) a-=b//=a%b 实际上,G++中实现的取模不是这么简单.具体来说,若$a=qb+r$,则$a \\ mod \\ b=r$(例:7%(-3)=1 -7%(-3)=-1 -7%3=-1).并且,G++的原则是使商尽可能大有点扯远了,最重要的是知道上面在正数意义下的代码!我们再来举几个例感性理解一下复杂度不用感性理解了,请读者们自己思考吧,我直接说结论好了,gcd中的有效操作至少能让a减半. 那么,gcd的复杂度就为$log \\ n$ 补充知识: 多个数的最大公约数/最小公倍数求法:每次取出2个数求得最大公约数/最小公倍数后将最大公约数/最小公倍数放回去 算数基本定理(用于求lcm,Least Common Multiple,最小公倍数):$gcd(a,b) \\times lcm(a,b)=a \\times b$ 扩展欧几里德算法(exgcd)恶心gcd 扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求$ax+by=gcd(a,b)$的一组可行解。 P.S 原来extra指额外,extend才是扩展…定理:$x_1=y_2,y_1=x_2-\\lfloor \\frac a b \\rfloor$证明(摘自oi-wiki,但手写一遍才能更好的弄懂): 设$ax_1+by_1=\\gcd(a,b)$$bx_2+(a\\bmod b)y_2=\\gcd(b,a\\bmod b)$由欧几里得定理可知： $\\gcd(a,b)=\\gcd(b,a\\bmod b)$所以 $ax_1+by_1=bx_2+(a\\bmod b)y_2$又因为 $a\\bmod b=a-(\\lfloor\\frac{a}{b}\\rfloor\\times b)$所以 $ax_1+by_1=bx_2+(a-(\\lfloor\\frac{a}{b}\\rfloor\\times b))y_2$$ax_1+by_1=ay_2+bx_2-\\lfloor\\frac{a}{b}\\rfloor\\times by_2=ay_2+b(x_2-\\lfloor\\frac{a}{b}\\rfloor y_2)$因为 $a=a,b=b$ ，所以 $x_1=y_2,y_1=x_2-\\lfloor\\frac{a}{b}\\rfloor y_2$ 证明中比较重要的就是这个式子(其实就是取模运算的数学表达式):$$a \\ mod \\ b=a-\\lfloor \\frac a b \\rfloor \\times b$$知道了$x$和$y$的递归表达式,我们就可以进行程序设计了. 既然是递归,就一定有最底层的$x$和$y$能够让我们轻易求出值,回到基础gcd算法的递归结束位置,$a_{now}=gcd(a,b),b_{now}=0$,带入$ax+by=gcd(a,b)$,得${gcd(a,b)} \\times x +0 \\times y=gcd(a,b)$ 那么显然$x$取1,$y$取任意值即可(我们选择取0). 考虑到在源代码上修改,我们仍然返回gcd的值,在过程中计算x和y即可. 代码: 12345678910111213int exgcd(int a,int b,int &amp;x,int &amp;y){ if(b==0) { x=1,y=0; return a; } int ret=exgcd(b,a%b,x,y); int temp=x; x=y; y=temp-(a/b)*y; return ret; }","link":"/2021/01/31/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95(exgcd)/"},{"title":"【专题】拉格朗日插值(入门)","text":"本文介绍了拉格朗日插值法,并给出了模版代码. 拉格朗日插值法可构造一个经过任意n个点的函数f $拉格朗日插值法可构造一个经过任意n个点(a_1,b_1),(a_2,b_2),(a_3,b_3),\\dots,(a_n,b_n)的函数f,设f=f_1+f_2+\\dots+f_n,需要让f_1,f_2,\\dots,f_n均经过这n个点,且当x=a_i时,f_i=b_i;当x=a_j(j \\ne i)时,f_i=0.$ $那么显然,由f_1,f_2,\\dots,f_n相加得到的的f,恰好经过了a_1,a_2,\\dots,a_n.$$f_1,f_2,\\dots,f_n被称为拉格朗日基函数,表达式为:f_i=b_i\\prod_{j\\ne i} \\frac {x-x_j} {x_i-x_j}$ $那么,由拉格朗日插值法得到的函数f的表达式为:\\sum_{i=1}^{n}b_i\\prod_{j\\ne i} \\frac{x-x_j} {x_i-x_j},时间复杂度为O(n^2).$ $若在程序实现中,每一次计算x_i-x_j值时都求一次其的乘法逆元,时间复杂度将乘上log\\ n,我们选择先计算所有x_i-x_j的乘积,再求逆元.$ 另外,此处求逆元必须选择快速幂方法,否则你将陷入深深的迷惑中.为什么呢?在此题中,可能会需要求负数的逆元,但根据辗转相除法求负数和-1的最大公约数时,求得的最大公约数为-1(在cmath库函数__gcd中计算也会得到-1,可见其运用的是辗转相除法).可是在数学定义上,gcd(a,b)=gcd(|a|,|b|),也就是说负数和-1的最大公约数为1.贝祖等式ax+by=gcd(a,b)的gcd(a,b)显然是数学定义上的.那么便不能得到ax+by=1,或者说我们算的其实是ax+by=-1,完全错误了.(我在这个问题上困扰了接近1个小时TAT) 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,k,x[2005],y[2005],mod=998244353,ans;//998244353是个题目常用取模质数 ll fpm(ll x,ll power,ll mod) { x %= mod; ll ans = 1; for (; power; power &gt;&gt;= 1,(x*=x)%=mod) if(power&amp;1) (ans*=x)%=mod; return ans;}ll inv(ll x){ return fpm(x,mod-2,mod);}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x[i]&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++) { ll ans_up=y[i],ans_down=1; for(int j=1;j&lt;=n;j++) { if(j==i) continue; ans_up=(ans_up*(k-x[j]))%mod; ans_down=(ans_down*(x[i]-x[j]))%mod; } ans=(ans+(ans_up*inv(ans_down)))%mod; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0;}","link":"/2021/02/02/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC(%E5%85%A5%E9%97%A8)/"},{"title":"【专题】最小生成树","text":"最小生成树最小生成树就是在一个图中寻找一个联通图,必须包含原图的所有节点,且这个图的所有边的权值和最小.为什么是一个树呢?因为只要求联通,就一定没有环,没有环不就是树了嘛! Kruskal算法Kruskal算法的核心是加边和判环.一条一条把边加上,如果加上会形成环就不加,最后弄成一个连通图. 假设有n个节点,就需要加(n-1)条边.为什么呢?因为每加上一条边,就会多连接一个点.因为是要求最小生成树,所以先将所有边权值从小到大排序,挨个加边,加完的值一定是最小的.判环主要用并查集实现,若两个节点的祖先不同,则加边后不会形成环,反之会形成环. P3366 【模板】最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,m,p,sum,father[5005];struct Edge{ int x,y,w;}a[200005];int getfather(int);void merge(int,int);bool cmp(const Edge &amp;a,const Edge &amp;b);int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) father[i]=i; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].w; } sort(a+1,a+m+1,cmp); int k=0; for(int i=1;i&lt;=m;i++) { if(getfather(a[i].x)!=getfather(a[i].y)) { ++k; merge(a[i].x,a[i].y); sum+=a[i].w; } if(k==n-1) break; } cout&lt;&lt;sum; return 0;}int getfather(int v){ if(father[v]!=v) father[v]=getfather(father[v]); return father[v];} void merge(int a,int b){ father[getfather(a)]=getfather(b);}bool cmp(const Edge &amp;a,const Edge &amp;b){ return a.w&lt;b.w; } Prim算法核心:加点(未完待续)","link":"/2020/01/20/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"title":"【专题】递推","text":"** 水水水水水** 问题 A: 铺瓷砖题目描述用红色的 1×1 和黑色的 2×2 两种规格的瓷砖不重叠地铺满 n×3 的路面，求出有多少种不同的铺设方案。 输入一行一个整数 n，0&lt;n&lt;1000。 输出一行一个整数，为铺设方案的数量模12345的结果。 1:1 2:3 4:5 5:11 也就是2n+1,2n-1滴规律 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;int n,ans=1; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; if\\(n==1\\) cout\\&lt;\\&lt;ans; else \\{ for\\(int j=2;j\\&lt;=n;j++\\) \\{ if\\(j\\%2==0\\) \\{ ans=ans\\*2+1; \\} else \\{ ans=ans\\*2-1; \\} ans\\%=12345; \\} \\} cout\\&lt;\\&lt;ans; return 0; } 问题 B: 彩带题目描述 一中 90 周年校庆，小林准备用一些白色、蓝色和红色的彩带来装饰学校超市的橱窗，他希望满足以下两个条件： (1) 相同颜色的彩带不能放在相邻的位置； (2) 一条蓝色的彩带必须放在一条白色的彩带和一条红色的彩带中间。 现在，他想知道满足要求的放置彩带的方案数有多少种。例如，如图 所示为橱窗宽度n=3 的所有放置方案，共 4 种。 输入一行一个整数 n，表示橱窗宽度(或者说彩带数目)。 输出一行一个整数，表示装饰橱窗的彩带放置方案数。 样例输入 Copy3 样例输出 Copy4 提示对 30% 的数据满足：1≤n≤15。 对 100% 的数据满足：1≤n≤45。 斐波那契数列,但前两项都是2 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;int n,f[50]; int main(){ ios::sync_with_stdio(false); f\\[1\\]=f\\[2\\]=2; cin&gt;&gt;n; for\\(int j=3;j\\&lt;=n;j++\\) \\{ f\\[j\\]=f\\[j-1\\]+f\\[j-2\\]; \\} cout\\&lt;\\&lt;f\\[n\\]; return 0; } 1389: 城市路径题目描述地图上有 n 个城市，一只奶牛要从 1 号城市开始依次经过这些城市，最终到达 n 号城市。但是这只奶牛觉得这样太无聊了，所以它决定跳过其中的一个城市(但是不能跳过 1 号和 n 号城市)，使得它从 1 号城市开始，到达 n 号城市所经过的总距离最小。假设每一个城市 i 都有一个坐标(x i ，y i )，从 (x 1 ，y 1 ) 的城市 1 到 (x 2 ，y 2 ) 的城市 2 之间的距离为 | x 1 -x 2 | + | y 1 -y 2 | 。 输入第 1 行 1 个正整数 n，表示城市个数。 接下来的 n 行，每行 2 个数 x i 和 y i ，表示城市 i 的坐标。 输出一行一个数，使得它从1号城市开始，跳过某一个城市，到达n号城市所经过的最小总距离。 样例输入 Copy40 08 311 -110 0 样例输出 Copy14 提示【样例说明】 跳过 2 号城市。 【数据规模】 对于 40% 的数据满足：n≤1000。 对于 100% 的数据满足：3≤n≤100000，-1000≤x i ，y i ≤1000。 pz:这不是枚举吗? #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;int n,x[100005],y[100005],maxx,tot; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=2;i&lt;=n;i++) { tot+=abs(x[i-1]-x[i])+abs(y[i-1]-y[i]); } for(int i=2;i&lt;n;i++) { int save=(abs(x[i-1]-x[i])+abs(y[i-1]-y[i])+abs(x[i+1]-x[i])+abs(y[i+1]-y[i]))-(abs(x[i-1]-x[i+1])+abs(y[i-1]-y[i+1])); if(save&gt;0&amp;&amp;save&gt;maxx) maxx=save; } cout&lt;&lt;tot-maxx; return 0; } 2020/3/28 20:21 歇息一下 问题 D: 偶数个3题目描述编程求出所有的 n 位数中，有多少个数中有偶数个数字 3。 输入一行一个正整数 n，0&lt;n&lt;1000。 输出一行一个正整数，表示 n 位数中有多少个数有偶数个 3，这个数可能会很大，请输出它%12345的值。 样例输入 Copy2 样例输出 Copy73 2020/3/28 22:10 1408: 数塔问题题目描述设有一个三角形的数塔，顶点为根结点，每个结点有一个整数值。从顶点出发，可以向左走或向右走，如图所示： 若要求从根结点开始，请找出一条路径，使路径之和最大，只要输出路径的和。 输入第一行为n(n&lt;10)，表示数塔的层数 从第2行至n+1行，每行有若干个数据，表示数塔中的数值。 输出输出路径和最大的路径值。 样例输入 Copy51311 812 7 266 14 15 812 7 13 24 11 样例输出 Copy86 pz:dpdpdp #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;int n,f[15][15],a[15][15],ans; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ for\\(int j=1;j\\&lt;=i;j++\\) \\{ cin&gt;&gt;a\\[i\\]\\[j\\]; \\} \\} f\\[1\\]\\[1\\]=a\\[1\\]\\[1\\]; for\\(int i=2;i\\&lt;=n;i++\\) \\{ for\\(int j=1;j\\&lt;=i;j++\\) \\{ f\\[i\\]\\[j\\]=max\\(f\\[i-1\\]\\[j-1\\],f\\[i-1\\]\\[j\\]\\)+a\\[i\\]\\[j\\]; \\} \\} for\\(int i=1;i\\&lt;=n;i++\\) \\{ if\\(f\\[n\\]\\[i\\]&gt;ans\\) ans=f\\[n\\]\\[i\\]; \\} cout\\&lt;\\&lt;ans; return 0; }","link":"/2020/03/28/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E9%80%92%E6%8E%A8/"},{"title":"【专题】线性动态规划","text":"线性DP1. 最长上升(不下降)子序列 O(n^2)的基础算法,如果是不下降只用把f[i]&lt;f[j]改成f[i]&lt;=f[j] 方程:f[i]=max(f[j]+1) j∈i+1~n了 ps:每个位置的初始长度都是1!!!! 1234567891011121314151617181920212223242526272829303132333435363738//最长上升序列#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std;int n,a[5005],f[5005]; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; f[i]=1; }// f[n]=1;每个位置都是1 for(int i=n-1;i&gt;=1;i--) { for(int j=i+1;j&lt;=n;j++) { if(a[i]&lt;a[j]) f[i]=max(f[i],f[j]+1); } } int ans=0; for(int i=1;i&lt;=n;i++) { ans=max(ans,f[i]); } cout&lt;&lt;ans; return 0;} O(n*logn)的进阶算法,主要思想是贪心和二分导弹拦截 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100005],p,f[100005],k=0;int main(){ while(cin&gt;&gt;a[p]) { p++; } f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&lt;=f[k]) { f[++k]=a[i]; } else { int x=upper_bound(f,f+k,a[i],greater&lt;int&gt;())-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; k=0; memset(f,0,sizeof(f)); f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&gt;f[k]) { f[++k]=a[i]; } else { int x=lower_bound(f,f+k,a[i])-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; return 0; } 主要是贪心思想,对于每个a[i],如果a[i]&gt;f[end],a[i]就接在f[end]; 反之,替换掉f数组中大于a[i]的最小的(upper_bound(f.begin,f.end,a[i])) 不好严格证明,如下为示例: 样例: 121413 7 9 16 38 24 37 18 4 19 21 22 63 15 过程: 1234567891377 97 9 16 387 9 16 247 9 16 187 9 16 18 197 9 16 18 19 21 22 637 9 15 18 19 21 22 63 2. 最长公共子序列(LCS) 给定一个序列X=&lt;x1,x2,x3,x4...,xm&gt;，另一个序列Z=&lt;z1,z2,z3,z4...,zk&gt;，若存在一个严格递增的X的下标序列&lt;i1,i2,i3,…,ik&gt;对所有的1,2,3,…,k，都满足x(ik)=zk，则称Z是X的子序列 比如Z=&lt;B,C,D,B&gt;是X=&lt;A,B,C,B,D,A,B&gt;的子序列 方程:f(i,j)={f[i-1,j-1](a[i]=a[j]),max(f[i-1][j],f[i][j-1])(a[i]≠a[j]} 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;char a[205],b[205];int f[205][205]; int main(){// ios::sync_with_stdio(false); scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); strlen() int lena=strlen(a+1),lenb=strlen(b+1);//从下标1开始计算长度 size t cdecl strlen (const char Str) for(int i=1;i&lt;=lena;i++) { for(int j=1;j&lt;=lenb;j++) { if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); } } cout&lt;&lt;f[lena][lenb]; return 0;} 最经典的是这个图","link":"/2020/05/24/%E3%80%90%E4%B8%93%E9%A2%98%E3%80%91%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【小记】CSP-J2019游记&amp;解题报告","text":"考前一天晚上失眠…….(其实主要不是因为考试的原因) 很幸运,我们学校就是一个考点,本场作战,应该有一点加持吧. 上午在家复习,看到一篇关于PN532模拟小米手环加密卡的文章,于是,,,,,,,,你们懂的,荒废了. 下午1点过正式出征,在熟悉的学校排了一会,碰到几个同学,甚至还有小学同学! 2点半开考,先让我们看了10分钟卷子,我说这个完善程序第二题怎么这么简单啊(大雾),结果最后做自闭了…. 选择题出奇简单,事实证明我全对.而且,**一个基础知识题都没有!**CCF真的是大刀阔斧的改革! 读程序没什么可说的,逼疯众考生第二题只试了几组数据就写出来了,错了一个判断. 就是这道: 看样子是数据试少了(雾*2) 实际上你看看这答案解析不是在试数据是在干嘛!要不然谁搞得懂CCF出的鬼题是什么意思! 阅读程序第三道的最后一题,简直跪了,考场上猜了D 实际上我的思路是对的.最好的情况,也就是输出最小,就是每次都2分. 100 个节点的每层节点数量就是 （1,2,4,8,16,32,37）分别乘对应权值即可 1+4+12+32+80+192+259 但是,我天真的列出来1,2,4,8,16,32,64,算出来600多,呵呵… 完善程序第一道,简单,全对. 但这个思路清奇,加上位运算的使用,可以学习一下. 最后来说说完善程序第二道,难哭 重了几层数组,出题人不数数的吗!!!!! 好了,来说说正解. 我们先抛开双关键字,看看单关键字,最普通的基数排序. 找到一篇很好的文章:https://www.itcodemonkey.com/article/11750.html 这里是计数排序算法演示 : 还有网上找的代码: #include &lt;iostream&gt; #include &lt;stdio.h&gt;using namespace std; void COUNTINGSORT(int *A,int *B,int len,int k){ if(A == NULL || k &lt;= 0 || len &lt;= 0){ return; } int C[k+1],i; //初始化 for(i = 0;i &lt;= k;i++){ C[i] = 0; } //统计值为A[i]的个数,C[i]是等于i的元素个数 for(i = 0;i &lt; len;i++){ C[A[i]] ++; }//标记1 //确定值A[i]在最终输出数组B中位置,C[i]是小于等于i的元素个数 for(i = 1;i &lt;= k;i++){ C[i] += C[i-1]; } //输出到数组B中 for(i = len-1;i &gt;= 0;i–){ //index元素A[i]在数组B中的下标 int index = C[A[i]]; B[index] = A[i]; //如果有相同值元素的情况 C[A[i]] –; } //B下标从1开始} int main(){ int A[8] = {2,5,3,0,2,3,0,3}; int B[9]; COUNTINGSORT(A,B,8,5); for(int i = 1;i &lt;= 8;i++){ printf(“%d\\n”,B[i]); } return 0;} 在这个地方，其实相当于把程序的标记1做完了，下面的for循环就是在做前缀和,做完后是: 1 3 6 7 7 9 做了前缀和有什么用呢?看下面代码: for(i = len-1;i &gt;= 0;i–){ //index元素A[i]在数组B中的下标 int index = C[A[i]]; B[index] = A[i]; //如果有相同值元素的情况 C[A[i]] –; } 相当于题中的 ord[--cnt[b[i]]] = i 到这里便不难理解了. 最后回到考题双关键字,就是多套了几个数组,没什么区别. 自测分数84，等着出成绩吧，反正四川慢的很。（心里还有一点小激动呢） 最后 复赛good luck! 附2019CSP-J初赛试题及答案 链接: https://pan.baidu.com/s/1FmJHHaYZZSwDC\\_6J7I8x4A\\&amp;shfl=shareset 提取码: u6kv","link":"/2019/10/19/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91CSP-J2019%E6%B8%B8%E8%AE%B0&%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"【小记】2019成都市青少年编程应用挑战赛","text":"今天 2019年12月8日上午 星期日，我参加了一场奇怪的比赛。 网址：https://www.stackedu.com/cd/ 这玩意在成外举行，学校让参加的，我们学校一共去了50个人（直接去考） 2个小时，一共5道。前3道都是水题，第四道是给一个数字串并删除几个数字获得最大的，搜索就行了。第五道考了一个图论，Floyd暴力分拿了。 考试考完感觉很蒙圈，这到底是个什么比赛？网址是小栈教育提供的，举办方又是成都市科学教育协会？？？ 反正干就对了，奥利给！！！","link":"/2019/12/08/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%912019%E6%88%90%E9%83%BD%E5%B8%82%E9%9D%92%E5%B0%91%E5%B9%B4%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E6%8C%91%E6%88%98%E8%B5%9B/"},{"title":"【小记】Contest 210205","text":"在210205的校内测试.包含模拟,动态规划等算法. 题目已存档至硬盘 万能遥控器第一道就是毒瘤模拟,TAT.先不改了,记录一下我的代码和标程吧. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;int n;char ip[100][50],ans[100][50];string s;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}bool special(int &amp;len){ for(int i=0;i&lt;len-2;i++) { if(s[i]==':'&amp;&amp;s[i+1]==':'&amp;&amp;s[i+2]==':') return true; } return false;}void solve(){ for(int j=0;j&lt;100;j++) { for(int k=0;k&lt;50;k++) { ip[j][k]='x'; ans[j][k]='x'; } } cin&gt;&gt;s; int len=s.length(),flag=-1,p=0,p_group=-1; if(special(len)) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } for(int j=0;j&lt;len;j++) { if(j&lt;len-1&amp;&amp;s[j]==':'&amp;&amp;s[j+1]==':') { if(flag==-1) flag=p; else { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } p++; j++; p_group=-1; } else if(s[j]==':') { p++; p_group=-1; } else ip[p][++p_group]=s[j]; } if((p&lt;7&amp;&amp;flag==-1) || p&gt;7 || (p==6 &amp;&amp; flag&gt;=0)) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } for(int j=0;j&lt;=p;j++) { int tot=0; for(int k=0;k&lt;50;k++) { if(ip[j][k]=='x') break; else if((ip[j][k]&gt;='0'&amp;&amp;ip[j][k]&lt;='9') || (ip[j][k]&gt;='A'&amp;&amp;ip[j][k]&lt;='F')) { tot++; } else { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } } if(tot&gt;4) { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } else { for(int k=0;k&lt;4-tot;k++) { ans[j][k]='0'; } for(int k=4-tot;k&lt;4;k++) { ans[j][k]=ip[j][k-4+tot]; } } } for(int j=0;j&lt;=p;j++) { for(int k=0;k&lt;4;k++) { if(ans[j][k]=='x') { cout&lt;&lt;&quot;INVALID\\n&quot;; return; } cout&lt;&lt;ans[j][k]; } if(j!=p) cout&lt;&lt;':'; if(j==flag) { for(int k=1;k&lt;=(7-p);k++) { printf(&quot;0000&quot;);//bug,but solved if(k+j!=7) putchar(':'); } } } cout&lt;&lt;endl;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { solve(); } return 0;} 137行,学OI来写的最多的一次. 标程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;char s[100], a[100];int main(){ freopen( &quot;ipv6.in&quot;, &quot;r&quot;, stdin ); freopen( &quot;ipv6.out&quot;, &quot;w&quot;, stdout ); int n; scanf( &quot;%d\\n&quot;, &amp;n ); for ( int ii = 1; ii &lt;= n; ii++ ) { memset( s, '0', sizeof(s) ); memset( a, '0', sizeof(a) ); char c; int p1 = 0, p2 = 0, p3 = 0, p4 = 0, k = 0, point = 0; while ( (c = getchar() ) != EOF &amp;&amp; c != '\\n' ) { s[++k] = c; if ( c == ':' ) { p1 = 0; p2++; }else p1++; if ( p1 &gt; 4 || p2 &gt; 7 ) p4 = 1; if ( c == ':' &amp;&amp; s[k - 1] == ':' ) { p3++; point = k; } if ( p3 &gt; 1 ) p4 = 1; } if ( !p3 &amp;&amp; p2 &lt; 7 ) p4 = 1; if ( p3 &amp;&amp; p2 == 7 &amp;&amp; point != 2 &amp;&amp; point != k ) p4 = 1; for ( int i = 1; i &lt;= k; i++ ) a[i] = s[k - i + 1]; if ( p4 ) { printf( &quot;INVALID\\n&quot; ); continue; } int q = 0; p1 = 0; for ( int i = 1; i &lt;= k; i++ ) { s[++q] = a[i]; p1++; if ( a[i] == ':' ) { q--; while ( p1 &lt; 5 ) { s[++q] = '0'; p1++; } s[++q] = ':'; p1 = 0; if ( a[i + 1] == ':' ) { while ( p2 &lt;= 7 ) { for ( int j = 1; j &lt;= 4; j++ ) s[++q] = '0'; s[++q] = ':'; p2++; } q--; p1 = 4; } } } for ( int i = 39; i &gt;= 1; i-- ) printf( &quot;%c&quot;, s[i] ); cout &lt;&lt; endl; } return(0);} 收藏钻石这道题很有意思呀,乍一看以为是二分答案,结果要分成2个陈列架.然后想到用一块板子将钻石们分开,左右2边分别二分答案,但这样复杂度是 O ( n 2 l o g n ) O(n^2 log\\ n) O(n2logn).考虑优化,首先第一层枚举板子的循环肯定不能再优化了,难道优化二分答案? 结果真的是优化二分答案,考场上想出了一种DP方案.若 m 表 示 所 有 满 足 a [ i ] − a [ i − m ] ≤ k 的 m 的 最 小 值 , 则 f [ i ] = m a x ( f [ i − 1 ] , m + 1 ) 若m表示所有满足a[i]-a[i-m]\\le k的m的最小值,则\\\\f[i]=max(f[i-1],m+1) 若m表示所有满足a[i]−a[i−m]≤k的m的最小值,则f[i]=max(f[i−1],m+1)然后正向和反向分别DP一次,再插板,即可求出最终答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5;int n,k,s[N],ans,l[N],r[N];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ freopen(&quot;diamond.in&quot;,&quot;r&quot;,stdin); freopen(&quot;diamond.out&quot;,&quot;w&quot;,stdout); n=read(); k=read(); for(int i=1;i&lt;=n;i++) { s[i]=read(); } sort(s+1,s+n+1); l[1]=r[n]=1; l[0]=r[n+1]=0; for(int i=2;i&lt;=n;i++) { int x=l[i-1]; while(s[i]-s[i-x+1]&lt;=k&amp;&amp;i-x&gt;=0) { x++; } l[i]=max(l[i-1],x-1);// cout&lt;&lt;l[i]&lt;&lt;' '; }// cout&lt;&lt;endl; for(int i=n-1;i&gt;=1;i--) { int x=r[i+1]; while(s[i+x-1]-s[i]&lt;=k&amp;&amp;i+x&lt;=n+1) { x++; } r[i]=max(r[i+1],x-1);// cout&lt;&lt;r[i]&lt;&lt;' '; }// cout&lt;&lt;endl; for(int i=0;i&lt;=n;i++) { ans=max(ans,l[i]+r[i+1]); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} sequence最难的一道DP.看了题解,还结合了另外的算法,于是先去把字符串哈希做了. 决定以后hash的mod就用1e9+7和1e7+7,base为131 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=1e4+5,mod=1e9+7,base=131;int n,ans;ll a[N];string s;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s; int len=s.length(); for(int j=0;j&lt;len;j++) { a[i]=(a[i]*base+(ll)s[j])%mod; } } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]==a[i+1]) ans++; } cout&lt;&lt;n-ans; return 0;} 回到这道题,我的思考过程落脚于将数列分开的”切点”.切点前数列的长度一定小于等于切点后数列的长度.然后就开始愉快的正向DFS模拟了,每次可以将剩下没切的数列切下一块,但切的长度,要么是小于等于剩下长度的二分之一,要么是等于剩下的长度(切完).中途会比较本次切的部分与上次切的部分的大小. 一份代码就出炉了: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e3+5,mod=1e9+7;int n,ans;int s[N];bool cmp(const int &amp;l1,const int &amp;r1,const int &amp;l2,const int &amp;r2)//if l1 to r1&gt;l2 to r2{ if(r1-l1&gt;r2-l2) return true; else if(r1-l1==r2-l2) { for(int i=l1;i&lt;=r1;i++) { if(s[i]&lt;s[l2+i-l1]) return false; if(s[i]==s[l2+i-l1]&amp;&amp;i==r1) return false; } return true; } else return false;}void solve(int l,int r,int pre_l,int pre_r){ if(l==r) { (ans+=1)%=mod; return; } if(s[l]==0) return; int pre_size=pre_l-pre_r+1; for(int i=pre_size;i&lt;=((r-l+1)/2);i++) { if(cmp(l,l+i-1,pre_l,pre_r)) solve(l+i,r,l,l+i-1); } if(cmp(l,r,pre_l,pre_r)) { solve(r,r,l,r); }}int main(){ freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%1d&quot;,&amp;s[i]); } solve(1,n,0,0); cout&lt;&lt;ans%mod; return 0;} 首先DFS不是正解DP,复杂度就被卡掉了,其次正确性还出了问题,另外,根本就没考虑到cmp函数会是正解程序优化的着重部分,复杂度Up. 如果复杂度过高,n=10的部分解也有30分,也是个不错的选择,但因为正确性问题,最终只得到了10分. 开始正解分析: 本题的答案需要mod 1e9+7,显然考虑DP求总方案数.定义f[i][j]为取[i,j]为最后一段的总方案数,那么f[i][j]可以由f[k][i-1]转移得到(k&lt;i-1).","link":"/2021/02/05/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Contest%20210205/"},{"title":"【小记】Hello,Hexo!","text":"Welcome to Hexo! 2021/2/21 搭建了在github上的hexo博客!计划将csdn和博客园的所有博客搬过来,并稍微美化一下. 在搭建过程中用到的资料: 超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否 CSDN博客迁移到Hexo(提供格式转换)_huoji555的博客-CSDN博客 超详细Hexo+Github博客搭建小白教程 - 知乎 (zhihu.com)","link":"/2021/02/21/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Hello,Hexo!/"},{"title":"【小记】SSZX集训 Contest 20210203 递推,最小生成树,矩阵快速幂,染色","text":"在210203的测试. 题目已存档至百度网盘 前言: 还行,就是有人AK,令人不爽 方阵(matrix)标程是记录每行每列的染色时间,我的做法是从指令最后往前处理,染色过的就不能再染了.时间复杂度为 O ( n + n m + q ) O(n+nm+q) O(n+nm+q),可以通过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*从后往前排，排过的就锁住不能再排了问题：1、快写居然出问题了 */#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXQ=1e6+5,MAXN=1e3+5;int n,m,q,x[MAXQ],y[MAXQ],z[MAXQ],tot;bool vish[MAXN],visl[MAXN],vis_map[MAXN][MAXN];int ans[MAXN][MAXN];inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s*x;}//void write(int x)//{// if(x&lt;0)// {// x=-x;// putchar('-');// }// else if(x&gt;9)// {// write(x/10);// }// putchar();//}int main(){ freopen(&quot;matrix.in&quot;,&quot;r&quot;,stdin); freopen(&quot;matrix.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); q=read(); const int tot_map=n*m; for(int i=1;i&lt;=q;i++) { x[i]=read();y[i]=read();z[i]=read(); } for(int i=q;i&gt;=1;i--) { int h=y[i]; if(x[i]==1&amp;&amp;vish[h]==false) { for(int j=1;j&lt;=m;j++) { if(vis_map[h][j]==false) { ans[h][j]=z[i]; vis_map[h][j]=true; tot++; } } vish[h]=true; } if(x[i]==2&amp;&amp;visl[h]==false) { for(int j=1;j&lt;=n;j++) { if(vis_map[j][h]==false) { ans[j][h]=z[i]; vis_map[j][h]=true; tot++; } } visl[h]=true; } if(tot==tot_map) break; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { printf(&quot;%d&quot;,ans[i][j]); putchar(' '); } putchar('\\n'); } return 0;} 另外,此题的write函数居然出锅了,应该这么写: 12345678910111213void write(int x){ if(x&lt;0) { x=-x; putchar('-'); } else if(x&gt;9) { write(x/10); } putchar(x%10+48);} 即putchar(x%10+48)不是putchar(`x%10+48`) 坐标系(coordinate)此题为Openjudge那道奶牛散步数据加强版,递推经典题呀.递推关系式为 f n = 2 f n − 1 + f n − 2 f_n=2f_{n-1}+f_{n-2} fn​=2fn−1​+fn−2​.但今天做的时候显然忘记了,于是先搞了一个dfs把前几项算了出来.又因为前几天在接受数学的熏陶,弄了很久的差分表,结果发现根本弄不出来,直接吐血.(其实显然弄不出来,因为答案并不能被表示为多项式) 但好就好在,偶从差分表中看出了规律,最后列出了递推关系式. 另外,这道题数据范围过大,考虑优化. 方案一: 打表 在本机测试了用时: 1231000000000999999966Use Time:16.217000 也就是说,我们将复杂度优化到 1 0 7 10^7 107即可. 我 们 已 经 知 道 了 f n = 2 f n − 1 + f n − 2 , 那 么 显 然 , 要 知 道 f n , 只 用 知 道 f n − 1 和 f n − 2 . 选 择 打 出 所 有 f n 与 f n + 1 ( n = 1 0 7 k , k 为 正 整 数 ) 我们已经知道了f_n=2f_{n-1}+f_{n-2},那么显然,要知道f_n,只用知道f_{n-1}和f_{n-2}.选择打出所有f_n与f_{n+1}(n=10^7k,k为正整数) 我们已经知道了fn​=2fn−1​+fn−2​,那么显然,要知道fn​,只用知道fn−1​和fn−2​.选择打出所有fn​与fn+1​(n=107k,k为正整数) 具体操作如下代码,也是考试时写出来的.打表的数据是用原本的未优化代码生成的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n;ll biao1[1005]={0,627935421,438953224,542068249,329814112,560895073,119554882,817838024,413683704,457693522,548686427,625090930,854797397,507897869,61876493,38377219,305397032,834552550,86754567,509991039,595114395,406847212,670491536,432878314,135680620,898309326,728242939,198112061,177816349,19047210,455754392,852650532,521176598,71125034,245305647,837039919,188113267,56598060,432474979,432717386,87865010,771920945,438742654,288408342,246724129,896686551,339943192,339062029,917394372,746339567,880572807,739796257,59753287,776287897,225152152,836502060,948930900,475746791,722277745,851272656,790561977,985377610,885700761,132420780,835281543,520522277,705708011,107967744,357214655,287632826,452485219,234406704,490642737,105936544,662318372,10700633,44184524,425184700,853280967,501062760,425337376,984713729,821083793,448257541,299730624,956477347,53544543,258784453,686484973,12946211,133711137,828167667,821810848,728440912,992782964,810060630,81297710,592494925,333385653,68086064,999999966};ll biao2[1005]={0,316019740,372654023,224763656,22469312,782122008,34120220,931864090,425814224,323613731,426904732,655133268,419960676,600143856,636422754,404303050,514440356,364914981,228761950,38777592,133257557,122058434,66188449,284201981,606451036,708146069,58038914,491958600,718356299,472529774,855728576,454092882,3075198,128033925,672313652,274523182,685346016,965382417,79327031,70919624,314176084,524093558,507000754,423517629,401454042,306672104,839594331,294033500,29439574,960708835,59713600,296223267,981986607,148291544,877858011,326733601,500718454,694404815,412489057,164309652,746610433,220032885,261585106,940108177,802956593,46695727,852179533,782419693,57729179,975765453,190151629,400743276,947414172,856017108,746680441,337348962,303616399,286766519,671925310,423986587,856516568,213870031,317318877,493679984,182995823,98269674,305866735,16514990,809398153,525848172,231896493,533455685,956438514,294996456,409710864,32400151,771974784,207954764,741176549,835969528};int main(){// freopen(&quot;coordinate.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;coordinate.out&quot;,&quot;w&quot;,stdout); register long long f[3]={3,7}; register long long mod=1e9+7; cin&gt;&gt;n; if(n&lt;=2) { cout&lt;&lt;f[n-1]&lt;&lt;endl; return 0; } if(n&lt;=10000000) { for(register int i=3;i&lt;=n;i++) { f[2]=(2*f[1]+f[0])%mod; f[0]=f[1],f[1]=f[2]; } cout&lt;&lt;f[2]&lt;&lt;endl; } else { int k=n/10000000; n%=10000000; f[0]=biao1[k]; f[1]=biao2[k]; if(n&lt;=1) { cout&lt;&lt;f[n]&lt;&lt;endl; return 0; } for(register int i=2;i&lt;=n;i++) { f[2]=(2*f[1]+f[0])%mod; f[0]=f[1],f[1]=f[2]; } cout&lt;&lt;f[2]&lt;&lt;endl; } return 0;} 方案二: 矩阵快速幂 递推关系式的优化都可以用到矩阵快速幂,前几天讲课时也提到过,我已经写了一篇新的博客来介绍.","link":"/2021/02/03/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91SSZX%E9%9B%86%E8%AE%AD%20Contest%2020210203%20%E9%80%92%E6%8E%A8,%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91,%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82,%E6%9F%93%E8%89%B2/"},{"title":"【小记】Manjaro Linux使用1月滚粗记","text":"每个OIer都有对Linux的向往(雾) 这不,一个月前我便看上了Manjaro,主要原因是因为Manjaro软件包全,安装简便,下面就来说说我退回windows的原因: 1.桌面卡顿,我用的gnome桌面,切换窗口,新建窗口时总是没有windows那种丝滑. 2.软件不全,虽然有QQ,微信,Chrome,但是还是满足不了我的搞机需求 3.资料太少,manjaro的网上资料少的一批,贴吧人都没有 4.使用不便(搞了半天都没弄好C++的调试环境,dock栏还不见了!!!),Linux嘛,大家懂的,我怎么会用呢…… 综上,换回了windows10 LTSB 2016!!!爽!!!!","link":"/2019/10/20/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Manjaro%20Linux%E4%BD%BF%E7%94%A81%E6%9C%88%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"title":"【小记】对ABBYY FineReader功能的探究","text":"ABBYY FineReader,一个强大的PDF阅读器和OCR识别器! 阅读主界面 OCR主界面 资源就不贴了,不过提示一下大家:Google Search 懒 得 勤 快,就可以找到. 经过研究,发现以下几点: 1.可以用此工具代替打印机扫描软件,支持连续扫描,同步OCR 2.OCR识别率挺高,但对公式,表格支持不太好 3.保存格式不要用”可搜索的PDF”,卡的要死 4.电子书只能保存epub格式 5.可发送文档到KINDLE!","link":"/2019/11/02/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E5%AF%B9ABBYY%20FineReader%E5%8A%9F%E8%83%BD%E7%9A%84%E6%8E%A2%E7%A9%B6/"},{"title":"【小记】惨痛の教训","text":"2021/2/2 16:03#3827 The XOR Largest Pair因为乱改了maxn,导致WA91分的代码变成了WA9分,调试了半个小时,终于发现了问题…教训: 一定要把目前得分最多的代码存档! 2021/2/2 19:35gcd(-1,1)=-1(辗转相除法)gcd(-1,1)=1(数学意义上)","link":"/2021/02/02/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%83%A8%E7%97%9B%E3%81%AE%E6%95%99%E8%AE%AD/"},{"title":"【小记】梦开始的地方","text":"明天就是CSP（NOIP）2019年初赛了，我注册了博客园，希望能够以此手段督促自己，更好的成长","link":"/2019/10/18/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"},{"title":"【小记】我的首次AK记","text":"哈哈哈！本蒟蒻终于在今天中午机房测试中AK全场了（其实没啥技术含量，只有5个水题，对，全都很水）","link":"/2019/10/21/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91%E6%88%91%E7%9A%84%E9%A6%96%E6%AC%A1AK%E8%AE%B0/"},{"title":"【杂项】C++程序计时器模版(用于计算某个代码块用时)","text":"12345678910111213#include&lt;time.h&gt;#include&lt;stdio.h&gt;int main(){ double dur; clock_t start,end; start = clock(); foo();//dosomething end = clock(); dur = (double)(end - start); printf(&quot;Use Time:%f\\n&quot;,(dur/CLOCKS_PER_SEC));} 精确到毫秒","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91C++%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E6%A8%A1%E7%89%88(%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97%E7%94%A8%E6%97%B6)/"},{"title":"【杂项】post模版","text":"Des: Sol: My code:","link":"/2021/02/22/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91post%E6%A8%A1%E7%89%88/"},{"title":"【杂项】OI中的C++语法基础&amp;进阶技巧","text":"前言: 写这个的目的主要是为了总结在OI中用到的C++语法奇淫巧技以及在入门的时候没学好的C/C++语言语法部分 数据类型OI中常用的数据类型大小 数据类型 范围 位数 int -2147483648~2147483647 10 unsigned int 0~4294967295 10 long long -9223372036854775808~92233,72036,85477,5807 19 unsigned long long 0~18446744073709551615 20 总之,9位数能安全地用int存下,18位数用long long,19位数或是 2 64 2^{64} 264以内用unsigned long long. 另外,合理利用unsigned类型的自动溢出机制可以实现取模运算中的骚操作–快速乘. 输入输出相关(printf,cout)关于printf菜鸟教程已经讲得很详细了,下面给出几个实例: 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ printf(&quot;%-6d\\n&quot;,3); printf(&quot;%+06d\\n&quot;,3); printf(&quot;%010.2f\\n&quot;,32434.434); unsigned long long a=1; for(int i=1;i&lt;=64;i++) a*=2; a--; printf(&quot;%llu&quot;,a); return 0;} 输出: 12343+000030032434.4318446744073709551615 结构体(struct)结构体以前比较常用的是带结构体排序,就不再提及.高阶技巧便是把结构体当作一个简单版class用,可以封装一些函数,结构体中的运算符重载也能节约不少时间. 初始化 12345678910111213141516171819202122struct test{ int a,b,c; test(int p,int q) { a=p,b=q; } test(char s) { c=s-'A'; }};int main(){ test a=test(3,5); test b(3,5); test c('A'); cout&lt;&lt;a.a&lt;&lt;' '&lt;&lt;b.b&lt;&lt;' '&lt;&lt;c.c; return 0;} 输出: 13 5 0 简单来讲就是让新建一个结构体变量的操作变方便了 运算符重载 别看代码短,其实有很多东西 12345678910111213141516171819202122232425262728293031323334353637383940414243struct test{ int a,b,c; test(int p,int q) { a=p,b=q; } /* 下面这个函数的返回值为bool,重载的运算符为&lt;,运算符左边的数据类型为test,右边 的数据类型也为test 括号内const和&amp;的用途在于加速和不改变源值 第二个const放在非静态成员函数的尾部，表示该非静态成员函数不修改对象内容 */ bool operator &lt; (const test &amp;m) const { if(a&lt;m.a) return false; else return true; } bool operator &gt; (const test &amp;m) const { if(b&gt;m.b) return true; else return false; } int operator + (const test &amp;m) const { return a+b+m.a+m.b; } test operator - (const test &amp;m) const { test q(a-m.a,b-m.b); return q; }};int main(){ test a=test(3,5); test b(2,6); test c(3,7); cout&lt;&lt;(a&lt;b)&lt;&lt;' '&lt;&lt;(a&gt;b)&lt;&lt;' '&lt;&lt;(a+b)&lt;&lt;' '&lt;&lt;(b-c+a); return 0;} 输出: 11 0 16 6 面向对象编程参看菜鸟教程","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91OI%E4%B8%AD%E7%9A%84C++%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80&%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/"},{"title":"【杂项】c++ map的使用","text":"题目描述： n（n&lt;=200000)个数(1.5*10^9范围内)，输出重复的数（最多10000个）出现的次数 代码： #include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstdio&gt; using namespace std;map&lt;int,int&gt; a;int n,t; int main(){ freopen(“count.in”,”r”,stdin); //打开输入文件 freopen(“count.out”,”w”,stdout); //打开输出文件 cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;t; a\\[t\\]++; \\} for\\(map\\&lt;int,int&gt;::iterator it=a.begin\\(\\);it\\!=a.end\\(\\);it++\\) cout\\&lt;\\&lt;it-&gt;first\\&lt;\\&lt;&quot; &quot;\\&lt;\\&lt;it-&gt;second\\&lt;\\&lt;&quot; &quot;\\&lt;\\&lt;endl; fclose\\(stdin\\);//关闭输入文件 fclose\\(stdout\\);//关闭输出文件 } 几个操作总结： 1.定义map&lt;数据类型，数据类型&gt; 变量名; 2.首元素：x.began() 3.尾元素:x.end() 4.遍历: 先定义一个迭代器: map&lt;数据类型，数据类型&gt;::iterater it; 接着: it=a.begin();it!=a.end();it++ 这里it相当于指针. 4.输出元素:定义的第一个:it-&gt;first 第二个:it-&gt;second","link":"/2019/10/23/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91c++%20map%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"【杂项】一个程序弄懂C++面向对象编程","text":"没有继承和友元函数的内容,而且太乱了,以后可能会修改,但对我来说够用了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//huaruoji on 2021/2/1#include &lt;bits/stdc++.h&gt;using namespace std;struct test{ //struct中的成员均为public成员 static int pi,e;//声明了pi和e,但此处只是声明,不能接着赋值 int a,b,c;//实例变量 test(int p,int q)//构造函数定义 { a=p,b=q; } test(char s)//构造函数定义 { c=s-'A'; } /* 下面这个函数的返回值为bool,重载的运算符为&lt;,运算符左边的数据类型为test,右边 的数据类型也为test 括号内const和&amp;的用途在于加速和不改变源值 第二个const放在非静态成员函数的尾部，表示该非静态成员函数不修改对象内容 */ bool operator &lt; (const test &amp;m) const { if(a&lt;m.a) return false; else return true; } bool operator &gt; (const test &amp;m) const { if(b&gt;m.b) return true; else return false; } int operator + (const test &amp;m) const { return a+b+m.a+m.b; } test operator - (const test &amp;m) const { test q(a-m.a,b-m.b); return q; } //声明成员函数 bool isab(void) const;//const可加可不加 int *address(void); //但这里const不能加,因为返回的是地址 //定义成员函数 bool compare(int com) { return (com&lt;a); } int compare2(test rec) { return (this-&gt;compare(5)&lt;rec.compare(1));//this指针的用法 }};//定义test中的成员函数 bool test::isab() const{ return (a==b);}int *test::address()//一个返回地址的函数 { return &amp;a; }int test::pi;//定义了piint test::e=2;//定义并初始化了e int main(){ test::pi=1;//初始化了pi test a=test(3,5);//main函数中的局部对象 test b(3,5); test c('A'); test d(4,6); cout&lt;&lt;a.a&lt;&lt;' '&lt;&lt;b.b&lt;&lt;' '&lt;&lt;c.c&lt;&lt;' '&lt;&lt;a.isab()&lt;&lt;endl; cout&lt;&lt;(a&lt;b)&lt;&lt;' '&lt;&lt;(a&gt;b)&lt;&lt;' '&lt;&lt;(a+b)&lt;&lt;' '&lt;&lt;(b-d+a)&lt;&lt;endl; int m=*b.address(); cout&lt;&lt;m&lt;&lt;endl; cout&lt;&lt;a.compare(1)&lt;&lt;endl; cout&lt;&lt;a.compare2(b); return 0;}","link":"/2021/02/01/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%84%E6%87%82C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"title":"【杂项】重读C++ Primer Plus","text":"**前言:**重读C++ Primer Plus,温故而知新 重读C++ Primer Plus,温故而知新 第3章 处理数据关于int的长度 short至少16位； int至少与short一样长； long至少32位，且至少与int一样长； long long至少64位，且至少与long一样长。 int可以为16,24,32,64位,在windows中与long一样长,为32位. 各种数据类型的长度 别再傻傻上网查了!在头文件climits中都有!sizeof sizeof用于变量根本不用加括号,例:数据的初始化 12345int b(23);//int b=23; int physics[1000]{};//int physics[1000];physics[1,2,3...1000]=0;int math[1000];cout&lt;&lt;3000000000//this is ok.int a=2147483649//a will be -2147483647 上面几种初始化方式在c++98中都是可行的 十六进制(hex),八进制(octal) 表示方法:0x42,042输出方法:cout&lt;&lt;hex&lt;&lt;42;cout&lt;&lt;oct&lt;&lt;42; char 12cout&lt;&lt;'a';//编译器将会把'a'当作字符常量,因此输出字符achout&lt;&lt;int('a');//输出a的ASCII值 double","link":"/2021/02/17/%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E9%87%8D%E8%AF%BBC++%20Primer%20Plus/"},{"title":"【笔记】upper_bound和lower_bound","text":"前言: upper_bound和lower_bound是C++ STL提供的二分查找函数 upper_bound和lower_bound要求被查找的区域已经从小到大排好序. upper_bound用于查找区域内第一个大于目标值的元素的位置,lower_bound用于查找区域内第一个大于等于目标值的元素的位置. upper_bound和lower_bound均有2种用法.(来自C语言中文网) 123456//在 [first, last) 区域内查找不小于 val 的元素ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val);//在 [first, last) 区域内查找第一个不符合 comp 规则的元素ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val, Compare comp); C++友情提供了函数greater(),可用于按从大到小排序的序列.例: 1lower_bound(a+1,a+n+1,x,greater&lt;int&gt;()); 注意2个函数返回的是指针,如果要求数组内元素下标可以这样用: 1lower_bound(a+1,a+n+1,x)-a; 例题:P2782 友好城市","link":"/2021/02/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91upper_bound%E5%92%8Clower_bound/"},{"title":"【笔记】听课记录 210220【分治,树分治,CDQ分治】","text":"本文为分治,树分治,CDQ分治的听课笔记 分治思想的最简单体现，将具有特征的问题分解成子问题，子问题可用同样方法（即递归）处理。对于子问题之间的联系，特殊处理。 sszx dzy 20% 分治分而治之 归并排序分治思想的最简单体现，将具有特征的问题分解成子问题，子问题可用同样方法（即递归）处理。对于子问题之间的联系，特殊处理。 求逆序对与归并排序密不可分，例： 121 2 3 4 1 2 3 41 2 3 4 5 6 7 8 主定理求递归式的时间复杂度 平面上的分治在平面上按x坐标排序分治，再在归并排序过程中考虑y坐标。 练习题CF480E 树分治求树上距离不大于k的点对个数，即路径。树分治就是解决树上路径问题的高效算法。 分为点分治和边分治 练习题SPOJ FTOUR2（求选择不超过k个黑点的路径最大权值）：点分治 BZOJ2152（求2个点之间路径权值和是3的倍数的概率）： BZOJ1758（）：分数规划+长链剖分 CDQ分治CDQ分治需要题目支持离线算法，且修改操作互不影响 例题：陌上花开（BZOJ3262）Des：求比每个元素的三种属性都小的元素个数Sol：CDQ分治 练习题BZOJ1176（维护矩阵，支持单点修改和范围查询）： BZOJ3295,CQOI2011（动态逆序对:CDQ分治经典例题，删除元素的同时求逆序对个数）： BZOJ2716/2648（SJY摆棋子：在棋盘上放下黑棋和白棋，对于白棋输出这个白棋和离它最近的黑棋之间的距离，此处的近和距离指曼哈顿距离）：二维偏序||kdtree 总结题单:https://www.luogu.com.cn/training/57283","link":"/2021/02/21/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%AC%E8%AF%BE%E8%AE%B0%E5%BD%95%20210220%E3%80%90%E5%88%86%E6%B2%BB,%E6%A0%91%E5%88%86%E6%B2%BB,CDQ%E5%88%86%E6%B2%BB%E3%80%91/"},{"title":"【笔记】线性代数","text":"本文为huaruoji蒟蒻的线性代数笔记，没有参考价值 向量向量:既有大小又有方向的量向量的三种表示方式:1.空间中的箭头2.$\\vec{v}$3.$\\begin{bmatrix}2\\3\\end{bmatrix}$向量的模有向线段$\\overrightarrow{AB}$的长度叫做$AB$的模,记作|$\\overrightarrow{AB}$|或$|a|$ 矩阵例:$$\\begin{bmatrix}2&amp;3\\4&amp;7\\end{bmatrix}$$ 矩阵乘法例：$$设A=\\begin{bmatrix}2&amp;3\\4&amp;7\\end{bmatrix},B=\\begin{bmatrix}1&amp;5\\6&amp;8\\end{bmatrix},C=AB\\则C=\\begin{bmatrix}21+36&amp;25+38\\41+76&amp;45+78\\end{bmatrix}=\\begin{bmatrix}20&amp;34\\46&amp;76\\end{bmatrix}$$感性理解：如果把A和B像下面这样标号$$A=\\begin{bmatrix}第一行\\第二行\\end{bmatrix},B=\\begin{bmatrix}第&amp;第\\一&amp;二\\列&amp;列\\end{bmatrix}，$$那么$C=\\begin{bmatrix}第一行第一列&amp;第一行第二列\\第二行第一列&amp;第二行*第二列\\end{bmatrix}$.此处的行与列相乘理解为行与列每个对应数乘积之和,既然要”对应”,那么我们的行宽度与列长度显然要相同. 特殊矩阵零矩阵记作$O$,即元素全为0的矩阵 单位矩阵主对角线全为1的矩阵,例:$$\\begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1 \\end{bmatrix}$$","link":"/2021/01/31/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"【资源】SC CSP-J2019初赛成绩","text":"链接: https://pan.baidu.com/s/1UK2pL7UW0n0vYpnzMbJm9A 提取码: uwav 复制这段内容后打开百度网盘手机App，操作更方便哦 Me?87! I am a large!!! 还有几个100分的QAQ","link":"/2019/10/24/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91SC%20CSP-J2019%E5%88%9D%E8%B5%9B%E6%88%90%E7%BB%A9/"},{"title":"【资源】noip初赛试题","text":"链接: https://pan.baidu.com/s/1yoOMIUqMRBnBUPprC3o6HQ\\&amp;shfl=shareset 提取码: m8ns 复制这段内容后打开百度网盘手机App，操作更方便哦 2006-2016 给个赞呗","link":"/2019/10/18/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91noip%E5%88%9D%E8%B5%9B%E8%AF%95%E9%A2%98/"},{"title":"【资源】NOI ONLINE 提高组第三次测试题目存档","text":"NOI ONLINE 提高组第三次测试题目存档水壶（kettle） 魔法值（magic） 优秀子序列（sequence）","link":"/2020/05/24/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91NOI%20ONLINE%20%E6%8F%90%E9%AB%98%E7%BB%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E5%AD%98%E6%A1%A3/"},{"title":"【题解】HUSTOJ 有序表的最小和","text":"一次奇怪的AC经历。。。上周被这道题卡了3天。。。 传送门：http://oj.gdsyzx.edu.cn/problem.php?id=1475 题目描述给出两个长度为n的有序表A和B，在A和B中各任取一个元素，可以得到n2个和，求这些和中最小的n个。（不要去重） 输入第一行包含一个整数n（n&lt;=400000）; 第二行与第三行分别有n个整数，分别代表有序表A和B。整数之间由一个空格隔开，大小在长整型范围内，保证有序表的数据单调递增。 输出输出共n行，每行一个整数，第i行为第i小的和。数据保证在长整型范围内。 样例输入31 2 52 4 7 样例输出3 45 先是在学校做了这道题，被归到了“队列”标签里，然后因为是求前n个最小值，那么肯定就是用优先队列啦。 我们先来看一个叫做k路归并问题的神奇玩意（抄的百度文库） 好的，看懂了上面我们进行下一步！把A和B数组所有元素的和看作n个有序表（如下） 如果直接按照k路归并的算法，“把每个表的当前元素放入二叉堆中”需要log n的时间，删除最小值，加入下一个元素（所有表的）又需要log n的时间，总共就需要 n^2 log n 的时间，400000的数据规模铁定爆了！！！ 既然会爆，我们就来优化一下。先思考一下把一个元素放入二叉堆的条件是什么，是它在有序表中的前一个元素被弹出（不是被放入）！所以我们从a1+b1开始扫，每次入堆的时候都打上标记，如果这个元素出堆了，那么就把它所在的有序表的下一个元素入堆！ 综上，O(n log n)！ 代码： #include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt; using namespace std;int n,a[400005],b[400005],t[400005];struct sb{ int h,bj; friend bool operator&lt; (sb a1,sb b1)//带结构体的优先队列用法 { return a1.h&gt;b1.h; }}; priority_queue&lt;sb&gt; q; inline void write(int x)//快速写入{ if(x&gt;9) write(x/10); putchar(x%10+’0’);} int main(){ ios::sync_with_stdio(0); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) cin&gt;&gt;a\\[i\\]; for\\(int i=1;i\\&lt;=n;i++\\) cin&gt;&gt;b\\[i\\]; for\\(int i=1;i\\&lt;=n;i++\\) \\{ sb temp; temp.h=a\\[i\\]+b\\[++t\\[i\\]\\]; temp.bj=i; q.push\\(temp\\); write\\(q.top\\(\\).h\\); putchar\\('\\\\n'\\); int bjt=q.top\\(\\).bj; if\\(t\\[bjt\\]\\&lt;n\\) \\{ temp.h=a\\[bjt\\]+b\\[++t\\[bjt\\]\\]; temp.bj=bjt; \\} q.push\\(temp\\); q.pop\\(\\); \\} }","link":"/2019/12/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91HUSTOJ%20%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C/"},{"title":"【转载文章】各种排序方法思想与时间复杂度与稳定性","text":"注意！此处没有打广告！ ps：计数排序就是桶排序，不是基数排序 补充两种排序：希尔排序和基数排序 基数排序：桶排序plus，把每个数分个，十，百位来桶排，复杂度O (nlog(r)m)，其中r为所采取的基数，而m为堆数 希尔排序：插入排序plus，以空间换时间，把每个数间隔加大，插入时便无需向后移动所有元素，时间复杂度介于对数线性阶与平方阶之间 时间复杂度其实很好理解。 直接插入，直接选择，冒泡排序都是n方，因为都是双重循环。 快排和归并都是1生2，2生4，4生8，子子孙孙无穷匮，所以类似于二分，时间复杂度是nlogn 附上快排代码，完善程序有可能考 #include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std; const int maxn=1e5+5; int n; int a[maxn]; int read() //快速读入{ int x=0,f=1;char ch=getchar(); for(;ch&lt;‘0’||ch&gt;’9’;ch=getchar())if(ch==’-‘)f=-1; for(;ch&gt;=’0’&amp;&amp;ch&lt;=’9’;ch=getchar())x=x*10+ch-‘0’; return x*f;} void Qsort(int l,int r) { int i=l,j=r,mid=a[(l+r)&gt;&gt;1];//mid作为键值 注意 n&gt;&gt;1表示n/2，位运算基本操作 while(i&lt;=j) { while(a[i]&lt;mid)i++;//小于mid的值放在左半部分不用管 while(a[j]&gt;mid)j–;//大于mid的值放在右半部分不用管 if(i&lt;=j)swap(a[i++],a[j–]);//维护序列 }//[l,i]始终小于等于mid，区间[j,r]始终大于等于mid if(l&lt;j)Qsort(l,j);//递归处理 if(i&lt;r)Qsort(i,r);//递归处理} int main() { n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); Qsort(1,n); for(int i=1;i&lt;=n;i++) printf(“%d “,a[i]); return 0;} 由于各种神奇的数据，快排其实是可以优化一下的。 最简单的就是mid=(l+r)/2 再者是随机化，用rand（）函数随机mid（基准数）的值。 代码： #include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std; int n,a[10005]; void quicksort(int l,int r){ int i=l,j=r,mid=a[rand()%(r-l)+l]; while(i&lt;=j) { while(a[i]&lt;mid) i++; while(a[j]&gt;mid) j–; if(i&lt;=j) swap(a[i++],a[j–]); } if(l&lt;j) quicksort(l,j); if(i&lt;r) quicksort(i,r);} int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quicksort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;“ “;} 用随机化和不用时间比较 左用，右不用 少了一点点吧。。。","link":"/2019/10/18/%E3%80%90%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0%E3%80%91%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%9D%E6%83%B3%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A8%B3%E5%AE%9A%E6%80%A7/"},{"title":"【题解】P1020 [NOIP1999 普及组] 导弹拦截","text":"使用STL中的upper_bound和lower_bound代替二分操作对于问一求最长不上升子序列，问二求最长上升子序列（为什么问二是这样是我也不知道）巨坑的点，对于问一，f数组中的数据是下降（从大到小排序）的，必须添加greater()，二分的原则是排好序啊！！！终于AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100005],p,f[100005],k=0;int main(){ while(cin&gt;&gt;a[p]) { p++; } f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&lt;=f[k]) { f[++k]=a[i]; } else { int x=upper_bound(f,f+k,a[i],greater&lt;int&gt;())-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; k=0; memset(f,0,sizeof(f)); f[0]=a[0]; for(int i=1;i&lt;p;i++) { if(a[i]&gt;f[k]) { f[++k]=a[i]; } else { int x=lower_bound(f,f+k,a[i])-f; f[x]=a[i]; } } cout&lt;&lt;k+1&lt;&lt;endl; return 0; }","link":"/2020/05/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1020%20%5BNOIP1999%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/"},{"title":"【题解】P1439 【模板】最长公共子序列","text":"前言: LCS：Longest Common Subsequence，最长公共子序列. DesP1439 【模板】最长公共子序列 - 洛谷 Sol这道题真的是LCS的模版题吗… 基础的LCS算法当然是$dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(仅在a[i]=b[j]情况下))$.但$O(n^2)$的算法当然过不了洛谷$10^5$的毒瘤数据.只能考虑优化.","link":"/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"【题解】P2782 友好城市","text":"DesP2782 友好城市 - 洛谷 Sol画出一个满足条件的方法图例,可以发现,从左到右的航线对应的端点(及城市)编号都是上升的.考虑满足这个关系. 对于河岸一边的城市,考虑排序使其编号上升.对于另一边的城市,则求最长上升序列.可以证明这样找出的答案是最大的. My code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,f[N],r; struct line{ int x,y;}a[N];bool cmp(const line &amp;a,const line &amp;b){ return a.x&lt;b.x;}inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x; } int main(){ n=read(); for(int i=1;i&lt;=n;i++) { a[i].x=read(),a[i].y=read(); } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(a[i].y&gt;f[r]) f[++r]=a[i].y; else { int pos=upper_bound(f+1,f+r,a[i].y)-f; f[pos]=a[i].y; } } printf(&quot;%d\\n&quot;,r); return 0;}","link":"/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2782-%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/"},{"title":"【题解】P5514 [MtOI2019]永夜的报应","text":"看了题解才知道这个性质:$$a \\oplus b \\le a+b$$粗略证明:由$$0+0=0,0\\oplus 0=0\\1+0=1,1\\oplus 0=1\\0+1=1,0\\oplus 1=1\\1+1=2,1\\oplus 1=0$$可以得到:$a \\oplus b \\le a+b$ 回到题目,设分成了2组,得到结果为c,d,原数为$a_1,a_2,a_3,a_4$,则$c + d =(a_1 \\oplus a_2)+(a_3 \\oplus a_4)\\ge a_1 \\oplus a_2 \\oplus a_3 \\oplus a_4$ 代码: 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans,p;int main(){ cin&gt;&gt;n; cin&gt;&gt;ans; for(int i=2;i&lt;=n;i++) { cin&gt;&gt;p; ans=ans^p; } cout&lt;&lt;ans; return 0;}","link":"/2021/01/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5514%20%5BMtOI2019%5D%E6%B0%B8%E5%A4%9C%E7%9A%84%E6%8A%A5%E5%BA%94/"},{"title":"【题解】P5657 [CSP-S2019] 格雷码","text":"T1 格雷码首先看到这是一道普及-的题,我深表惊讶.于是决定认真想一想来测试一下我的智商是否达到了OIer准入水平,于是,我被自己的智慧所折服了~ 阅读题目我们可以发现生成的格雷码是一个长度为 2 n 2^n 2n的数列,既然放在第一题就一定有各种奇葩的简单做法,找规律又有何不可呢?(实际上,其他题解也有大佬是直接按照题意模拟的,这算是正向思维.根据生成的数列找到规律算是一种逆向思维啦) 题目中给出的 n = 3 n=3 n=3的情况对我来说还不便于寻找规律,我们把 n = 4 n=4 n=4的表列出来:0000 , 0001 , 0011 , 0010 , 0110 , 0111 , 0101 , 0100 , 1100 , 1101 , 1111 , 1110 , 1010 , 1011 , 1001 , 1000 0000,0001,0011,0010,0110,0111,0101,0100,\\\\ 1100,1101,1111,1110,1010,1011,1001,1000 0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1111,1110,1010,1011,1001,1000显然,每一位是 0 0 0或 1 1 1都是有规律的,考虑到生成算法是分成了2部分进行,我们可以画出一颗二叉树(我也不知道我怎么想到的):从最下一层序号位置向上遍历,就可得到整个格雷码. 回到孩子的操作为 i d x ÷ 2 idx \\div 2 idx÷2,求得当前值为0或1的算法是:a n s p = { 1 i d x m o d 4 = = 1 o r 2 0 i d x m o d 4 = = 0 o r 3 ans_p=\\begin{cases}1\\qquad &amp;idx \\mod4==1\\ or \\ 2 \\\\ 0 \\ \\quad &amp; idx \\mod 4==0\\ or \\ 3 \\end{cases} ansp​={10​idxmod4==1or2idxmod4==0or3​代码: 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;unsigned long long k;int ans[70],n,p;int main(){ cin&gt;&gt;n&gt;&gt;k; p=n; while(p--) { int modx=k%4; if(modx==1||modx==2) ans[p]=1; else ans[p]=0; k/=2; } for(int i=0;i&lt;n;i++) { cout&lt;&lt;ans[i]; } return 0;}","link":"/2021/01/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5657%20%5BCSP-S2019%5D%20%E6%A0%BC%E9%9B%B7%E7%A0%81/"},{"title":"【题解】P4305 【[JLOI2011]不重复数字】","text":"**前言:**本题解为洛谷P4305,JLOI2011,BZOJ2761不重复数字的题解.方法: 字符串哈希 排序 Des:P4305 [JLOI2011]不重复数字Sol1:多关键字排序输入时记录每个元素的idx和num. 首先按照大小排序,去重.再按照原先的idx排序,得到答案. My code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define INF 1e9;using namespace std;const int N=5e4+5;int t,n;struct element{ int num,idx;}a[N];bool cmp_num(const element &amp;a,const element &amp;b){ if(a.num==b.num) return a.idx&lt;b.idx; else return a.num&lt;b.num;}bool cmp_idx(const element &amp;a,const element &amp;b){ return a.idx&lt;b.idx;}inline int read(){ int s=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}int main(){ t=read(); for(int i=1;i&lt;=t;i++) { n=read(); for(int j=1;j&lt;=n;j++) { a[j].num=read(); a[j].idx=j; } sort(a+1,a+n+1,cmp_num); int tmp=a[1].num; for(int j=2;j&lt;=n;j++) { if(a[j].num==tmp) { a[j].num=a[j].idx=INF; } else tmp=a[j].num; } sort(a+1,a+n+1,cmp_idx); for(int j=1;j&lt;=n;j++) { if(a[j].num==1e9) break; printf(&quot;%d &quot;,a[j].num); } putchar('\\n'); } return 0;} Sol 2:使用vector进行字符串哈希 关于hash表的部分大家可以看一看其他的题解，我就不说了 不定长数组vector的几个基本用法： 定义: vector&lt;数据类型&gt; 数组名称 访问: a[pos]//访问a数组下标为pos的元素 尾部加入元素: a.push_back(x) 判断是否为空: a.empty()//空返回true,非空返回false 代码: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n,hash_num=50021,t,temp;vector&lt;int&gt; a[50022];int main(){ ios::sync_with_stdio(false); //快速读入 cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;n; memset(a,0,sizeof(a));//重置hash表 for(int j=1;j&lt;=n;j++) { cin&gt;&gt;temp;//输入当前数据 int hash=temp%hash_num;//hash过程 bool pd=false; if(a[hash].empty()==false) { for(int k=0;k&lt;a[hash].size();k++) { if(a[hash][k]==temp)//判断hash表中是否有当前元素 pd=true; } } else if(pd==false) { a[hash].push_back(temp);//如果hash表中没有,加入hash表并输出 printf(&quot;%d &quot;,temp); } } printf(&quot;\\n&quot;); }}","link":"/2019/12/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4305%20%E3%80%90%5BJLOI2011%5D%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91/"},{"title":"【题解】UVA10810 Ultra-QuickSort","text":"一个元素想要到达正确的位置,前面的元素必须比它小.也就是说,该元素至少必须和前面比自己大的元素交换一次.这道题就转化成了求逆序对. 接下来就是归并排序求逆序对的过程.代码中最重要的部分是ans+=p2-k-1.说明:若第二部分的元素进入了答案数组,说明它比第一部分还未进入答案数组的数要小,即第一部分还未进入答案数组的数的数量便是逆序对个数. Des: UVA10810 Ultra-QuickSort - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Sol: 一个元素想要到达正确的位置,前面的元素必须比它小.也就是说,该元素至少必须和前面比自己大的元素交换一次.这道题就转化成了求逆序对. 接下来就是归并排序求逆序对的过程.代码中最重要的部分是ans+=p2-k-1.说明:若第二部分的元素进入了答案数组,说明它比第一部分还未进入答案数组的数要小,即第一部分还未进入答案数组的数的数量便是逆序对个数. My code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5;int n=5e5+5,a[N],t[N];long long ans;inline int read(){ int s=1,x=0;char c=getchar(); while(c&gt;'9'||c&lt;'0'){if(c=='-')s=0;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-48;c=getchar();} return s?x:-x;}void merge_sort(int l,int r){ if(l&gt;=r) return; int mid=(l+r)&gt;&gt;1; merge_sort(l,mid); merge_sort(mid+1,r); int p1=l,p2=mid+1,k=l-1;//p1,p2为2部分指针，k为答案数组指针 while(p1&lt;=mid &amp;&amp; p2&lt;=r) { if(a[p1]&lt;=a[p2]) t[++k]=a[p1++]; else ans+=p2-k-1,t[++k]=a[p2++]; } while(p1&lt;=mid) t[++k]=a[p1++]; while(p2&lt;=r) t[++k]=a[p2++]; for(int i=l;i&lt;=r;i++) { a[i]=t[i]; }}int main(){ while(n) { ans=0; n=read(); if(n==0) break; for(int i=1;i&lt;=n;i++) { a[i]=read(); } merge_sort(1,n); printf(&quot;%lld\\n&quot;,ans); } return 0;}","link":"/2021/02/22/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91UVA10810%20Ultra-QuickSort/"},{"title":"【题解】简单双向链表的实现&amp;新约瑟夫问题","text":"题目描述： 给定m个人，从s开始报数，数字顺加，报到n的人出列，然后数字顺减报到k的人出列，求出列顺序 样例输入： 8 1 3 2 样例输出： 3 6 1 5 2 8 4 7 分析： 约瑟夫问题主要就是处理边界，因此选用链表，第一个指向最后一个，最后一个指向第一个。 注意，这里链表不用指针！不用指针！为什么？因为m&lt;=100,链表节点数量小，可直接用数组+结构体！ q为前驱，h为后继。 完整代码如下： #include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstdio&gt; using namespace std;int m,s,n,k,cnt,pd=true,pd2=true;struct lb{ int q,h;}a[105]; void del(int x)//删除节点{ a[a[x].q].h=a[x].h; a[a[x].h].q=a[x].q;} int main(){// freopen(“newjsf.in”,”r”,stdin); //打开输入文件// freopen(“newjsf.out”,”w”,stdout); //打开输出文件 cin&gt;&gt;m&gt;&gt;s&gt;&gt;n&gt;&gt;k; a\\[1\\].q=m,a\\[1\\].h=2,a\\[m\\].q=m-1,a\\[m\\].h=1; cnt=m; for\\(int i=2;i\\&lt;=m-1;i++\\) \\{ a\\[i\\].q=i-1,a\\[i\\].h=i+1; \\} while\\(cnt&gt;0\\) \\{ if\\(pd\\) for\\(int i=1;i\\&lt;=n;i++\\) \\{ if\\(pd2\\)//判断是否第一个人 \\{ pd2=false; continue; \\} s=a\\[s\\].h; \\} else for\\(int i=1;i\\&lt;=k;i++\\) s=a\\[s\\].q; cout\\&lt;\\&lt;s\\&lt;\\&lt;&quot; &quot;; cnt--; del\\(s\\); \\} fclose\\(stdin\\);//关闭输入文件 fclose\\(stdout\\);//关闭输出文件 }","link":"/2019/10/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%AE%80%E5%8D%95%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0&%E6%96%B0%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"},{"title":"【小记】2019 CSP-J复赛游记","text":"不出行？不出行考屁呢？ 今天的CSP-J似乎比去年简单了一些，可它。。。 好了，来说一说我的情况。 T1：太水，5分钟秒 T2：这个数据有点尴尬，双重循环铁定爆，用链表有有一点小题大做。本蒟蒻在考场上打了三个版本才过了大样例。 说一下本蒟蒻的思路：首先用两个O（n）的数组存下时间与费用，若是地铁就直接存进去；若是公交车就往前扫，由于时间是递增的，当某一时刻时间差大于45时便停止遍历。若遇到可使用的优惠劵，则将该值清为0；若没有，ans加上price。 代码（或许有点差异）： #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std;int n,lx,price,t,a[100005],b[100005],ans,q=1; int main(){ freopen(“transfer.in”,”r”,stdin); freopen(“transfer.out”,”w”,stdout); cin&gt;&gt;n; for\\(int i=1;i\\&lt;=n;i++\\) \\{ cin&gt;&gt;lx&gt;&gt;price&gt;&gt;t; if\\(lx==0\\) \\{ b\\[i\\]=t; a\\[i\\]=price; ans+=price; \\} if\\(lx==1\\) \\{ b\\[i\\]=t; a\\[i\\]=price; bool pd=false; for\\(int k=q;k\\&lt;i;k++\\) \\{ if\\(t-b\\[k\\]&gt;45\\) q=k+1; if\\(t-b\\[k\\]\\&lt;=45 \\&amp;\\&amp; a\\[k\\]&gt;=price\\) \\{ a\\[k\\]=0; pd=true; break; \\} \\} if\\(pd==false\\) ans+=price; \\} \\} cout\\&lt;\\&lt;ans\\&lt;\\&lt;endl; return 0; } T3：Orz太难了，比T4还难，像是背包可惜还可以卖，像是搜索可惜数据范围太大。在考场上只写了一个25%数据（应对n为1的情况）的DP，对了第一个样例 T4：本蒟蒻手推了半个小时，又打了半个小时的代码，找到了一个像是正解的算法，可惜是O（n^3) 555555555……QAQ 主要思路就是顺着推，从与小轩直接相连的工人开始，每遇着一个，便把和他相连的所有工人打上标记，等下次循环继续此操作。 其实这可以看作是求全集与每个工人对应的集的交集的过程，看出来了吗，并查集！！！可惜我忘了！！！ 1-16的测试点都只有1000的数据范围，可以用邻接矩阵。最后的应该要用邻接表，可惜我不会！！！ 一年OI一场空，本事不全见祖宗！ 附认真的反思： 就我个人来说，csp对我的意义，不能不说非常重大。 既然如何， 一般来说， 就我个人来说，csp对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 可是，即使是这样，csp的出现仍然代表了一定的意义。 从这个角度来看， 既然如何， 斯宾诺莎曾经说过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。带着这句话，我们还要更加慎重的审视这个问题： 而这些并不是完全重要，更加重要的问题是， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 可是，即使是这样，csp的出现仍然代表了一定的意义。 我们都知道，只要有意义，那么就必须慎重考虑。 现在，解决csp的问题，是非常非常重要的。 所以， 在这种困难的抉择下，本人思来想去，寝食难安。 所谓csp，关键是csp需要如何写。 我认为， 就我个人来说，csp对我的意义，不能不说非常重大。 马尔顿曾经说过，坚强的信心，能使平凡的人做出惊人的事业。这启发了我， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 而这些并不是完全重要，更加重要的问题是， 这样看来， 从这个角度来看， 邓拓在不经意间这样说过，越是没有本领的就越加自命不凡。这不禁令我深思。 经过上述讨论， 克劳斯·莫瑟爵士说过一句富有哲理的话，教育需要花费钱，而无知也是一样。这不禁令我深思。 白哲特曾经说过，坚强的信念能赢得强者的心，并使他们变得更坚强。 我希望诸位也能好好地体会这句话。 而这些并不是完全重要，更加重要的问题是， 我认为， 我们不得不面对一个非常尴尬的事实，那就是， 所谓csp，关键是csp需要如何写。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 所谓csp，关键是csp需要如何写。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 经过上述讨论， 在这种困难的抉择下，本人思来想去，寝食难安。 一般来讲，我们都必须务必慎重的考虑考虑。 带着这些问题，我们来审视一下csp。 经过上述讨论， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 所谓csp，关键是csp需要如何写。 可是，即使是这样，csp的出现仍然代表了一定的意义。 在这种困难的抉择下，本人思来想去，寝食难安。 博在不经意间这样说过，一次失败，只是证明我们成功的决心还够坚强。 维这句话语虽然很短，但令我浮想联翩。 那么， 这样看来， 既然如此， 克劳斯·莫瑟爵士在不经意间这样说过，教育需要花费钱，而无知也是一样。这似乎解答了我的疑惑。 那么， 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 要想清楚，csp，到底是一种怎么样的存在。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 现在，解决csp的问题，是非常非常重要的。 所以， 歌德曾经提到过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 既然如此， 伏尔泰曾经提到过，坚持意志伟大的事业需要始终不渝的精神。这似乎解答了我的疑惑。 要想清楚，csp，到底是一种怎么样的存在。 经过上述讨论， 要想清楚，csp，到底是一种怎么样的存在。 现在，解决csp的问题，是非常非常重要的。 所以， 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 阿卜·日·法拉兹说过一句富有哲理的话，学问是异常珍贵的东西，从任何源泉吸收都不可耻。带着这句话，我们还要更加慎重的审视这个问题： 歌德曾经提到过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 斯宾诺莎说过一句富有哲理的话，最大的骄傲于最大的自卑都表示心灵的最软弱无力。带着这句话，我们还要更加慎重的审视这个问题： 既然如何， 一般来讲，我们都必须务必慎重的考虑考虑。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 一般来讲，我们都必须务必慎重的考虑考虑。 鲁巴金说过一句富有哲理的话，读书是在别人思想的帮助下，建立起自己的思想。这启发了我， 就我个人来说，csp对我的意义，不能不说非常重大。 培根说过一句富有哲理的话，合理安排时间，就等于节约时间。这似乎解答了我的疑惑。 亚伯拉罕·林肯曾经说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。我希望诸位也能好好地体会这句话。 带着这些问题，我们来审视一下csp。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 经过上述讨论。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 问题的关键究竟为何？ 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 就我个人来说，csp对我的意义，不能不说非常重大。 杰纳勒尔·乔治·S·巴顿在不经意间这样说过，接受挑战，就可以享受胜利的喜悦。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 我们都知道，只要有意义，那么就必须慎重考虑。 从这个角度来看， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 那么， 既然如此， 莎士比亚说过一句富有哲理的话，本来无望的事，大胆尝试，往往能成功。这似乎解答了我的疑惑。 问题的关键究竟为何？ 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我认为， 每个人都不得不面对这些问题。 在面对这种问题时， 吕凯特曾经提到过，生命不可能有两次，但许多人连一次也不善于度过。这不禁令我深思。 而这些并不是完全重要，更加重要的问题是， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 那么， 总结的来说， 每个人都不得不面对这些问题。 在面对这种问题时， 从这个角度来看， 我们都知道，只要有意义，那么就必须慎重考虑。 问题的关键究竟为何？ 我认为， 我们不得不面对一个非常尴尬的事实，那就是， csp，到底应该如何实现。 每个人都不得不面对这些问题。 在面对这种问题时， 既然如此， 我们都知道，只要有意义，那么就必须慎重考虑。 所谓csp，关键是csp需要如何写。 现在，解决csp的问题，是非常非常重要的。 所以， 这样看来， 每个人都不得不面对这些问题。 在面对这种问题时， 我们不得不面对一个非常尴尬的事实，那就是， 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 经过上述讨论， 总结的来说， 一般来说， 一般来讲，我们都必须务必慎重的考虑考虑。 一般来说， csp，到底应该如何实现。 总结的来说， 可是，即使是这样，csp的出现仍然代表了一定的意义。 所谓csp，关键是csp需要如何写。 而这些并不是完全重要，更加重要的问题是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 csp，到底应该如何实现。 我们都知道，只要有意义，那么就必须慎重考虑。 富兰克林说过一句富有哲理的话，读书是易事，思索是难事，但两者缺一，便全无用处。这不禁令我深思。 就我个人来说，csp对我的意义，不能不说非常重大。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 带着这些问题，我们来审视一下csp。 要想清楚，csp，到底是一种怎么样的存在。 塞内加曾经说过，勇气通往天堂，怯懦通往地狱。我希望诸位也能好好地体会这句话。 我认为， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 富勒曾经提到过，苦难磨炼一些人，也毁灭另一些人。我希望诸位也能好好地体会这句话。 莎士比亚在不经意间这样说过，抛弃时间的人，时间也抛弃他。我希望诸位也能好好地体会这句话。 美华纳曾经提到过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这似乎解答了我的疑惑。 总结的来说， 我们都知道，只要有意义，那么就必须慎重考虑。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下csp。 每个人都不得不面对这些问题。 在面对这种问题时， 这样看来， 一般来说， 培根在不经意间这样说过，阅读使人充实，会谈使人敏捷，写作使人精确。这似乎解答了我的疑惑。 csp，到底应该如何实现。 就我个人来说，csp对我的意义，不能不说非常重大。 在这种困难的抉择下，本人思来想去，寝食难安。 总结的来说， 美华纳在不经意间这样说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这句话语虽然很短，但令我浮想联翩。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 一般来讲，我们都必须务必慎重的考虑考虑。 要想清楚，csp，到底是一种怎么样的存在。 问题的关键究竟为何？ 总结的来说， 那么， 既然如何， 从这个角度来看， 既然如何， 现在，解决csp的问题，是非常非常重要的。 所以， 我们不得不面对一个非常尴尬的事实，那就是。 就我个人来说，csp对我的意义，不能不说非常重大。 爱尔兰曾经说过，越是无能的人，越喜欢挑剔别人的错儿。我希望诸位也能好好地体会这句话。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 乌申斯基曾经提到过，学习是劳动，是充满思想的劳动。这似乎解答了我的疑惑。 一般来讲，我们都必须务必慎重的考虑考虑。 别林斯基说过一句富有哲理的话，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我认为， csp，发生了会如何，不发生又会如何。 伏尔泰说过一句富有哲理的话，不经巨大的困难，不会有伟大的事业。这句话语虽然很短，但令我浮想联翩。 带着这些问题，我们来审视一下csp。 现在，解决csp的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下csp。 亚伯拉罕·林肯在不经意间这样说过，我这个人走得很慢，但是我从不后退。这不禁令我深思。 要想清楚，csp，到底是一种怎么样的存在。 一般来说， 我认为， 我们都知道，只要有意义，那么就必须慎重考虑。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下csp。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 csp，发生了会如何，不发生又会如何。 带着这些问题，我们来审视一下csp。 既然如何， 既然如何。 在这种困难的抉择下，本人思来想去，寝食难安。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如何， csp因何而发生？ 每个人都不得不面对这些问题。 在面对这种问题时， 鲁巴金在不经意间这样说过，读书是在别人思想的帮助下，建立起自己的思想。这不禁令我深思。 美华纳在不经意间这样说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这启发了我， 既然如何， 既然如何， 斯宾诺莎曾经提到过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。这不禁令我深思。 带着这些问题，我们来审视一下csp。 带着这些问题，我们来审视一下csp。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 那么， 在这种困难的抉择下，本人思来想去，寝食难安。 现在，解决csp的问题，是非常非常重要的。 所以， 一般来讲，我们都必须务必慎重的考虑考虑。 拉罗什福科在不经意间这样说过，我们唯一不会改正的缺点是软弱。带着这句话，我们还要更加慎重的审视这个问题： 所谓csp，关键是csp需要如何写。 既然如此， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 csp，到底应该如何实现。 吉格·金克拉在不经意间这样说过，如果你能做梦，你就能实现它。带着这句话，我们还要更加慎重的审视这个问题： 经过上述讨论， 吉格·金克拉在不经意间这样说过，如果你能做梦，你就能实现它。这似乎解答了我的疑惑。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如何， 黑塞曾经说过，有勇气承担命运这才是英雄好汉。带着这句话，我们还要更加慎重的审视这个问题： 叔本华说过一句富有哲理的话，普通人只想到如何度过时间，有才能的人设法利用时间。这启发了我， 总结的来说， 在这种困难的抉择下，本人思来想去，寝食难安。 我们都知道，只要有意义，那么就必须慎重考虑。 一般来说， 一般来说， 我认为， 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 美华纳曾经提到过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这似乎解答了我的疑惑。 奥斯特洛夫斯基在不经意间这样说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。 带着这句话，我们还要更加慎重的审视这个问题： 德谟克利特在不经意间这样说过，节制使快乐增加并使享受加强。带着这句话，我们还要更加慎重的审视这个问题： 爱迪生曾经说过，失败也是我需要的，它和成功对我一样有价值。这不禁令我深思。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 一般来说， 可是，即使是这样，csp的出现仍然代表了一定的意义。 可是，即使是这样，csp的出现仍然代表了一定的意义。 现在，解决csp的问题，是非常非常重要的。 所以， 总结的来说， 希腊说过一句富有哲理的话，最困难的事情就是认识自己。我希望诸位也能好好地体会这句话。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 塞涅卡说过一句富有哲理的话，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这启发了我， 老子在不经意间这样说过，知人者智，自知者明。胜人者有力，自胜者强。我希望诸位也能好好地体会这句话。 既然如此， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如何， 我认为， 既然如此。 带着这些问题，我们来审视一下csp。 米歇潘说过一句富有哲理的话，生命是一条艰险的峡谷，只有勇敢的人才能通过。这不禁令我深思。 每个人都不得不面对这些问题。 在面对这种问题时， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 马尔顿曾经提到过，坚强的信心，能使平凡的人做出惊人的事业。这启发了我， 既然如何， 现在，解决csp的问题，是非常非常重要的。 所以， 我们都知道，只要有意义，那么就必须慎重考虑。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 那么， 可是，即使是这样，csp的出现仍然代表了一定的意义。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来说， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。这启发了我， 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 csp因何而发生？ 笛卡儿说过一句富有哲理的话，阅读一切好书如同和过去最杰出的人谈话。我希望诸位也能好好地体会这句话。 德谟克利特曾经说过，节制使快乐增加并使享受加强。这不禁令我深思。 一般来说， 一般来说， 所谓csp，关键是csp需要如何写。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 现在，解决csp的问题，是非常非常重要的。 所以， 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， csp，到底应该如何实现。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 csp，到底应该如何实现。 就我个人来说，csp对我的意义，不能不说非常重大。 从这个角度来看， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 洛克在不经意间这样说过，学到很多东西的诀窍，就是一下子不要学很多。这句话语虽然很短，但令我浮想联翩。 csp因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 csp，发生了会如何，不发生又会如何。 我认为， 莎士比亚曾经提到过，抛弃时间的人，时间也抛弃他。我希望诸位也能好好地体会这句话。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 卡莱尔曾经说过，过去一切时代的精华尽在书中。我希望诸位也能好好地体会这句话。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 就我个人来说，csp对我的意义，不能不说非常重大。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 要想清楚，csp，到底是一种怎么样的存在。 一般来说， 经过上述讨论， 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这似乎解答了我的疑惑。 就我个人来说，csp对我的意义，不能不说非常重大。 塞涅卡说过一句富有哲理的话，生命如同寓言，其价值不在与长短，而在与内容。这不禁令我深思。 而这些并不是完全重要，更加重要的问题是， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 布尔沃说过一句富有哲理的话，要掌握书，莫被书掌握；要为生而读，莫为读而生。我希望诸位也能好好地体会这句话。 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 所谓csp，关键是csp需要如何写。 就我个人来说，csp对我的意义，不能不说非常重大。 总结的来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 既然如此， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 叔本华曾经提到过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。我希望诸位也能好好地体会这句话。 每个人都不得不面对这些问题。 在面对这种问题时， csp因何而发生？ 这样看来， 问题的关键究竟为何？ 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 这样看来。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 那么， 从这个角度来看， 从这个角度来看， 富兰克林曾经说过，你热爱生命吗？那么别浪费时间，因为时间是组成生命的材料。这似乎解答了我的疑惑。 亚伯拉罕·林肯在不经意间这样说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。我希望诸位也能好好地体会这句话。 而这些并不是完全重要，更加重要的问题是， csp因何而发生？ 富兰克林曾经提到过，读书是易事，思索是难事，但两者缺一，便全无用处。这句话语虽然很短，但令我浮想联翩。 csp，发生了会如何，不发生又会如何。 富兰克林说过一句富有哲理的话，读书是易事，思索是难事，但两者缺一，便全无用处。带着这句话，我们还要更加慎重的审视这个问题： 既然如何， 要想清楚，csp，到底是一种怎么样的存在。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 从这个角度来看， 孔子曾经说过，知之者不如好之者，好之者不如乐之者。这不禁令我深思。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。带着这句话，我们还要更加慎重的审视这个问题： 白哲特说过一句富有哲理的话，坚强的信念能赢得强者的心，并使他们变得更坚强。 这似乎解答了我的疑惑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 裴斯泰洛齐曾经提到过，今天应做的事没有做，明天再早也是耽误了。这似乎解答了我的疑惑。 既然如何， 这样看来， 西班牙说过一句富有哲理的话，自己的鞋子，自己知道紧在哪里。带着这句话，我们还要更加慎重的审视这个问题： 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 我认为， 总结的来说， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 现在，解决csp的问题，是非常非常重要的。 所以， 那么， 德国曾经说过，只有在人群中间，才能认识自己。这不禁令我深思。 csp，到底应该如何实现。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 既然如何， csp，到底应该如何实现。 而这些并不是完全重要，更加重要的问题是， 这样看来， 这样看来， 总结的来说， 所谓csp，关键是csp需要如何写。 csp，到底应该如何实现。 问题的关键究竟为何？ 就我个人来说，csp对我的意义，不能不说非常重大。 csp，发生了会如何，不发生又会如何。 既然如何， 一般来说， 而这些并不是完全重要，更加重要的问题是， 别林斯基在不经意间这样说过，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 可是，即使是这样，csp的出现仍然代表了一定的意义。 这样看来， 既然如何， 从这个角度来看， csp，发生了会如何，不发生又会如何。 而这些并不是完全重要，更加重要的问题是， 我们不得不面对一个非常尴尬的事实，那就是， csp，到底应该如何实现。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 我认为， 亚伯拉罕·林肯在不经意间这样说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。这启发了我， 那么， 歌德在不经意间这样说过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 总结的来说， 我认为。 培根在不经意间这样说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。带着这句话，我们还要更加慎重的审视这个问题： 现在，解决csp的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 就我个人来说，csp对我的意义，不能不说非常重大。 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 csp，发生了会如何，不发生又会如何。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是， 每个人都不得不面对这些问题。 在面对这种问题时， 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 我们不得不面对一个非常尴尬的事实，那就是， 而这些并不是完全重要，更加重要的问题是。 对我个人而言，csp不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 经过上述讨论， 从这个角度来看， 这样看来， 既然如此， 那么， 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚csp到底是一种怎么样的存在，是解决一切问题的关键。 总结的来说， 经过上述讨论， 我们都知道，只要有意义，那么就必须慎重考虑。 史美尔斯曾经说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。这似乎解答了我的疑惑。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来说， 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 奥普拉·温弗瑞曾经说过，你相信什么，你就成为什么样的人。这启发了我， 吉姆·罗恩曾经说过，要么你主宰生活，要么你被生活主宰。这似乎解答了我的疑惑。 海贝尔曾经说过，人生就是学校。在那里，与其说好的教师是幸福，不如说好的教师是不幸。这句话语虽然很短，但令我浮想联翩。 现在，解决csp的问题，是非常非常重要的。 所以， 我认为， 那么， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 带着这些问题，我们来审视一下csp。 要想清楚，csp，到底是一种怎么样的存在。 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这启发了我， 杰纳勒尔·乔治·S·巴顿在不经意间这样说过，接受挑战，就可以享受胜利的喜悦。我希望诸位也能好好地体会这句话。 我们不得不面对一个非常尴尬的事实，那就是， 所谓csp，关键是csp需要如何写。 既然如何， csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 csp，到底应该如何实现。 赫尔普斯曾经提到过，有时候读书是一种巧妙地避开思考的方法。带着这句话，我们还要更加慎重的审视这个问题： 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 问题的关键究竟为何？ 带着这些问题，我们来审视一下csp。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 马云说过一句富有哲理的话，最大的挑战和突破在于用人，而用人最大的突破在于信任人。带着这句话，我们还要更加慎重的审视这个问题： csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 就我个人来说，csp对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 就我个人来说，csp对我的意义，不能不说非常重大。 csp，发生了会如何，不发生又会如何。 富勒说过一句富有哲理的话，苦难磨炼一些人，也毁灭另一些人。这句话语虽然很短，但令我浮想联翩。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 从这个角度来看， 经过上述讨论， csp，发生了会如何，不发生又会如何。 我们都知道，只要有意义，那么就必须慎重考虑。 生活中，若csp出现了，我们就不得不考虑它出现了的事实。 所谓csp，关键是csp需要如何写。 富勒说过一句富有哲理的话，苦难磨炼一些人，也毁灭另一些人。这启发了我， 要想清楚，csp，到底是一种怎么样的存在。 总结的来说， 这样看来， 带着这些问题，我们来审视一下csp。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 那么， 可是，即使是这样，csp的出现仍然代表了一定的意义。 csp因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 莎士比亚说过一句富有哲理的话，本来无望的事，大胆尝试，往往能成功。这不禁令我深思。 csp的发生，到底需要如何做到，不csp的发生，又会如何产生。 经过上述讨论， 一般来讲，我们都必须务必慎重的考虑考虑。 既然如何， 可是，即使是这样，csp的出现仍然代表了一定的意义。 现在，解决csp的问题，是非常非常重要的。 所以， 总结的来说。 可是，即使是这样，csp的出现仍然代表了一定的意义。 既然如此， 既然如何， 贝多芬在不经意间这样说过，卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。这句话语虽然很短，但令我浮想联翩。 卡耐基曾经提到过，一个不注意小事情的人，永远不会成就大事业。带着这句话，我们还要更加慎重的审视这个问题： 佚名在不经意间这样说过，感激每一个新的挑战，因为它会锻造你的意志和品格。这不禁令我深思。 每个人都不得不面对这些问题。 在面对这种问题时， 西班牙曾经说过，自己的鞋子，自己知道紧在哪里。这不禁令我深思。 既然如何。 我们都知道，只要有意义，那么就必须慎重考虑。 csp因何而发生？ 我认为， 从这个角度来看， 歌德说过一句富有哲理的话，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 既然如何， 卡耐基曾经说过，一个不注意小事情的人，永远不会成就大事业。我希望诸位也能好好地体会这句话。 问题的关键究竟为何？ csp因何而发生？ 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 卡耐基在不经意间这样说过，一个不注意小事情的人，永远不会成就大事业。这句话语虽然很短，但令我浮想联翩。 csp因何而发生？ 我们都知道，只要有意义，那么就必须慎重考虑。 亚伯拉罕·林肯曾经提到过，我这个人走得很慢，但是我从不后退。我希望诸位也能好好地体会这句话。 经过上述讨论， 问题的关键究竟为何？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 生活中，若csp出现了，我们就不得不考虑它出现了的事实。","link":"/2019/11/16/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%912019%20CSP-J%E5%A4%8D%E8%B5%9B%E6%B8%B8%E8%AE%B0/"},{"title":"【资源】洛谷能力进阶提升题单--个人刷题记录","text":"本文为 洛谷能力进阶提升题单 的个人刷题记录 对于初学者，建议先完成 Part 1,2 两部分内容，为接下来的学习打好基础。 对于要参加 CSP-S 的选手，建议在前面的基础上优先完成 Part 3.1-3.4, 4.1-4.4, 6.1-6.5, 7.1-7.8, 8.1-8.7 的内容（具体内容见下），在此基础上继续完成其他内容。 每个专题下的题目先给出模板，剩下的题目均按照难度递增顺序排序，部分难度较高的综合性题目建议达到一定能力后再尝试解决。 Part 0 试机题 三道试机题目。 P1000 超级玛丽游戏 P1001 A+B Problem P1008 三连击 Part 1 入门阶段 本部分内容针对入门 OIer ，主要是语言基础内容。 Part 1.1 从零开始 语言基础题。 P1421 小玉买文具 P1909 买铅笔 P1089 津津的储蓄计划 P1085 不高兴的津津 P1035 级数求和 P1980 计数问题 P1014 Cantor表 P1307 数字反转 Part 1.2 数组基础 数组可以用于存储大量的信息。 P1046 陶陶摘苹果 P1047 校门外的树 P1427 小鱼的数字游戏 P2141 珠心算测验 P5594 【XR-4】模拟赛 Part 1.3 字符串基础 字符串是特殊的数组，但它也有很多自身的特点。 P5015 标题统计 P1055 ISBN号码 P1308 统计单词数 P2010 回文日期 P1012 拼数 P5587 打字练习 Part 1.4 函数，递归及递推 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。 P1028 数的计算 P1036 选数 P1464 Function P5534 【XR-3】等差数列 P1192 台阶问题 P1025 数的划分 P4994 终于结束的起点 Part 2 基础算法 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。 当然，这里面也有一些难度比较高的题目。 Part 2.1 模拟 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。 这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。 P1003 铺地毯 P1067 多项式输出 P1328 生活大爆炸版石头剪刀布 P1563 玩具谜题 P1042 乒乓球 P1179 数字统计 P2615 神奇的幻方 P3952 时间复杂度 P2482 [SDOI2010]猪国杀 P5380 [THUPC2019]鸭棋 Part 2.2 排序算法 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。 P1177 【模板】快速排序 P1059 明明的随机数 P1068 分数线划定 P1051 谁拿了最多奖学金 P1309 瑞士轮 P1908 逆序对 Part 2.3 二分答案 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。 P1024 一元三次方程求解 P2678 跳石头 P1824 进击的奶牛 P1902 刺杀大使 P1314 聪明的质监员 P1083 借教室 P4343 [SHOI2015]自动刷题机 Part 2.4 分治 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。 P1226 【模板】快速幂||取余运算 P1010 幂次方 P1429 平面最近点对（加强版） P3612 [USACO17JAN]Secret Cow Code Part 2.5 贪心 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。 P1208 [USACO1.3]Mixing Milk P4995 跳跳！ P1094 纪念品分组 P1199 三国游戏 P2672 推销员 P1080 国王游戏 P2123 皇后游戏 P5521 [yLOI2019]梅深不见冬 Part 2.6 构造 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。 P3599 Koishi Loves Construction P5441 【XR-2】伤痕 P5595 【XR-4】歌唱比赛 Part 2.7 高精度 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！ P1601 A+B Problem（高精） P2142 高精度减法 P1303 A*B Problem P1480 A/B Problem P1009 阶乘之和 Part 2.8 前缀和 &amp; 差分 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。 P3131 [USACO16JAN]Subsequences Summing to Sevens P1387 最大正方形 P3397 地毯 P2280 [HNOI2003]激光炸弹 P4552 [Poetize6] IncDec Sequence Part 3 搜索 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。 Part 3.1 深度优先搜索 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。 深度优先搜索一般使用栈来实现。 P1219 八皇后 P1019 单词接龙 P5194 [USACO05DEC]Scales P5440 【XR-2】奇迹 P1378 油滴扩展 Part 3.2 广度优先搜索 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。 广度优先搜索一般使用队列来实现。 P1162 填涂颜色 P1443 马的遍历 P3956 棋盘 P1032 字串变换 P1126 机器人搬重物 Part 3.3 记忆化搜索 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。 动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。 P1514 引水入城 P1535 游荡的奶牛 P1434 [SHOI2002]滑雪 P3953 逛公园 Part 3.4 搜索的剪枝 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。 P1120 小木棍 ［数据加强版］ P1312 Mayan游戏 P1074 靶形数独 Part 3.5 双向搜索 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。 P3067 [USACO12OPEN]Balanced Cow Subsets P4799 [CEOI2015 Day2]世界冰球锦标赛 P5195 [USACO05DEC]Knights of Ni Part 3.6 A* 在 BFS 中，如果能设计一个合理的估价函数，就可以更快扩展到最优解。这就是 A*算法。 P1379 八数码难题 Part 3.7 IDA* 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。 再加上一个估价函数来减小搜索量，就是 IDA*了。 P2324 [SCOI2005]骑士精神 P2534 [AHOI2012]铁盘整理 Part 3.8 DLX 算法 X 是通过回溯法求解精确覆盖问题的算法，而删除列这一操作可以使用舞蹈链加速。 P4929 【模板】舞蹈链（DLX） P4205 [NOI2005]智慧珠游戏 Part 4 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。 Part 4.1 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。 P1216 数字三角形 P1020 导弹拦截 P1091 合唱队形 P1095 守望者的逃离 P1541 乌龟棋 P1868 饥饿的奶牛 P2679 子串 P2501 [HAOI2006]数字序列 P3336 [ZJOI2013]话旧 P3558 [POI2013]BAJ-Bytecomputer P4158 [SCOI2009]粉刷匠 P5301 [GXOI/GZOI2019]宝牌一大堆 Part 4.2 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。 P1048 采药 P1060 开心的金明 P1855 榨取kkksc03 P5020 货币系统 P1757 通天之分组背包 P1064 金明的预算方案 P2946 [USACO09MAR]Cow Frisbee Team P1156 垃圾陷阱 P5322 [BJOI2019]排兵布阵 P5289 [十二省联考2019]皮配 Part 4.3 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。 P1880 [NOI1995]石子合并 P3146 [USACO16OPEN]248 P1063 能量项链 P1005 矩阵取数游戏 P4170 [CQOI2007]涂色 P4302 [SCOI2003]字符串折叠 P2466 [SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。 因为树的递归性质，树形动态规划一般都是递归求解的。 P1352 没有上司的舞会 P1040 加分二叉树 P1122 最大子树和 P1273 有线电视网 P2014 选课 P2585 [ZJOI2006]三色二叉树 P3047 [USACO12FEB]Nearby Cows P3698 [CQOI2017]小Q的棋盘 P5658 括号树 P2607 [ZJOI2008]骑士 P3177 [HAOI2015]树上染色 P4395 [BOI2003]Gem P4516 [JSOI2018]潜入行动 Part 4.5 状态压缩动态规划 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。 P2704 [NOI2001]炮兵阵地 P1879 [USACO06NOV]Corn Fields P1896 [SCOI2005]互不侵犯 P3092 [USACO13NOV]No Change P3694 邦邦的大合唱站队 P4925 [1007]Scarlet的字符串不可能这么可爱 P2157 [SDOI2009]学校食堂 P2167 [SDOI2009]Bill的挑战 P2396 yyy loves Maths VII P4363 [九省联考2018]一双木棋 P5005 中国象棋 - 摆上马 P2150 [NOI2015]寿司晚宴 Part 4.6 倍增优化动态规划 利用倍增的方式，我们可以将状态转移的效率大大提高。 P1613 跑路 P1081 开车旅行 P5024 保卫王国 Part 4.7 数据结构优化动态规划 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。 P4719 【模板】动态dp P4751 动态dp【加强版】 P3287 [SCOI2014]方伯伯的玉米田 P2605 [ZJOI2010]基站选址 Part 4.8 单调队列优化动态规划 借助单调队列，排除不可能的决策，可以起到优化状态转移的效果。 P1776 宝物筛选 P3089 [USACO13NOV]Pogo-Cow P3572 [POI2014]PTA-Little Bird P3522 [POI2011]TEM-Temperature P4544 [USACO10NOV]Buying Feed P5665 划分 P1973 [NOI2011]Noi嘉年华 P2569 [SCOI2010]股票交易 P4852 yyf hates choukapai Part 4.9 斜率优化动态规划 通过用单调队列维护一个凸壳，来达到优化转移的目的。 P2900 [USACO08MAR]Land Acquisition P3195 [HNOI2008]玩具装箱 P3628 [APIO2010]特别行动队 P3648 [APIO2014]序列分割 P4027 [NOI2007]货币兑换 P4360 [CEOI2004]锯木厂选址 P5468 [NOI2019]回家路线 P2305 [NOI2014]购票 Part 4.10 决策单调性优化动态规划 利用决策间的递变规律，也能实现优化状态转移的目的。 P3515 [POI2011]Lightning Conductor P4767 [IOI2000]邮局 P1912 [NOI2009]诗人小G P1973 [NOI2011]Noi嘉年华 P3724 [AH2017/HNOI2017]大佬 P5574 [CmdOI2019]任务分配问题 Part 4.11 数位统计类动态规划 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。 P2602 [ZJOI2010]数字计数 P3281 [SCOI2013]数数 P2518 [HAOI2010]计数 P2657 [SCOI2009]windy数 P3286 [SCOI2014]方伯伯的商场之旅 P4124 [CQOI2016]手机号码 P4999 烦人的数学作业 P2606 [ZJOI2010]排列计数 P4798 [CEOI2015 Day1]卡尔文球锦标赛 Part 4.12 轮廓线动态规划 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。 P5056 【模板】插头dp P2289 [HNOI2004]邮递员 P2337 [SCOI2012]喵星人的入侵 P5347 【XR-1】俄罗斯方块 Part 5 字符串 字符串问题有很多自己的特点。 Part 5.1 字符串哈希 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。 P3370 【模板】字符串哈希 P5270 无论怎样神树大人都会删库跑路 P5537 【XR-3】系统设计 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。 P3375 【模板】KMP字符串匹配 P4391 [BOI2009]Radio Transmission P3435 [POI2006]OKR-Periods of Words P4824 [USACO15FEB]Censoring (Silver) P2375 [NOI2014]动物园 P3426 [POI2005]SZA-Template P3193 [HNOI2008]GT考试 Part 5.3 Manacher Manacher 可以在线性时间内求出一个字符串的最长回文子串。 P3805 【模板】manacher算法 P4555 [国家集训队]最长双回文串 P1659 [国家集训队]拉拉队排练 Part 5.4 Trie树 Trie树可以像查字典一样把多个字符串组织到一棵树上。 P3879 [TJOI2010]阅读理解 P2292 [HNOI2004]L语言 P2922 [USACO08DEC]Secret Message P3065 [USACO12DEC]First! P3294 [SCOI2016]背单词 P4407 [JSOI2009]电子字典 P4551 最长异或路径 P4683 [IOI2008]Type Printer P3783 [SDOI2017]天才黑客 Part 5.5 AC自动机 AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。 P3808 【模板】AC自动机（简单版） P3796 【模板】AC自动机（加强版） P5357 【模板】AC自动机（二次加强版） P3121 [USACO15FEB]Censoring (Gold) P2414 [NOI2011]阿狸的打字机 P3966 [TJOI2013]单词 P2444 [POI2000]病毒 P3311 [SDOI2014]数数 P4052 [JSOI2007]文本生成器 P5599 【XR-4】文本编辑器 Part 5.6 回文自动机 回文自动机是解决回文串问题的有力工具。 P5496 【模板】回文自动机（PAM） P3649 [APIO2014]回文串 P4287 [SHOI2011]双倍回文 P4762 [CERC2014]Virus synthesis Part 5.7 后缀数组 后缀数组可以解决很多字符串匹配的问题。 P3809 【模板】后缀排序 P5353 【模板】树上后缀排序 P2336 [SCOI2012]喵星球上的点名 P2463 [SDOI2008]Sandy的卡片 P2852 [USACO06DEC]Milk Patterns P4051 [JSOI2007]字符加密 P1117 [NOI2016]优秀的拆分 P2178 [NOI2015]品酒大会 P5346 【XR-1】柯南家族 P5576 [CmdOI2019]口头禅 Part 5.8 后缀自动机 后缀自动机是一种处理字符串问题的强大工具。 P3804 【模板】后缀自动机 P3649 [APIO2014]回文串 P3975 [TJOI2015]弦论 P4248 [AHOI2013]差异 P5341 [TJOI2019]甲苯先生和大中锋的字符串 P4770 [NOI2018]你的名字 P5284 [十二省联考2019]字符串问题 P5319 [BJOI2019]奥术神杖 Part 6 数学 OI 中的数学知识很多，也有些杂乱。 Part 6.1 位运算 将十进制整数转换为二进制后，有很多按位运算的运算符。 如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。 P5657 格雷码 P5514 [MtOI2019]永夜的报应 P5538 【XR-3】Namid[A]me P5539 【XR-3】Unknown Mother-Goose P5523 [yLOI2019]珍珠 Part 6.2 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。 Part 6.2.1 素数 素数，指的是除 1 和它本身之外没有其他约数的数。 P4718 【模板】Pollard-Rho算法 P1075 质因数分解 P2441 角色属性树 P5535 【XR-3】小道消息 Part 6.2.2 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。 求解两个数的最大公约数，可以采用欧几里得算法解决。 P5435 【模板】快速 GCD P5436 【XR-2】缘分 P1029 最大公约数和最小公倍数问题 P1414 又是毕业季II P2152 [SDOI2009]SuperGCD P1072 Hankson 的趣味题 Part 6.2.3 欧拉函数 欧拉函数 $ \\varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。 P2158 [SDOI2008]仪仗队 P2568 GCD P2398 GCD SUM P4139 上帝与集合的正确用法 Part 6.3 同余方程 求解同余方程往往可以引出不少话题。 Part 6.3.1 线性同余方程&amp;乘法逆元 线性同余方程是同余方程中最基础的内容。 P4549 【模板】裴蜀定理 P2613 【模板】有理数取余 P3811 【模板】乘法逆元 P5431 【模板】乘法逆元2 P1082 同余方程 P3951 小凯的疑惑 P1516 青蛙的约会 Part 6.3.2 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。 P4777 【模板】扩展中国剩余定理（EXCRT） P3868 [TJOI2009]猜数字 P2480 [SDOI2010]古代猪文 P4774 [NOI2018]屠龙勇士 P5345 【XR-1】快乐肥宅 Part 6.3.3 高次同余方程 BSGS 算法可以高效计算离散对数。 而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。 P4195 【模板】exBSGS P5491 【模板】二次剩余 P3306 [SDOI2013]随机数生成器 P2485 [SDOI2011]计算器 Part 6.4 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 P2197 【模板】nim游戏 P1288 取数游戏II P1290 欧几里德的游戏 P1247 取火柴游戏 P2252 取石子游戏 Part 6.5 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。 P5104 红包发红包 P1850 换教室 P3830 [SHOI2012]随机树 P4564 [CTSC2018]假面 P2473 [SCOI2008]奖励关 P2221 [HAOI2012]高速公路 P3239 [HNOI2015]亚瑟王 P3750 [六省联考2017]分手是祝愿 P4284 [SHOI2014]概率充电器 P5249 [LnOI2019]加特林轮盘赌 P2081 [NOI2012]迷失游乐园 P3343 [ZJOI2015]地震后的幻想乡 P3600 随机数生成器 P5326 [ZJOI2019]开关 Part 6.6 组合数学 组合数学常常与计数问题，概率期望紧密相连。 Part 6.6.1 排列组合 排列组合是组合数学的基础。 P3807 【模板】卢卡斯定理 P2822 组合数问题 P5520 [yLOI2019]青原樱 P3197 [HNOI2008]越狱 P2290 [HNOI2004]树的计数 P4981 父子 P4769 [NOI2018]冒泡排序 P4931 情侣？给我烧了！（加强版） P5596 【XR-4】题 P5598 【XR-4】混乱度 Part 6.6.2 卡特兰数&amp;斯特林数 卡特兰数和斯特林数是两类常见的组合递推数列。 P5395 第二类斯特林数·行 P5396 第二类斯特林数·列 P5408 第一类斯特林数·行 P5409 第一类斯特林数·列 P1655 小朋友的球 P2532 [AHOI2012]树屋阶梯 P3200 [HNOI2009]有趣的数列 P3978 [TJOI2015]概率论 P4091 [HEOI2016/TJOI2016]求和 P4827 [国家集训队]Crash 的文明世界 Part 6.6.3 容斥原理 容斥原理常常用于解决集合的计数问题。 P5664 Emiya 家今天的饭 P1450 [HAOI2008]硬币购物 P3214 [HNOI2011]卡农 P3270 [JLOI2016]成绩比较 P4336 [SHOI2016]黑暗前的幻想乡 P4448 [AHOI2018初中组]球球的排列 P4491 [HAOI2018]染色 P5339 [TJOI2019]唱、跳、rap和篮球 P5400 [CTS2019]随机立方体 Part 6.7 线性代数 线性代数主要用于解决线性关系问题。 Part 6.7.1 矩阵 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。 P3390 【模板】矩阵快速幂 P1939 【模板】矩阵加速（数列） P4783 【模板】矩阵求逆 P1962 斐波那契数列 P1349 广义斐波那契数列 P4000 斐波那契数列 P3758 [TJOI2017]可乐 P4967 黑暗打击 P5343 【XR-1】分块 P5337 [TJOI2019]甲苯先生的字符串 P5303 [GXOI/GZOI2019]逼死强迫症 Part 6.7.2 高斯消元 高斯消元可以用来求解方程组。 P3389 【模板】高斯消元法 P2447 [SDOI2010]外星千足虫 P4035 [JSOI2008]球形空间产生器 P5516 [MtOI2019]小铃的烦恼 P4111 [HEOI2015]小Z的房间 P4457 [BJOI2018]治疗之雨 Part 6.7.3 线性基 线性基可以求解最大异或和的一类问题。 P3812 【模板】线性基 P3857 [TJOI2008]彩灯 P4570 [BJWC2011]元素 P4301 [CQOI2013]新Nim游戏 P3292 [SCOI2016]幸运数字 P4151 [WC2011]最大XOR和路径 Part 6.8 多项式 对多项式的运算进行优化，从而能够解决规模更大的问题。 P3803 【模板】多项式乘法（FFT） P4238 【模板】多项式求逆 P4245 【模板】任意模数NTT P4512 【模板】多项式除法 P4717 【模板】快速沃尔什变换 P4721 【模板】分治 FFT P4725 【模板】多项式对数函数 P4726 【模板】多项式指数函数 P4781 【模板】拉格朗日插值 P5050 【模板】多项式多点求值 P5158 【模板】多项式快速插值 P5205 【模板】多项式开根 P5245 【模板】多项式快速幂 P5273 【模板】多项式幂函数 (加强版) P5282 【模板】快速阶乘算法 P5373 【模板】多项式复合函数 P5394 【模板】下降幂多项式乘法 P3338 [ZJOI2014]力 P3723 [AH2017/HNOI2017]礼物 P5437 【XR-2】约定 P5293 [HNOI2019]白兔之舞 P5432 A/B Problem (加强版) P5472 [NOI2019]斗主地 P5577 [CmdOI2019]算力训练 Part 6.9 莫比乌斯反演 运用莫比乌斯反演，我们可以将一些函数转化，从而降低计算难度。 P3172 [CQOI2015]选数 P2522 [HAOI2011]Problem b P3455 [POI2007]ZAP-Queries P3327 [SDOI2015]约数个数和 P1829 [国家集训队]Crash的数字表格 / JZPTAB P4619 [SDOI2018]旧试题 P3704 [SDOI2017]数字表格 P5518 [MtOI2019]幽灵乐团 Part 6.10 筛法 利用数列的性质，有多种筛法可以求出我们想要的信息。 P3383 【模板】线性筛素数 P4213 【模板】杜教筛（Sum） P5325 【模板】Min_25筛 P1865 A % B Problem P1621 集合 P3768 简单的数学题 P5438 【XR-2】记忆 Part 6.11 线性规划 线性规划是研究线性约束条件下线性目标函数极值问题的方法。 P3980 [NOI2008]志愿者招募 P4232 无意识之外的捉迷藏 Part 6.12 数值方法 在算法领域，有很多求近似值的数值方法。 Part 6.12.1 三分法 三分法可以求出一个单峰 / 单谷函数的极值。 P3382 【模板】三分法 P1883 函数 Part 6.12.2 自适应辛普森法 自适应辛普森法可以高效求出给定函数的数值积分。 P4525 【模板】自适应辛普森法1 P4526 【模板】自适应辛普森法2 P3779 [SDOI2017]龙与地下城 Part 6.13 置换群 置换群通常用来解决一些涉及“本质不同”的计数问题。 P4980 【模板】Polya定理 P1446 [HNOI2008]Cards P2561 [AHOI2002]黑白瓷砖 P4128 [SHOI2006]有色图 P4727 [HNOI2009]图的同构记数 Part 7 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。 Part 7.1 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。 P1996 约瑟夫问题 P1160 队列安排 Part 7.2 栈 栈，是一种后进先出（FILO）的数据结构。 P1449 后缀表达式 P1739 表达式括号匹配 P1981 表达式求值 P1175 表达式的转换 Part 7.3 队列 队列，是一种先进先出（FIFO）的数据结构。 P1540 机器翻译 Part 7.4 并查集 并查集常用于处理一些不相交集合的合并和查询问题。 P1111 修复公路 P3958 奶酪 P1525 关押罪犯 P4185 [USACO18JAN]MooTube G P2024 [NOI2001]食物链 P1197 [JSOI2008]星球大战 P1196 [NOI2002]银河英雄传说 P1955 [NOI2015]程序自动分析 Part 7.5 二叉堆 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。 P3378 【模板】堆 P1090 合并果子 P1168 中位数 P2085 最小函数值 P2827 蚯蚓 P3045 [USACO12FEB]Cow Coupons Part 7.6 ST表 ST表可以离线查询区间最值。 P3865 【模板】ST表 P2251 质量检测 P1816 忠诚 P1198 [JSOI2008]最大数 P2880 [USACO07JAN]Balanced Lineup P5012 水の数列 P5344 【XR-1】逛森林 P2048 [NOI2010]超级钢琴 Part 7.7 树状数组 树状数组是一种简洁高效的树形数据结构。 P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P1908 逆序对 P1966 火柴排队 P3605 [USACO17JAN]Promotion Counting P1972 [SDOI2009]HH的项链 P3586 [POI2015]LOG P4054 [JSOI2009]计数问题 P4113 [HEOI2012]采花 P3960 列队 Part 7.8 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。 P3372 【模板】线段树 1 P3373 【模板】线段树 2 P5490 【模板】扫描线 P4588 [TJOI2018]数学计算 P1502 窗口的星星 P2471 [SCOI2007]降雨量 P2824 [HEOI2016/TJOI2016]排序 P3722 [AH2017/HNOI2017]影魔 P4097 [HEOI2013]Segment P4198 楼房重建 P4513 小白逛公园 P4556 [Vani有约会]雨天的尾巴 P5324 [BJOI2019]删数 P5327 [ZJOI2019]语言 Part 7.9 分块 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。 P3870 [TJOI2009]开关 P3396 哈希冲突 P3863 序列 P1975 [国家集训队]排队 P3710 方方方的数据结构 P3992 [BJOI2017]开车 P4168 [Violet]蒲公英 P4119 [Ynoi2018]未来日记 Part 7.10 可并堆 可并堆分为左偏树和配对堆两种，它们都具有堆的性质，且可以高效合并。 P3377 【模板】左偏树（可并堆） P2713 罗马游戏 P1456 Monkey King P1552 [APIO2012]派遣 P3261 [JLOI2015]城池攻占 P3273 [SCOI2011]棘手的操作 P4331 [BOI2004]Sequence Part 7.11 主席树 主席树，即可持久化权值线段树。 P2468 [SDOI2010]粟粟的书架 P3302 [SDOI2013]森林 P3168 [CQOI2015]任务查询系统 P4559 [JSOI2018]列队 P2633 Count on a tree P3293 [SCOI2016]美味 P4618 [SDOI2018]原题识别 Part 7.12 平衡树 二叉搜索树可以用来维护有序序列。 为了保证查询效率，有多种使二叉搜索树保持平衡的实现方法。 P3369 【模板】普通平衡树 P3391 【模板】文艺平衡树（Splay） P3850 [TJOI2007]书架 P4008 [NOI2003]文本编辑器 P5338 [TJOI2019]甲苯先生的滚榜 P2042 [NOI2005]维护数列 P1110 [ZJOI2007]报表统计 P3644 [APIO2015]八邻旁之桥 P1486 [NOI2004]郁闷的出纳员 P2710 数列 P3224 [HNOI2012]永无乡 P3285 [SCOI2014]方伯伯的OJ P5321 [BJOI2019]送别 Part 7.13 树链剖分 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。 P3384 【模板】树链剖分 P3313 [SDOI2014]旅行 P2590 [ZJOI2008]树的统计 P1505 [国家集训队]旅游 P2486 [SDOI2011]染色 P3258 [JLOI2014]松鼠的新家 P4069 [SDOI2016]游戏 P4211 [LNOI2014]LCA P4592 [TJOI2018]异或 P5305 [GXOI/GZOI2019]旧词 P5354 [Ynoi2017]由乃的OJ P5499 [LnOI2019]Abbi并不想研学 Part 7.14 树套树 树套树可以用来维护多维度信息。 P3380 【模板】二逼平衡树（树套树） P1975 [国家集训队]排队 P3332 [ZJOI2013]K大数查询 P4278 带插入区间K小值 P1903 [国家集训队]数颜色 / 维护队列 P3759 [TJOI2017]不勤劳的图书管理员 P3242 [HNOI2015]接水果 P3248 [HNOI2016]树 P5445 [APIO2019]路灯 Part 7.15 动态树 Link-Cut Tree 可以用来解决动态树一类问题。 P3690 【模板】Link Cut Tree （动态树） P3203 [HNOI2010]弹飞绵羊 P4338 [ZJOI2018]历史 P4312 [COCI2009]OTOCI P1501 [国家集训队]Tree II P2387 [NOI2014]魔法森林 P3348 [ZJOI2016]大森林 P3703 [SDOI2017]树点涂色 P4172 [WC2006]水管局长 P4219 [BJOI2014]大融合 P5489 EntropyIncreaser 与 动态图 Part 7.16 可持久化数据结构 可持久化数据结构实现了在更新信息的时候保留历史版本。 P3919 【模板】可持久化数组（可持久化线段树/平衡树） P3834 【模板】可持久化线段树 1（主席树） P3402 【模板】可持久化并查集 P3835 【模板】可持久化平衡树 P5055 【模板】可持久化文艺平衡树 P5283 [十二省联考2019]异或粽子 Part 7.17 K-D Tree K-D Tree 是一种高效处理 $ k $ 维信息的数据结构。 P4357 [CQOI2016]K远点对 P4148 简单题 P2479 [SDOI2010]捉迷藏 P3769 [CH弱省胡策R2]TATT P4169 [Violet]天使玩偶/SJY摆棋子 P4390 [BOI2007]Mokia P4475 巧克力王国 P2093 [国家集训队]JZPFAR P5471 [NOI2019]弹跳 Part 7.18 珂朵莉树 珂朵莉树，是一种基于 std::set 的暴力数据结构，在数据随机的情况下表现优秀。 P5251 [LnOI2019]第二代图灵机 P5350 序列 Part 8 图论 图论是数学的一个分支，它以图为研究的对象。 Part 8.1 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。 P2661 信息传递 P2921 [USACO08DEC]Trick or Treat on the Farm Part 8.2 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。 P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） P5905 【模板】Johnson 全源最短路 P1144 最短路计数 P1462 通往奥格瑞玛的道路 P1522 Cow Tours P1266 速度限制 P4001 [ICPC-Beijing 2006]狼抓兔子 P4568 [JLOI2011]飞行路线 P3238 [HNOI2014]道路堵塞 P5304 [GXOI/GZOI2019]旅行者 Part 8.3 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。 Part 8.3.1 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。 P1087 FBI树 P1030 求先序排列 P1305 新二叉树 P1229 遍历问题 P5018 对称二叉树 P5597 【XR-4】复读 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。 计算树的直径，可以通过两遍 DFS 解决。 P2195 HXY造公园 P3629 [APIO2010]巡逻 P5536 【XR-3】核心城市 P1099 树网的核 P4408 [NOI2003]逃学的小孩 Part 8.3.3 最近公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。 P3379 【模板】最近公共祖先（LCA） P3938 斐波那契 P4281 [AHOI2008]紧急集合 / 聚会 Part 8.4 生成树 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。 P3366 【模板】最小生成树 P4180 【模板】严格次小生成树[BJWC2010] P2872 [USACO07DEC]Building Roads P1991 无线通讯网 P1967 货车运输 P4047 [JSOI2010]部落划分 Part 8.5 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。 P1113 杂务 P1983 车站分级 P1038 神经网络 Part 8.6 差分约束 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。 P5960 【模板】差分约束算法 P3275 [SCOI2011]糖果 P2294 [HNOI2005]狡猾的商人 P4926 [1007]倍杀测量者 P5590 赛车游戏 Part 8.7 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。 P3387 【模板】缩点 P3388 【模板】割点（割顶） P2341 [HAOI2006]受欢迎的牛 P2863 [USACO06JAN]The Cow Prom P2746 [USACO5.3]Network of Schools P1407 [国家集训队]稳定婚姻 P2272 [ZJOI2007]最大半连通子图 P3225 [HNOI2012]矿场搭建 P5058 [ZJOI2004]嗅探器 P2515 [HAOI2010]软件安装 Part 8.8 二分图 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。 P3386 【模板】二分图匹配 P2756 飞行员配对方案问题 P1129 [ZJOI2007]矩阵游戏 P1559 运动员最佳匹配问题 P2423 [HEOI2012]朋友圈 P2764 最小路径覆盖问题 P2825 [HEOI2016/TJOI2016]游戏 P3033 [USACO11NOV]Cow Steeplechase P3731 [HAOI2017]新型城市化 P4014 分配问题 P4617 [COCI2017-2018#5] Planinarenje Part 8.9 网络流 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。 Part 8.9.1 最大流 最大流，即求网络中最大的流量。 P3376 【模板】网络最大流 P4722 【模板】最大流 加强版 / 预流推进 P2065 [TJOI2011]卡片 P2763 试题库问题 P2472 [SCOI2007]蜥蜴 P2754 [CTSC1999]家园 P2765 魔术球问题 P2766 最长不下降子序列问题 P2805 [NOI2009]植物大战僵尸 P3749 [六省联考2017]寿司餐厅 Part 8.9.2 最小割 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。 可以证明，最大流=最小割。 P1344 [USACO4.4]Pollutant Control P1345 [USACO5.4]Telecowmunication P2057 [SHOI2007]善意的投票 P2598 [ZJOI2009]狼和羊的故事 P2774 方格取数问题 P4126 [AHOI2009]最小割 P5039 [SHOI2010]最小生成树 Part 8.9.3 费用流 在网络流中给边加上一个参数——费用，就出现了费用流。 P3381 【模板】最小费用最大流 P4016 负载平衡问题 P4452 [国家集训队]航班安排 P2045 方格取数加强版 P2050 [NOI2012]美食节 P2053 [SCOI2007]修车 P2604 [ZJOI2010]网络扩容 P2770 航空路线问题 P3159 [CQOI2012]交换棋子 P3356 火星探险问题 P3358 最长k可重区间集问题 P4013 数字梯形问题 P4015 运输问题 P5331 [SNOI2019]通信 Part 8.9.4 上下界网络流 在网络流问题中给每条边的流量增加一个下界，就有了上下界网络流。 P3980 [NOI2008]志愿者招募 P4043 [AHOI2014/JSOI2014]支线剧情 P4553 80人环游世界 P4843 清理雪道 Part 8.10 2-SAT k-SAT 问题的目标是对一些布尔变量赋值，满足限定的条件。 在 k-SAT 问题中，2-SAT 问题属于较为容易解决的一类。 P4782 【模板】2-SAT 问题 P4171 [JSOI2010]满汉全席 P3825 [NOI2017]游戏 P5332 [JSOI2019]精准预测 Part 8.11 点分治 点分治是一种可以高效统计树上路径信息的算法。 P3806 【模板】点分治1 P2634 [国家集训队]聪聪可可 P2664 树上游戏 P3714 [BJOI2017]树的难题 P4149 [IOI2011]Race P3241 [HNOI2015]开店 P4075 [SDOI2016]模式字符串 P4183 [USACO18JAN]Cow at Large P P4292 [WC2010]重建计划 P5306 [COCI2019]Transport Part 8.12 虚树 将一些无用的点从树上删去，从而达到降低树的规模的效果。 P2495 [SDOI2011]消耗战 P3233 [HNOI2014]世界树 P5360 [SDOI2019]世界地图 P5439 【XR-2】永恒 Part 8.13 矩阵树定理 矩阵树定理可以解决图的生成树计数问题。 P4111 [HEOI2015]小Z的房间 P2144 [FJOI2007]轮状病毒 P3317 [SDOI2014]重建 P4208 [JSOI2008]最小生成树计数 Part 9 计算几何 试着用计算机来解决几何问题吧！ Part 9.1 凸包 凸包指在平面上能包含所有给定点的最小凸多边形。 P2742 【模板】二维凸包 P2287 [HNOI2004]最佳包裹 P3829 [SHOI2012]信用卡凸包 P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗? P4557 [JSOI2018]战争 P5403 [CTS2019]田野 Part 9.2 旋转卡壳 旋转卡壳是一种求出凸包所有对踵点对的算法。 P1452 Beauty Contest P3187 [HNOI2007]最小矩形覆盖 Part 9.3 半平面交 多个半平面的交集称之为半平面交。 P3256 [JLOI2013]赛车 P2600 [ZJOI2008]瞭望塔 P4196 [CQOI2006]凸多边形 P3297 [SDOI2013]逃考 P4250 [SCOI2015]小凸想跑步 P5328 [ZJOI2019]浙江省选 Part 10 杂项 这里的专题，有很多都难以纳入前面的类别中，故将他们单独列入了杂项。 Part 10.1 模拟退火 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。 P1337 [JSOI2004]平衡点 / 吊打XXX P2503 [HAOI2006]均分数据 P3878 [TJOI2010]分金币 Part 10.2 0/1 分数规划 0/1 分数规划用来求一个分式的极值。 P4377 [USACO18OPEN]Talent Show P3199 [HNOI2009]最小圈 P3288 [SCOI2014]方伯伯运椰子 P3705 [SDOI2017]新生舞会 P4322 [JSOI2016]最佳团体 Part 10.3 离线算法 当题目不要求强制在线时，我们可以一次性读入所有询问来处理。 Part 10.3.1 CDQ 分治 CDQ 分治是一个基于分治思想的离线算法。 P3810 【模板】三维偏序（陌上花开） P3157 [CQOI2011]动态逆序对 P2487 [SDOI2011]拦截导弹 P4690 [Ynoi2016]镜中的昆虫 P3206 [HNOI2010]城市建设 Part 10.3.2 整体二分 整体二分，顾名思义就是把多个查询一起二分解决。 P1527 [国家集训队]矩阵乘法 P2617 Dynamic Rankings P3527 [POI2011]MET-Meteors P4602 [CTSC2018]混合果汁 Part 10.3.3 莫队 莫队算法可以解决不少离线区间询问问题。 P1494 [国家集训队]小Z的袜子 /【模板】莫队 P1903 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队 P5906 【模板】回滚莫队 P4887 【模板】莫队二次离线（第十四分块(前体)） P2709 小B的询问 P3674 小清新人渣的本愿 P3709 大爷的字符串题 P4074 [WC2013]糖果公园 P5501 [LnOI2019]来者不拒，去者不追 Part 10.4 奇怪的题目 OI 界中有一些非常规套路的题目，这里放出来分享。 P4920 [WC2015]未来程序 P5042 [国家集训队]丢失的题面（ydc的题面） P5285 [十二省联考2019]骗分过样例 P5246 [集训队互测2016]消失的源代码 Part 10.5 非传统题 在 NOI 等比赛中，非传统题正越来越频繁出现。 非传统题主要包括以下几类：提交答案题，交互题，通信题。 Part 10.5.1 提交答案题 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。 P1335 [NOI2013]小Q的修炼 P1737 [NOI2016]旷野大计算 P3614 yyy棋 II P3640 [APIO2013]出题人 P3782 [WC2017]排序 P3836 Nowruz P4920 [WC2015]未来程序 P5402 [CTS2019]无处安放 P5418 [CTSC2016]NOIP十合一 P5600 【XR-4】尺规作图 Part 10.5.2 交互题 在交互题中，选手程序需要通过与测评程序交互来完成任务。 P1733 猜数（IO交互版） P1947 猜数 P5208 [WC2019]I 君的商店 P5473 [NOI2019]I 君的探险 P6541 [WC2018]即时战略 P6558 [APIO2017]考拉的游戏 Copyleft[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J0Xt39cG-1613870443314)(https://i.creativecommons.org/l/by-sa/4.0/88x31.png)] 本项目采用 知识共享署名-相同方式共享 4.0 国际许可协议 以及附加的 The Star And Thank Author License 进行许可。 换言之，您可以自由的共享并演绎该项目，但是必须给出必要的署名，并以相同方式共享本项目，并为本项目的 Github 仓库 点赞（Star）。","link":"/2021/02/21/%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91%E6%B4%9B%E8%B0%B7%E8%83%BD%E5%8A%9B%E8%BF%9B%E9%98%B6%E6%8F%90%E5%8D%87%E9%A2%98%E5%8D%95--%E4%B8%AA%E4%BA%BA%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"乘法逆元","slug":"乘法逆元","link":"/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"CSP初赛","slug":"CSP初赛","link":"/tags/CSP%E5%88%9D%E8%B5%9B/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"波兰表达式","slug":"波兰表达式","link":"/tags/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"质数","slug":"质数","link":"/tags/%E8%B4%A8%E6%95%B0/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"KMP算法","slug":"KMP算法","link":"/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"专题","slug":"专题","link":"/tags/%E4%B8%93%E9%A2%98/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"快速读写","slug":"快速读写","link":"/tags/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"拉格朗日插值","slug":"拉格朗日插值","link":"/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"比赛","slug":"比赛","link":"/tags/%E6%AF%94%E8%B5%9B/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"小记","slug":"小记","link":"/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","link":"/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"模版","slug":"模版","link":"/tags/%E6%A8%A1%E7%89%88/"},{"name":"C++程序","slug":"C-程序","link":"/tags/C-%E7%A8%8B%E5%BA%8F/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"语法","slug":"语法","link":"/tags/%E8%AF%AD%E6%B3%95/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"资源","slug":"资源","link":"/tags/%E8%B5%84%E6%BA%90/"},{"name":"CSP","slug":"CSP","link":"/tags/CSP/"},{"name":"NOIP","slug":"NOIP","link":"/tags/NOIP/"},{"name":"NOI online","slug":"NOI-online","link":"/tags/NOI-online/"},{"name":"二叉堆","slug":"二叉堆","link":"/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"异或","slug":"异或","link":"/tags/%E5%BC%82%E6%88%96/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"二分法","slug":"二分法","link":"/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","link":"/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"约瑟夫问题","slug":"约瑟夫问题","link":"/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"赛前","slug":"赛前","link":"/categories/%E8%B5%9B%E5%89%8D/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"数论","slug":"数学/数论","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"},{"name":"质数","slug":"数学/质数","link":"/categories/%E6%95%B0%E5%AD%A6/%E8%B4%A8%E6%95%B0/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树形数据结构","slug":"数据结构/树形数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CSP初赛","slug":"赛前/CSP初赛","link":"/categories/%E8%B5%9B%E5%89%8D/CSP%E5%88%9D%E8%B5%9B/"},{"name":"基础算法","slug":"基础算法","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"卡常+优化","slug":"卡常-优化","link":"/categories/%E5%8D%A1%E5%B8%B8-%E4%BC%98%E5%8C%96/"},{"name":"波兰表达式","slug":"杂项/波兰表达式","link":"/categories/%E6%9D%82%E9%A1%B9/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"快速幂","slug":"数学/快速幂","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"GCD","slug":"数学/GCD","link":"/categories/%E6%95%B0%E5%AD%A6/GCD/"},{"name":"多项式","slug":"数学/多项式","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"乘法逆元","slug":"数学/数论/乘法逆元","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"比赛","slug":"比赛","link":"/categories/%E6%AF%94%E8%B5%9B/"},{"name":"字典树","slug":"字符串/字典树","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"小记","slug":"小记","link":"/categories/%E5%B0%8F%E8%AE%B0/"},{"name":"字典树","slug":"数据结构/树形数据结构/字典树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"KMP算法","slug":"字符串/KMP算法","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP%E7%AE%97%E6%B3%95/"},{"name":"并查集","slug":"数据结构/树形数据结构/并查集","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"工具","slug":"杂项/工具","link":"/categories/%E6%9D%82%E9%A1%B9/%E5%B7%A5%E5%85%B7/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"哈希","slug":"基础算法/哈希","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"读写相关","slug":"卡常-优化/读写相关","link":"/categories/%E5%8D%A1%E5%B8%B8-%E4%BC%98%E5%8C%96/%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/"},{"name":"听课笔记","slug":"听课笔记","link":"/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"},{"name":"线性代数","slug":"数学/线性代数","link":"/categories/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"资源","slug":"资源","link":"/categories/%E8%B5%84%E6%BA%90/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"拉格朗日插值","slug":"数学/多项式/拉格朗日插值","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"name":"排序","slug":"基础算法/排序","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"最小生成树","slug":"图论/最小生成树","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"递推","slug":"基础算法/递推","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/"},{"name":"线性动态规划","slug":"动态规划/线性动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"CSP","slug":"比赛/CSP","link":"/categories/%E6%AF%94%E8%B5%9B/CSP/"},{"name":"其他","slug":"比赛/其他","link":"/categories/%E6%AF%94%E8%B5%9B/%E5%85%B6%E4%BB%96/"},{"name":"校内测","slug":"比赛/校内测","link":"/categories/%E6%AF%94%E8%B5%9B/%E6%A0%A1%E5%86%85%E6%B5%8B/"},{"name":"博客搭建","slug":"小记/博客搭建","link":"/categories/%E5%B0%8F%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"操作系统","slug":"小记/操作系统","link":"/categories/%E5%B0%8F%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件","slug":"小记/软件","link":"/categories/%E5%B0%8F%E8%AE%B0/%E8%BD%AF%E4%BB%B6/"},{"name":"经验","slug":"小记/经验","link":"/categories/%E5%B0%8F%E8%AE%B0/%E7%BB%8F%E9%AA%8C/"},{"name":"OI历程","slug":"小记/OI历程","link":"/categories/%E5%B0%8F%E8%AE%B0/OI%E5%8E%86%E7%A8%8B/"},{"name":"位运算","slug":"C/位运算","link":"/categories/C/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"语法","slug":"C/语法","link":"/categories/C/%E8%AF%AD%E6%B3%95/"},{"name":"map","slug":"STL/map","link":"/categories/STL/map/"},{"name":"面向对象","slug":"C/面向对象","link":"/categories/C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"语言","slug":"C/语言","link":"/categories/C/%E8%AF%AD%E8%A8%80/"},{"name":"algorithm","slug":"STL/algorithm","link":"/categories/STL/algorithm/"},{"name":"SSZX","slug":"听课笔记/SSZX","link":"/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/SSZX/"},{"name":"成绩","slug":"资源/成绩","link":"/categories/%E8%B5%84%E6%BA%90/%E6%88%90%E7%BB%A9/"},{"name":"题目","slug":"资源/题目","link":"/categories/%E8%B5%84%E6%BA%90/%E9%A2%98%E7%9B%AE/"},{"name":"XCSY","slug":"题解/XCSY","link":"/categories/%E9%A2%98%E8%A7%A3/XCSY/"},{"name":"洛谷","slug":"题解/洛谷","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"},{"name":"校内测","slug":"题解/校内测","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%B5%8B/"},{"name":"堆","slug":"数据结构/树形数据结构/堆","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"},{"name":"NOIP","slug":"题解/NOIP","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/"},{"name":"异或","slug":"数学/异或","link":"/categories/%E6%95%B0%E5%AD%A6/%E5%BC%82%E6%88%96/"},{"name":"1999","slug":"题解/NOIP/1999","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/1999/"},{"name":"MtOI","slug":"题解/MtOI","link":"/categories/%E9%A2%98%E8%A7%A3/MtOI/"},{"name":"2019","slug":"题解/MtOI/2019","link":"/categories/%E9%A2%98%E8%A7%A3/MtOI/2019/"},{"name":"CSP-S","slug":"题解/CSP-S","link":"/categories/%E9%A2%98%E8%A7%A3/CSP-S/"},{"name":"vector","slug":"STL/vector","link":"/categories/STL/vector/"},{"name":"归并排序","slug":"基础算法/排序/归并排序","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"线性数据结构","slug":"数据结构/线性数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"2019","slug":"题解/CSP-S/2019","link":"/categories/%E9%A2%98%E8%A7%A3/CSP-S/2019/"},{"name":"分治","slug":"基础算法/分治","link":"/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"},{"name":"链表","slug":"数据结构/线性数据结构/链表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"数据结构/树形数据结构/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"题单","slug":"资源/题单","link":"/categories/%E8%B5%84%E6%BA%90/%E9%A2%98%E5%8D%95/"}]}