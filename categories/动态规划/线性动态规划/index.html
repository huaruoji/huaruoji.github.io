<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: 线性动态规划 - 滑蒻稽的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="滑蒻稽的博客"><meta name="msapplication-TileImage" content="/img/positive.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="滑蒻稽的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="滑蒻稽的博客"><meta property="og:url" content="https://huaruoji.github.io/"><meta property="og:site_name" content="滑蒻稽的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://huaruoji.github.io/img/og_image.png"><meta property="article:author" content="huaruoji"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://huaruoji.github.io"},"headline":"滑蒻稽的博客","image":["https://huaruoji.github.io/img/og_image.png"],"author":{"@type":"Person","name":"huaruoji"},"description":""}</script><link rel="icon" href="/img/positive.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="滑蒻稽的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives/">归档</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a><a class="navbar-item" href="/about/">关于我</a><a class="navbar-item" href="/%E6%AF%8F%E6%97%A5/">每日</a><a class="navbar-item" href="/%E5%8F%8B%E9%93%BE/">友链</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Huaruoji GitHub" href="https://www.github.com/huaruoji"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="is-active"><a href="#" aria-current="page">线性动态规划</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P4933-%E5%A4%A7%E5%B8%88/"><i class="fas fa-angle-double-right"></i>【题解】P4933 大师</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a></span><span class="level-item"><i class="far fa-clock"></i> 5 分钟读完 (大约683个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4933">P4933 大师</a></p>
<h2 id="sol">Sol</h2>
<p>哇这道题...咳咳...想挑战一下蓝题DP,结果写得让人烦躁.明明感觉算法是对的,但怎么也过不了第2个样例,偏偏第2个样例又那么大,不好调试(侧面显示出我的能力不行).最后看了题解才写出来.我的思路和题解里<span class="math inline">\(O(n^2)\)</span>算法的一样.但是细节处理上显然不够老道.</p>
<p><span class="math inline">\(f[i][h]\)</span>表示第i个电塔为等差数列的最后一个电塔,公差为h的长度.ans需要在dp过程中累加.</p>
<p>为什么呢?发现规律:等差数列的长度每增加1,若原来的长度为l,总方案数增加l.所以在一个电塔可以"接在"一个等差数列的后面时,更新答案.为什么不能等所有的电塔处理完后,操作各个等差数列的长度呢?样例1就是一个很好的说明.如果你想要的操作最后的长度,就必须给之前没有用的长度打上标记,但是样例1中2个34都可以接在27的后面,无论打不打标记都无法满足需求.</p>
<p>回到正解,当<span class="math inline">\(f[j][v]\)</span>可以从<span class="math inline">\(f[j][h]\)</span>更新时,显然,方案数会增加<span class="math inline">\(f[j][h]\)</span>.这就是本题的核心思想.</p>
<p>在代码实现中,我们的<span class="math inline">\(f[i][j]\)</span>默认初始化为0,实际上长度是1,所以将上面的方案数增加<span class="math inline">\(f[j][h]\)</span>更改为方案数增加<span class="math inline">\(f[j][h]+1\)</span>.</p>
<p>对于公差为负数的等差数列,看做是逆序的公差为正数的等差数列,倒着DP一遍即可.</p>
<p>还有一个坑点,<span class="math inline">\(f[j][v]\)</span>可能从2个不同的<span class="math inline">\(f[j][h]\)</span>更新(例:<code>1 3 5 3 5 7</code>,7从2个5都可以更新,而答案都存在<span class="math inline">\(f[j][v]\)</span>里!),所以不能简单的使用如下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][a[i]-a[j]]=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">ans+=f[i][a[i]-a[j]];</span><br></pre></td></tr></table></figure>
<p>应该这样做:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">ans+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><del>就是因为这个我才卡了那么久</del></p>
<h2 id="my-code">My code</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>,V=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],f[N][V];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]-a[j]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">                f[i][a[i]-a[j]]%=P;</span><br><span class="line">                ans+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">                ans%=P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]-a[j]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][a[i]-a[j]]+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">                f[i][a[i]-a[j]]%=P;</span><br><span class="line">                ans+=f[j][a[i]-a[j]]+<span class="number">1</span>;</span><br><span class="line">                ans%=P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (ans+=n)%=P;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="note">Note</h2>
<p>莫等闲,没法敲代码,自伤悲</p>
</div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%B4%9B%E8%B0%B7/">洛谷 </a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"><i class="fas fa-angle-double-right"></i>【题解】P2758 编辑距离</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a></span><span class="level-item"><i class="far fa-clock"></i> 1 分钟读完 (大约208个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a></p>
<h2 id="sol">Sol</h2>
<p>记录这道题主要是归纳动态规划的方法.</p>
<p><img src="/images/image-20210301133315774.png"></p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%B4%9B%E8%B0%B7/">洛谷 </a></div><a class="article-more button is-small is-size-7" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2758-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/"><i class="fas fa-angle-double-right"></i>【题解】P1950 长方形</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">线性数据结构</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></span><span class="level-item"><i class="far fa-clock"></i> 10 分钟读完 (大约1442个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1950">P1950 长方形</a></p>
<h2 id="sol">Sol</h2>
<p>做这道题的路途真是曲折...</p>
<figure>
<img src="/images/vbw2ufy6%20(1).png" alt="何以见得"><figcaption aria-hidden="true">何以见得</figcaption>
</figure>
<p>从3月2号下午做到现在,不过,也收获了许多.</p>
<p>最开始的想法是受到了<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4933">P4933 大师</a>的启发,这道题的答案与每个等差数列的长度密不可分,并且会发现一个规律:等差数列的长度每增加1,能选的方案数会增加l(等差数列当前的长度).那么套到这道题上,一个"能选"的矩形(全为'.'的矩形)的长度和宽度的增加也会带来能选方案数的增加.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line">. .. ... ----矩形</span><br><span class="line">1 3  6   ----方案数</span><br><span class="line">. .. ...</span><br><span class="line">. .. ...</span><br><span class="line">3 9  18</span><br></pre></td></tr></table></figure>
<p>上面示例的每种矩形带来的方案数是有规律的,变化量也有规律,具体是什么我就不说了.既然变化量有规律,我们能不能求出新加入一个点对原来方案的贡献呢?新加入的点可以与它左上方(只计算左上方,避免重复)的点构成矩形,那么计算每个点的贡献就行.</p>
<p>如果想到这一步,离正解就不远了.遗憾的是,我被上一道题的解法限制住了,我错误地只计算了每个点在左上方的2个矩形区域的贡献(错误代码在My code #2).因为我可以按照规律方便地从这2个矩形区域更新答案,就像示例1那样.</p>
<p>在无数次得到10分后,我开始懊恼,但也下定了决心要AC这道题,而且不看题解.因为此题不能下载数据,我的进展停滞了.但今天早上我想到了把题解的程序拿来对拍,这是我的对拍程序(.bat文件):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:loop</span><br><span class="line">makedata.exe</span><br><span class="line">zhengjie.exe &lt; data.in &gt; test1.out</span><br><span class="line">mycode.exe &lt; data.in &gt; test2.out</span><br><span class="line">fc test1.out test2.out</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> errorlevel <span class="number">1</span> <span class="keyword">goto</span> loop</span><br><span class="line">pause</span><br><span class="line">:end</span><br></pre></td></tr></table></figure>
<p>只用更改<code>makedata.exe</code> <code>zhengjie.exe</code> <code>mycode.exe</code> 的名称即可使用.在对拍的过程中,我遇到了这样的数据,发现了我算法的致命错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例2:</span><br><span class="line">**.</span><br><span class="line">*..</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>按照我的算法,我只会统计最右边一列和最下面一行的矩形,并且如果在原有基础上改进算法就会超时了.</p>
<p>考虑新的解题方案.仍然是计算每个点的贡献.观察示例2,计算(3,3)这个点的贡献,显然它可以与(3,1),(3,2),(3,3),(2,2),(2,3),(1,3)这几个点组成矩形(将2个点作为矩形的左上定点和右下顶点),贡献为6.那么,唯一的问题就是如何方便的计算这些点个数的总和.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例3:</span><br><span class="line">*..</span><br><span class="line">**.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在示例3中,仍然计算(3,3)的贡献,并考虑暴力算法.不难想出,先跑一遍矩阵前缀和,用于求出以(x1,y1),(x2,y2)为矩形的2个顶点的矩形内部有多少个'.',即判断该矩形能否选择.然后枚举(3,3)左上方的点看能否选择.不难发现,(1,2)这个点不能选择是因为(2,2)把它限制住了.再推广一点,(2,2)把它正上方的所有点都限制住了,使得它们不能选.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例4:</span><br><span class="line">****.</span><br><span class="line">.....</span><br><span class="line">***..</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>到了示例4,如果你学过单调队列,单调栈相关的内容,一定可以发现,(4,5)在每一行能选择的点的个数是单调递减的.从下往上枚举行数,便能用单调栈求出当前行能选的点数.问题要求我们求方案总和,在单调栈内维护一个sum即可,有了sum,也得有单点的权值(比如5把7更新了,那么sum=sum-2,5的权值也得变为2来代表5和7两个元素).最后写出代码即可.如果对于"权值"没有理解,可以纸上模拟这组数据(要求:给出可用的更新sum的方案):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2 2 2 1 &#x2F;&#x2F;当前行能选的点数</span><br></pre></td></tr></table></figure></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%B4%9B%E8%B0%B7/">洛谷 </a></div><a class="article-more button is-small is-size-7" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/"><i class="fas fa-angle-double-right"></i>【题解】P1280 尼克的任务</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a></span><span class="level-item"><i class="far fa-clock"></i> 3 分钟读完 (大约468个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务</a></p>
<h2 id="sol-1">Sol #1</h2>
<p>最开始是想的是一种不像DP的方法,将任务分成很多个序列,每一个序列有一个结束时间t,如果当前枚举的任务可以接在这个序列的后面,就更新时间和答案数组(空闲时间).如果有多个任务都可以接上,就开辟新的序列.但这样代码实现复杂度极高,而且有很多细节需要调整,最坏时间复杂度为<span class="math inline">\(O(n^2).\)</span></p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%B4%9B%E8%B0%B7/">洛谷 </a></div><a class="article-more button is-small is-size-7" href="/2021/03/12/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1868%20%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B/"><i class="fas fa-angle-double-right"></i>【题解】P1868 饥饿的奶牛+P2439 [SDOI2005]阶梯教室设备利用</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-27</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-04-09</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/SDOI/">SDOI</a></span><span class="level-item"><i class="far fa-clock"></i> 2 分钟读完 (大约353个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1868">P1868 饥饿的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>[P2439 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2439">SDOI2005]阶梯教室设备利用 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="sol">Sol</h2>
<p>将草地的位置当作状态,满足无后效性,且完整记录状态.DP方程为<span class="math inline">\(f[i]=max(f[i-1],f[a[p].x]+a[p].y-a[p].x+1)\)</span>.其中<span class="math inline">\(a[p]\)</span>表示<span class="math inline">\(y=i\)</span>的所有草块.</p>
<p>第二道题与第一道不能说很像,只能说完全一样.只不过细节有变.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP </a></div><a class="article-more button is-small is-size-7" href="/2021/02/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1868%20%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1541-%5BNOIP2010-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E4%B9%8C%E9%BE%9F%E6%A3%8B/"><i class="fas fa-angle-double-right"></i>【题解】P1541 [NOIP2010 提高组] 乌龟棋</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-26</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/NOIP/">NOIP</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/NOIP/2010/">2010</a></span><span class="level-item"><i class="far fa-clock"></i> 4 分钟读完 (大约613个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a></p>
<h2 id="sol">Sol</h2>
<p>又是一道"取数"类问题.回首二维平面上的取数问题,如<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a>,<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7074">P7074 [CSP-J2020] 方格取数</a>.都是把当前的"位置"当作状态,即<span class="math inline">\(f[i][j]\)</span>表示走到<span class="math inline">\((i,j)\)</span>位置时的最优解.在上面的2道题中都没有额外的信息需要维护,但在本题中因为每种卡片数量是有限的,所以你需要存储当前位置的卡片数.这样的话dp数组就变成了五维,即<span class="math inline">\(f[i][c1][c2][c3][c4]\)</span>.i表示当前位置,c1~c4表示当前位置卡片数量.计算后发现超了空间,时间复杂度也不合理.</p>
<p>注意到本题"卡片"的特殊性质,卡片上的数代表了移动距离,也就是说我们完全可以只用卡牌数量做状态,去掉i.dp数组为<span class="math inline">\(f[c1][c2][c3][c4]\)</span>.这样既能保留完整的状态,状态转移也很简单.用a数组存储格子分数.状态转移方程即为<span class="math inline">\(f[c1][c2][c3][c4]=max\begin{cases}f[c1-1][c2][c3][c4]+a[now]\\ f[c1][c2-1][c3][c4]+a[now]\\ f[c1][c2][c3-1][c4]+a[now]\\ f[c1][c2][c3][c4-1]+a[now] \end{cases}\)</span>.代码实现中可建立一个辅助数组存储当前状态的位置,简化now值的求得.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%B4%9B%E8%B0%B7/">洛谷 </a></div><a class="article-more button is-small is-size-7" href="/2021/02/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1541-%5BNOIP2010-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E4%B9%8C%E9%BE%9F%E6%A3%8B/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1095-%5BNOIP2007-%E6%99%AE%E5%8F%8A%E7%BB%84%5D-%E5%AE%88%E6%9C%9B%E8%80%85%E7%9A%84%E9%80%83%E7%A6%BB/"><i class="fas fa-angle-double-right"></i>【题解】P1095 [NOIP2007 普及组] 守望者的逃离</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-25</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/NOIP/">NOIP</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/NOIP/2007/">2007</a></span><span class="level-item"><i class="far fa-clock"></i> 4 分钟读完 (大约564个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p>[P1095 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1095">NOIP2007 普及组] 守望者的逃离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="sol">Sol</h2>
<p>这道题真的挺有意思的,贪心和DP都能做,题解里还有一种神奇的做法.但是自己的才是最好的,说下我的做法吧.</p>
<p>本题涉及到一个''决策''的问题,即跑步还是闪现,与这个决策有关的为当前路程、魔法值和时间.可以发现.当时间还够的时候,永远是闪现更优(就算加上回蓝的时间).但当时间不够,我们就应该考虑跑步了.所以,对于这个题,我们可以设计一种通用的决策方法解题.</p>
<p>枚举时间,如果当前时间能够闪现就直接闪.不能闪就判断是回蓝更优还是跑步更优.判断的方法是计算速度.跑步的速度显然恒为<span class="math inline">\(17.0\)</span>.闪现的速度需要用<span class="math inline">\(闪现距离(60m)/(闪现的时间(1s)+回蓝的时间(\lceil(10-m)/4\rceil))\)</span>.当然这也是朴素贪心的思想.</p>
<p>这样做会出现一个问题.如果当前时间很够,魔法为0,用上面公式算出来的<span class="math inline">\(v_闪=15m/s\)</span>.比跑步慢.程序会选择一直跑步.这点是不是很反直觉?我们知道,如果存够魔法值连续闪2次,<span class="math inline">\(v_闪=120/7\approx17.14\)</span>.就比跑步快了.所以还需要考虑闪2次的速度.你会问,如果闪3次更快呢?闪3次就意味着魔法值在30以上,和闪2次再闪1次等效.所以其实这里20是<span class="math inline">\(gcd(10,4)\)</span>.也就是说,任何魔法值的状态都可以转移为20以下魔法值的状态.</p>
<p>到了这里,我们已经把魔法值,时间考虑进决策了,最后加上一个当前路程的特判,即可完成解题.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E8%B4%AA%E5%BF%83/">贪心 </a></div><a class="article-more button is-small is-size-7" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1095-%5BNOIP2007-%E6%99%AE%E5%8F%8A%E7%BB%84%5D-%E5%AE%88%E6%9C%9B%E8%80%85%E7%9A%84%E9%80%83%E7%A6%BB/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"><i class="fas fa-angle-double-right"></i>【题解】P1439 【模板】最长公共子序列</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-25</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a></span><span class="level-item"><i class="far fa-clock"></i> 2 分钟读完 (大约321个字)</span></div></div><div class="content"><p><strong>前言:</strong> LCS：Longest Common Subsequence，最长公共子序列.</p>
<h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列 - 洛谷</a></p>
<h2 id="sol">Sol</h2>
<p>这道题真的是LCS的模版题吗...</p>
<p>基础的LCS算法当然是<span class="math inline">\(dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(仅在a[i]=b[j]情况下))\)</span>.但<span class="math inline">\(O(n^2)\)</span>的算法当然过不了洛谷<span class="math inline">\(10^5\)</span>的毒瘤数据.只能考虑优化.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP </a></div><a class="article-more button is-small is-size-7" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2782-%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/"><i class="fas fa-angle-double-right"></i>【题解】P2782 友好城市</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-25</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/STL/">STL</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span> / </span><a class="link-muted" href="/categories/STL/algorithm/">algorithm</a><span> / </span><a class="link-muted" href="/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/">洛谷</a></span><span class="level-item"><i class="far fa-clock"></i> 2 分钟读完 (大约228个字)</span></div></div><div class="content"><h2 id="des">Des</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2782">P2782 友好城市 - 洛谷</a></p>
<h2 id="sol">Sol</h2>
<p>画出一个满足条件的方法图例,可以发现,从左到右的航线对应的端点(及城市)编号都是上升的.考虑满足这个关系.</p>
<p>对于河岸一边的城市,考虑排序使其编号上升.对于另一边的城市,则求最长上升序列.可以证明这样找出的答案是最大的.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%BA%BF%E6%80%A7DP/">线性DP, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/STL/">STL </a></div><a class="article-more button is-small is-size-7" href="/2021/02/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P2782-%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/2021/02/05/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Contest%20210205/"><i class="fas fa-angle-double-right"></i>【小记】Contest 210205</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-02-05</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><span> / </span><a class="link-muted" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">线性动态规划</a><span> / </span><a class="link-muted" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span> / </span><a class="link-muted" href="/categories/%E6%AF%94%E8%B5%9B/%E6%A0%A1%E5%86%85%E6%B5%8B/">校内测</a></span><span class="level-item"><i class="far fa-clock"></i> 8 分钟读完 (大约1168个字)</span></div></div><div class="content"><p>在210205的校内测试.包含模拟,动态规划等算法.</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划, </a><a class="link-muted" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解, </a><a class="link-muted" rel="tag" href="/tags/%E6%AF%94%E8%B5%9B/">比赛, </a><a class="link-muted" rel="tag" href="/tags/%E6%A8%A1%E6%8B%9F/">模拟 </a></div><a class="article-more button is-small is-size-7" href="/2021/02/05/%E3%80%90%E5%B0%8F%E8%AE%B0%E3%80%91Contest%20210205/#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">1</a></li><li><a class="pagination-link" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-96x96 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/04bb1eeaf09cf88b5d30d135fd495eb9?s=96" alt="滑蒻稽"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">滑蒻稽</p><p class="is-size-6 is-block">这写的什么玩意,博主上过小学吗?</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Chengdu, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">文章</p><div><p class="title">125</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/